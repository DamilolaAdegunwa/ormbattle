<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Xtensive.Core</name>
    </assembly>
    <members>
        <member name="T:Xtensive.Core.Arithmetic.Arithmetic`1">
            <summary>
            Provides delegates allowing to call <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> methods faster.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> generic argument.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Helpers.MethodCacheBase`1">
            <summary>
            Base class for any method caching class.
            </summary>
            <typeparam name="TImplementation">The type of <see cref="F:Xtensive.Core.Helpers.MethodCacheBase`1.Implementation"/>.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Helpers.MethodCacheBase`1.Implementation">
            <summary>
            Gets underlying implementation object or interface.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.MethodCacheBase`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation"><see cref="F:Xtensive.Core.Helpers.MethodCacheBase`1.Implementation"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Helpers.MethodCacheBase`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Helpers.MethodCacheBase`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Provider">
            <summary>
            Gets the provider underlying arithmetic is associated with.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Zero">
            <summary>
            Gets "<see langword="Zero"/>" value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.One">
            <summary>
            Gets "<see langword="One"/>" value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.MaxValue">
            <summary>
            Gets the maximal value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.MinValue">
            <summary>
            Gets the minimal value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.IsSigned">
            <summary>
            Gets the signed flag.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Add">
            <summary>
            Adds one value to another.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Negation">
            <summary>
            Gets negation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Multiply">
            <summary>
            Multiplies value by specified factor.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Divide">
            <summary>
            Divides value by specified factor.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.Subtract">
            <summary>
            Subtracts one value from another.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Arithmetic`1.ApplyRules">
            <summary>
            Creates a new instance of <see cref="T:Xtensive.Core.Arithmetic.Arithmetic`1"/> 
            with specified arithmetic rules applied.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Arithmetic`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="info">The info.</param>
            <param name="context">The context.</param>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Arithmetic`1.#ctor(Xtensive.Core.Arithmetic.IArithmetic{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation"><see cref="!:Implementation"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Arithmetic`1.Default">
            <summary>
            Gets default arithmetic for type <typeparamref name="T"/>
            (uses <see cref="P:Xtensive.Core.Arithmetic.ArithmeticProvider.Default"/> <see cref="T:Xtensive.Core.Arithmetic.ArithmeticProvider"/>).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.ArithmeticBase`1">
            <summary>
            Base class for <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> implementations.
            </summary>
            <typeparam name="T">Type to provide arithmetic operations for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.IArithmetic`1">
            <summary>
            Provides arithmetic operations for specified type.
            </summary>
            <typeparam name="T">Type to provide arithmetic operations for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.IArithmeticBase">
            <summary>
            Very base interface for any arithmetic implementation 
            supported by <see cref="T:Xtensive.Core.Arithmetic.IArithmeticProvider"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.IArithmeticBase.Provider">
            <summary>
            Gets the provider this arithmetic is associated with.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmetic`1.Add(`0,`0)">
            <summary>
            Adds one value to another.
            </summary>
            <param name="value1">First summand.</param>
            <param name="value2">Second summand.</param>
            <returns>Sum of <paramref name="value1"/> and <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmetic`1.Negation(`0)">
            <summary>
            Gets negation.
            </summary>
            <param name="value">Value to get negation for.</param>
            <returns>Negation of <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmetic`1.Multiply(`0,System.Double)">
            <summary>
            Multiplies value by specified factor.
            </summary>
            <param name="value">Value to multiply.</param>
            <param name="factor">Factor.</param>
            <returns>Multiplication of <paramref name="value"/> by <paramref name="factor"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmetic`1.Divide(`0,System.Double)">
            <summary>
            Divides value by specified factor.
            </summary>
            <param name="value">Value to divide.</param>
            <param name="factor">Factor.</param>
            <returns>Quotient of <paramref name="value"/> by <paramref name="factor"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmetic`1.Subtract(`0,`0)">
            <summary>
            Subtracts one value from another.
            </summary>
            <param name="value1">Value to subtract from.</param>
            <param name="value2">Deduction</param>
            <returns>Subtraction of <paramref name="value1"/> and <paramref name="value2"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmetic`1.ApplyRules(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            Creates a new instance of <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> 
            with specified arithmetic rules applied.
            </summary>
            <param name="rules">Rules to apply (relatively to <see cref="T:Xtensive.Core.Arithmetic.ArithmeticRules"/> of this arithmetic).</param>
            <returns>New instance of <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.IArithmetic`1.Zero">
            <summary>
            Gets "<see langword="Zero"/>" value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.IArithmetic`1.One">
            <summary>
            Gets "<see langword="One"/>" value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.IArithmetic`1.MaxValue">
            <summary>
            Gets the maximal value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.IArithmetic`1.MinValue">
            <summary>
            Gets the minimal value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.IArithmetic`1.IsSigned">
            <summary>
            Gets the signed flag.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticBase`1.OverflowAllowed">
            <summary>
            Indicates whether overflow is allowed (doesn't lead to an exception)
            on arithmetic operations.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticBase`1.NullIsZero">
            <summary>
            Indicates whether <see langword="null"/> value is threated as zero
            in arithmetic operations.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticBase`1.Rules">
            <summary>
            Gets <see cref="T:Xtensive.Core.Arithmetic.ArithmeticRules"/> used by this arithmetic.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.Add(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.Subtract(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.ApplyRules(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            Creates a new instance of <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> 
            with specified arithmetic rules applied.
            </summary>
            <param name="rules">Rules to apply (relatively to <see cref="T:Xtensive.Core.Arithmetic.ArithmeticRules"/> of this arithmetic).</param>
            <returns>New instance of <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            Creates new arithmetic of the same type, but using different arithmetic rules.
            </summary>
            <param name="rules">Arithmetic rules for the new arithmetic (relatively to this one).</param>
            <returns>New arithmetic of the same type, but using different arithmetic rules.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.Negation(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.Multiply(`0,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.Divide(`0,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Arithmetic provider this arithmetic is bound to.</param>
            <param name="rules">Arithmetic rules.</param>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticBase`1.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)"/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticBase`1.Provider">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticBase`1.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticBase`1.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticBase`1.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticBase`1.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticBase`1.IsSigned">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.ArithmeticProvider">
            <summary>
            Default <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> provider. 
            Provides default arithmetic for the specified type.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
            <assert>
            <summary>
            Default <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> provider. 
            Provides default arithmetic for the specified type.
            </summary>
            <remarks>
            <para id="About">
            This class has default instance - use its <see cref="P:Xtensive.Core.Arithmetic.ArithmeticProvider.Default"/>
            property to get it.
            </para>
            </remarks>
            </assert>
        </member>
        <member name="T:Xtensive.Core.IoC.AssociateProvider">
            <summary>
            Implements base functionality for associate provider.
            Creates and caches associates.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.AddHighPriorityLocation(System.Reflection.Assembly,System.String)">
            <summary>
            Adds high priority location for associate search.
            </summary>
            <param name="assembly">Assembly to search in.</param>
            <param name="nameSpace">Namespace to search in.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.AddHighPriorityLocation(System.Reflection.Assembly,System.String,System.Boolean)">
            <summary>
            Adds high priority location for associate search.
            </summary>
            <param name="assembly">Assembly to search in.</param>
            <param name="nameSpace">Namespace to search in.</param>
            <param name="overriding">Indicates whether specified location should 
            override all the others (i.e. be a first in the list of locations).</param>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.GetAssociate``3">
            <summary>
            Gets associate instance for specified parameter and result types.
            All associate instances are cached and returned on the same calls further.
            </summary>
            <typeparam name="TKey">Type to provide the associate for.</typeparam>
            <typeparam name="TAssociate">Type of result to provide the associate for.</typeparam>
            <typeparam name="TResult">The type of result.</typeparam>
            <returns>Associate instance, if found;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.GetAssociate``4">
            <summary>
            Gets associate instance for specified parameters and result types.
            All associate created instances are cached and returned on the same calls further.
            </summary>
            <typeparam name="TKey1">First type to try to provide the associate for.</typeparam>
            <typeparam name="TKey2">Second type to try to provide the associate for.</typeparam>
            <typeparam name="TAssociate">Type of result to provide the associate for.</typeparam>
            <typeparam name="TResult">The type of result.</typeparam>
            <returns>Associate instance, if found;
            otherwise, <see langword="null"/>.</returns>
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.PreferAssociate``3(``2,``2)">
            <summary>
            Chooses preferred associate instance from two associates.
            </summary>
            <param name="associate1">First choice option.</param>
            <param name="associate2">Second choice option.</param>
            <typeparam name="TKey1">First associate key type.</typeparam>
            <typeparam name="TKey2">Second associate key type.</typeparam>
            <typeparam name="TAssociate">Type of associate to choose.</typeparam>
            <returns>Preferred associate instance.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.GetAssociateLocationPosition``1(``0)">
            <summary>
            Gets the position of specified associate in <see cref="P:Xtensive.Core.IoC.AssociateProvider.HighPriorityLocations"/>
            list.
            </summary>
            <param name="associate">Associate to get the position for.</param>
            <typeparam name="TAssociate">Type of associate.</typeparam>
            <returns>Associate position. <see cref="F:System.Int32.MaxValue"/>, if its
            location isn't listed in <see cref="P:Xtensive.Core.IoC.AssociateProvider.HighPriorityLocations"/> list.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.CreateAssociate``2(System.Type@)">
            <summary>
            Creates associate instance for specified parameter and result types.
            </summary>
            <typeparam name="TKey">Type to create the associate for.</typeparam>
            <typeparam name="TAssociate">Type of result to create the associate for.</typeparam>
            <param name="foundFor">The type associate was found for.</param>
            <returns>Newly created instance of associate, if found;
            otherwise, <see langword="null"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Recursive associate lookup.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.CreateCustomAssociate``3">
            <summary>
            Creates associate by some custom way if no standard associate is found. 
            Override it to create the associate manually.
            </summary>
            <typeparam name="TKey1">First type to try to provide the associate for.</typeparam>
            <typeparam name="TKey2">Second type to try to provide the associate for.</typeparam>
            <typeparam name="TAssociate">Type of result to provide the associate for.</typeparam>
            <returns>Associate instance or <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.ConvertAssociate``3(``1)">
            <summary>
            Converts <paramref name="associate"/> to <typeparamref name="TResult"/> object.
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TAssociate">The type of associate.</typeparam>
            <typeparam name="TResult">The type of result.</typeparam>
            <param name="associate">Associate to convert to result.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.ConvertAssociate``4(``2)">
            <summary>
            Converts <paramref name="associate"/> to <typeparamref name="TResult"/> object.
            </summary>
            <typeparam name="TKey1">The type of key 1.</typeparam>
            <typeparam name="TKey2">The type of key 2.</typeparam>
            <typeparam name="TAssociate">The type of associate.</typeparam>
            <typeparam name="TResult">The type of result.</typeparam>
            <param name="associate">Associate to convert to result.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.AssociateProvider.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)"/>
        </member>
        <member name="P:Xtensive.Core.IoC.AssociateProvider.ConstructorParams">
            <summary>
            Gets associate constructor parameters.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.AssociateProvider.TypeSuffixes">
            <summary>
            Gets or sets associate type suffixes.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.AssociateProvider.HighPriorityLocations">
            <summary>
            Gets a list of high priority locations.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.IArithmeticProvider">
            <summary>
            Arithmetic provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.IArithmeticProvider.GetArithmetic``1">
            <summary>
            Gets <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> for the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to get the arithmetic for.</typeparam>
            <returns><see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> for the specified type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticProvider.GetArithmetic``1">
            <summary>
            Gets <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> for the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to get the arithmetic for.</typeparam>
            <returns><see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> for the specified type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticProvider.ConvertAssociate``3(``1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.ArithmeticRules">
            <summary>
            Describes how to calculate arithmetics.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticRules.Equals(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticRules.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticRules.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticRules.#ctor(Xtensive.Core.Arithmetic.NullBehavior,Xtensive.Core.Arithmetic.OverflowBehavior)">
            <summary>
            Creates new instance of <see cref="T:Xtensive.Core.Arithmetic.ArithmeticRules"/>.
            </summary>
            <param name="nullBehavior">Null behavior.</param>
            <param name="overflowBehavior">Overflow behavior.</param>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticRules.OverflowBehavior">
            <summary>
            Gets overflow behavior.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ArithmeticRules.NullBehavior">
            <summary>
            Gets null behavior.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.ArithmeticStruct`1">
            <summary>
            A struct providing faster access for key <see cref="!:Arithmetic&lt;T&gt;"/> delegates.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Default">
            <summary>
            Gets <see cref="T:Xtensive.Core.Arithmetic.ArithmeticStruct`1"/> for <see cref="!:Arithmetic&lt;T&gt;.Default"/> arithmetic.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Arithmetic">
            <summary>
            Gets the underlying arithmetic for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Zero">
            <summary>
            Gets "<see langword="Zero"/>" value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.One">
            <summary>
            Gets "<see langword="One"/>" value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.MaxValue">
            <summary>
            Gets the maximal value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.MinValue">
            <summary>
            Gets the minimal value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.IsSigned">
            <summary>
            Gets the signed flag.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Add">
            <summary>
            Adds one value to another.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Negation">
            <summary>
            Gets negation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Multiply">
            <summary>
            Multiplies value by specified factor.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Divide">
            <summary>
            Divides value by specified factor.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.Subtract">
            <summary>
            Subtracts one value from another.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.ArithmeticStruct`1.ApplyRules">
            <summary>
            Creates a new instance of <see cref="!:Arithmetic&lt;T&gt;"/> 
            with specified arithmetic rules applied.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticStruct`1.op_Implicit(Xtensive.Core.Arithmetic.Arithmetic{`0})~Xtensive.Core.Arithmetic.ArithmeticStruct{`0}">
            <summary>
            Implicit conversion of <see cref="!:Arithmetic&lt;T&gt;"/> to <see cref="T:Xtensive.Core.Arithmetic.ArithmeticStruct`1"/>.
            </summary>
            <param name="arithmetic">Arithmetic to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticStruct`1.#ctor(Xtensive.Core.Arithmetic.Arithmetic{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="arithmetic">Arithmetic to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticStruct`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ArithmeticStruct`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.Add(System.Byte,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.Negation(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.Subtract(System.Byte,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.Multiply(System.Byte,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.Divide(System.Byte,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.ByteArithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ByteArithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ByteArithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ByteArithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ByteArithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.ByteArithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.Add(System.SByte,System.SByte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.Negation(System.SByte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.Subtract(System.SByte,System.SByte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.Multiply(System.SByte,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.Divide(System.SByte,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SByteArithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SByteArithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SByteArithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SByteArithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SByteArithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SByteArithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.Add(System.Char,System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.Negation(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.Subtract(System.Char,System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.Multiply(System.Char,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.Divide(System.Char,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.CharArithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.CharArithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.CharArithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.CharArithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.CharArithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.CharArithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.Add(System.Int16,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.Negation(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.Subtract(System.Int16,System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.Multiply(System.Int16,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.Divide(System.Int16,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int16Arithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int16Arithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int16Arithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int16Arithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int16Arithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int16Arithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.Add(System.UInt16,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.Negation(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.Subtract(System.UInt16,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.Multiply(System.UInt16,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.Divide(System.UInt16,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt16Arithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt16Arithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt16Arithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt16Arithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt16Arithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt16Arithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.Add(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.Negation(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.Subtract(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.Multiply(System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.Divide(System.Int32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int32Arithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int32Arithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int32Arithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int32Arithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int32Arithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int32Arithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.Add(System.UInt32,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.Negation(System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.Subtract(System.UInt32,System.UInt32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.Multiply(System.UInt32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.Divide(System.UInt32,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt32Arithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt32Arithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt32Arithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt32Arithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt32Arithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt32Arithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.Add(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.Negation(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.Subtract(System.Int64,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.Multiply(System.Int64,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.Divide(System.Int64,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.Int64Arithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int64Arithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int64Arithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int64Arithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int64Arithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.Int64Arithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.Add(System.UInt64,System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.Negation(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.Subtract(System.UInt64,System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.Multiply(System.UInt64,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.Divide(System.UInt64,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.UInt64Arithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt64Arithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt64Arithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt64Arithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt64Arithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.UInt64Arithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.Add(System.Decimal,System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.Negation(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.Subtract(System.Decimal,System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.Multiply(System.Decimal,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.Divide(System.Decimal,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DecimalArithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DecimalArithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DecimalArithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DecimalArithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DecimalArithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DecimalArithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.Add(System.Single,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.Negation(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.Subtract(System.Single,System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.Multiply(System.Single,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.Divide(System.Single,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.SingleArithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SingleArithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SingleArithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SingleArithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SingleArithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.SingleArithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.Add(System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.Negation(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.Subtract(System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.Multiply(System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.Divide(System.Double,System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.DoubleArithmetic.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DoubleArithmetic.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DoubleArithmetic.One">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DoubleArithmetic.MaxValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DoubleArithmetic.MinValue">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.DoubleArithmetic.IsSigned">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogTemplate`1">
            <summary>
            Log template - simplifies logging,
            provides support for <see cref="T:Xtensive.Core.Diagnostics.LogCaptureScope"/>.
            </summary>
            <typeparam name="T">Should always be the type of descendant.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.IsLogged(Xtensive.Core.Diagnostics.LogEventTypes)">
            <see cref="M:Xtensive.Core.Diagnostics.ILogBase.IsLogged(Xtensive.Core.Diagnostics.LogEventTypes)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Debug(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Debug(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Debug(System.Exception,System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Debug(System.Exception,System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Debug(System.Exception)">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Debug(System.Exception)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.DebugRegion(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.DebugRegion(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Info(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Info(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Info(System.Exception,System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Info(System.Exception,System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Info(System.Exception)">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Info(System.Exception)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.InfoRegion(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.InfoRegion(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Warning(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Warning(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Warning(System.Exception,System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Warning(System.Exception,System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Warning(System.Exception)">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Warning(System.Exception)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Error(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Error(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Error(System.Exception,System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Error(System.Exception,System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.Error(System.Exception)">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.Error(System.Exception)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.FatalError(System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.FatalError(System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.FatalError(System.Exception,System.String,System.Object[])">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.FatalError(System.Exception,System.String,System.Object[])" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogTemplate`1.FatalError(System.Exception)">
            <see cref="M:Xtensive.Core.Diagnostics.ILog.FatalError(System.Exception)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogTemplate`1.Instance">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> this type logs to.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.NullBehavior">
            <summary>
            Describes how arithmetics treats <see langword="null"/> in operations.   
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.NullBehavior.Default">
            <summary>
            Default <see langword="null"/> behavior.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.NullBehavior.ThreatNullAsZero">
            <summary>
            Treats <see langword="null"/> as <see langword="zero"/> in additions and subtractions.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.NullBehavior.ThreatNullAsNull">
            <summary>
            Treats <see langword="null"/> as is in additions and subtractions. If one of parameters is null, the result will be always null.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.OverflowBehavior">
            <summary>
            Describes arithmetic overflow behavior.   
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.OverflowBehavior.Default">
            <summary>
            Default overflow behaviour.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.OverflowBehavior.DenyOverflow">
            <summary>
            Overflow is suppressed.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.OverflowBehavior.AllowOverflow">
            <summary>
            Overflow is allowed.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Arithmetic.WrappingArithmetic`2">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/>s.
            </summary>
            <typeparam name="T">The type to provide arithmetic operations for.</typeparam>
            <typeparam name="TBase">Base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Arithmetic.WrappingArithmetic`2.BaseArithmetic">
            <summary>
            Arithmetic delegates for <typeparamref name="TBase"/> type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.WrappingArithmetic`2.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Arithmetic provider this instance is bound to.</param>
            <param name="rules">Arithmetic rules.</param>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.Add(System.Nullable{`0},System.Nullable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.Negation(System.Nullable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.Subtract(System.Nullable{`0},System.Nullable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.Multiply(System.Nullable{`0},System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.Divide(System.Nullable{`0},System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.CreateNew(Xtensive.Core.Arithmetic.ArithmeticRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Arithmetic.NullableArithmetic`1.#ctor(Xtensive.Core.Arithmetic.IArithmeticProvider,Xtensive.Core.Arithmetic.ArithmeticRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.NullableArithmetic`1.Zero">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Arithmetic.NullableArithmetic`1.One">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Caching.ThreadSafeCache`2">
            <summary>
            A thread-safe wrapper for any <see cref="T:Xtensive.Core.Caching.ICache`2"/> implementation.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Caching.ICache`2">
            <summary>
            Cache contract.
            </summary>
            <typeparam name="TKey">The type of the cache key.</typeparam>
            <typeparam name="TItem">The type of the item to cached.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Caching.IInvalidatable">
            <summary>
            Invalidatable object contract.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.IInvalidatable.Invalidate">
            <summary>
            Invalidates the state of this object.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.ICountable`1">
            <summary>
            Exposes the a number of elements and the enumerator over a collection of a specified type.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Collections.ICountable">
            <summary>
            Exposes the a number of elements and the enumerator over a collection of a specified type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.ICountable.Count">
            <summary>
            Gets the number of elements contained in a collection.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.TryGetItem(`0,System.Boolean,`1@)">
            <summary>
            Tries to get cached item by its <paramref name="key"/>.
            </summary>
            <param name="key">The key of the item to get.</param>
            <param name="markAsHit">Indicates whether the item with specified key
            should be marked as hit.</param>
            <param name="item">The item, if found.</param>
            <returns>
            <see langword="true" />, if the item is found;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.Contains(`1)">
            <summary>
            Determines whether cache contains the specified item.
            </summary>
            <param name="item">The item to check.</param>
            <returns>
            <see langword="True"/> if cache contains the specified item; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.ContainsKey(`0)">
            <summary>
            Determines whether cache contains the item with specified key.
            </summary>
            <param name="key">The key to check.</param>
            <returns>
            <see langword="True"/> if cache contains the item with specified key; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.Add(`1)">
            <summary>
            Adds a new item to the cache. If item with this key is already in cache - replaces is with new item.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.Add(`1,System.Boolean)">
            <summary>
            Adds a new item to the cache.
            </summary>
            <param name="item">The item to add.</param>
            <param name="replaceIfExists">Indicates whether existing item must be replaced or not.</param>
            <returns>An existing, or a newly added item.</returns>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.Remove(`1)">
            <summary>
            Removes the specified <paramref name="item"/> from the cache.
            </summary>
            <param name="item">The item to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.RemoveKey(`0)">
            <summary>
            Removes the item with specified <paramref name="key"/> from the cache.
            </summary>
            <param name="key">The key of the item to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.ICache`2.Clear">
            <summary>
             Clears the cache.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.ICache`2.Count">
            <summary>
            Gets the count of cached items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.ICache`2.KeyExtractor">
            <summary>
            Gets the item key extractor.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.ICache`2.ChainedCache">
            <summary>
            Gets the chained cache, if any.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.ICache`2.Item(`0,System.Boolean)">
            <summary>
            Gets cached item by its <paramref name="key"/>.
            </summary>
            <param name="key">The key of the item to get.</param>
            <param name="markAsHit">Indicates whether the item with specified key 
            should be marked as hit.</param>
            <returns>Item, if found; 
            otherwise, <see langword="default(TItem)"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.Threading.ISynchronizable">
            <summary>
            Describes an object that supports synchronized access to it.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Threading.IHasSyncRoot">
            <summary>
            Describes an object that has <see cref="P:Xtensive.Core.Threading.IHasSyncRoot.SyncRoot"/> property.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Threading.IHasSyncRoot.SyncRoot">
            <summary>
            Gets or sets the synchronization root of the object.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Threading.ISynchronizable.IsSynchronized">
            <summary>
            Indicates whether object supports synchronized access to it, or not.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.#ctor(Xtensive.Core.Caching.ICache{`0,`1},System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="chainedCache">The chained cache.</param>
            <param name="syncRoot">The sync root.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.ThreadSafeCache`2.#ctor(Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="chainedCache">The chained cache.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.ChainedCache">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.ThreadSafeCache`2.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.BinarySerializable`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.BinarySerializable`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="P:Xtensive.Core.Helpers.BinarySerializable`1.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Caching.CachedSequence`1">
            <summary>
            Cached sequence wrapper.
            Wraps a cached value containing a sequence and exposes 
            it as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of element in sequence.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Caching.ICachedValue`1">
            <summary>
            Cached value contract.
            </summary>
            <typeparam name="T">The type of the <see cref="P:Xtensive.Core.Caching.ICachedValue`1.Value"/>.</typeparam>
        </member>
        <member name="P:Xtensive.Core.Caching.ICachedValue`1.Value">
            <summary>
            Gets the cached value.
            if it isn't actual (see <see cref="P:Xtensive.Core.Caching.ICachedValue`1.IsActual"/>),
            the value will be refreshed.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.ICachedValue`1.IsActual">
            <summary>
            Gets a value indicating whether cached <see cref="P:Xtensive.Core.Caching.ICachedValue`1.Value"/> is actual,
            so an attempt to read it will not lead to refresh.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedSequence`1.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedSequence`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedSequence`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedSequence`1.#ctor(Xtensive.Core.Caching.ICachedValue{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="cachedSequence">The sequence to cache.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.CachedSequence`1.Value">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.CachedSequence`1.IsActual">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Caching.Expiring`1">
            <summary>
            Describes expiring <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/>.
            </summary>
            <typeparam name="T">The type of <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/>.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Caching.CachedValueBase`2">
            <summary>
            Abstract base class for storing cached values.
            </summary>
            <typeparam name="TValue">The type of <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/>.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedValueBase`2.Invalidate">
            <summary>
            Invalidates the <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.State"/> by setting its value
            to <c>default(Pair&lt;TValue, TActualizationInfo&gt;)</c>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedValueBase`2.Refresh">
            <summary>
            Refreshes the <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.State"/> when <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/>
            is requested, but state isn't actual (see <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.IsActual"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedValueBase`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedValueBase`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedValueBase`2.#ctor(System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="syncRoot">The object to synchronize for duration of
            <see cref="M:Xtensive.Core.Caching.CachedValueBase`2.Refresh"/> method call; 
            <see langword="null"/> means no synchronization is implied.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.CachedValueBase`2.#ctor(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="syncOnItself">If set to <see langword="true"/>, this instance
            will synchronize on itself while invoking <see cref="M:Xtensive.Core.Caching.CachedValueBase`2.Refresh"/> method;
            otherwise it won't synchronize at all.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.CachedValueBase`2.Value">
            <summary>
            Gets the value; 
            if the <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.State"/> isn't actual (see <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.IsActual"/>),
            the value will be recalculated by <see cref="M:Xtensive.Core.Caching.CachedValueBase`2.Refresh"/> method.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.CachedValueBase`2.State">
            <summary>
            Gets the underlying state of this object.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.CachedValueBase`2.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.CachedValueBase`2.IsActual">
            <summary>
            Gets a value indicating whether <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> is actual,
            so an attempt to read it will not lead to invocation of
            <see cref="M:Xtensive.Core.Caching.CachedValueBase`2.Refresh"/> method.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.Refresh">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Func{`0,System.DateTime,Xtensive.Core.Pair{`0,System.DateTime}})">
            <inheritdoc/>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Func{Xtensive.Core.Pair{`0,System.DateTime}})">
            <inheritdoc/>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.TimeSpan,System.Func{`0})">
            <inheritdoc/>
            <param name="expiresIn">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> expiration period.</param>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Object,System.Func{`0,System.DateTime,Xtensive.Core.Pair{`0,System.DateTime}})">
            <inheritdoc/>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Object,System.Func{Xtensive.Core.Pair{`0,System.DateTime}})">
            <inheritdoc/>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Object,System.TimeSpan,System.Func{`0})">
            <inheritdoc/>
            <param name="expiresIn">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> expiration period.</param>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Boolean,System.Func{`0,System.DateTime,Xtensive.Core.Pair{`0,System.DateTime}})">
            <inheritdoc/>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Boolean,System.Func{Xtensive.Core.Pair{`0,System.DateTime}})">
            <inheritdoc/>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.Expiring`1.#ctor(System.Boolean,System.TimeSpan,System.Func{`0})">
            <inheritdoc/>
            <param name="expiresIn">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> expiration period.</param>
            <param name="calculator">The <see cref="P:Xtensive.Core.Caching.CachedValueBase`2.Value"/> calculator.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.Expiring`1.IsActual">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Caching.InfiniteCache`2">
            <summary>
            An unlimited set of items.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.#ctor(System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.InfiniteCache`2.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.InfiniteCache`2.#ctor(System.Int32,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="capacity">The capacity of cache.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.InfiniteCache`2.KeyExtractor"/> property value.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>capacity</c> is out of range.</exception>
        </member>
        <member name="P:Xtensive.Core.Caching.InfiniteCache`2.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.InfiniteCache`2.ChainedCache">
            <summary>
            <inheritdoc/>
            This method always returns <see langword="null" /> in this type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.InfiniteCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.InfiniteCache`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.InfiniteCache`2.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Caching.LruCache`2">
            <summary>
            A set of items limited by the maximal amount of memory it can use, or by any other measure.
            Stores as many most frequently accessed items in memory as long as it is possible
            while maintaining the total size of cached items less or equal to <see cref="P:Xtensive.Core.Caching.LruCache`2.MaxSize"/>.
            </summary>
            <typeparam name="TKey">The key of the item.</typeparam>
            <typeparam name="TItem">The type of the item to cache.</typeparam>
        </member>
        <member name="T:Xtensive.Core.IHasSize">
            <summary>
            Describes an object that able to calculate its own size.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHasSize.Size">
            <summary>
            Gets size of the instance in bytes.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.#ctor(System.Int64,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`2.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`2.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.#ctor(System.Int64,System.Converter{`1,`0},System.Func{`1,System.Int64})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`2.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`2.KeyExtractor"/> property value.</param>
            <param name="sizeExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`2.SizeExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.#ctor(System.Int64,System.Converter{`1,`0},Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`2.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`2.KeyExtractor"/> property value.</param>
            <param name="chainedCache"><see cref="P:Xtensive.Core.Caching.LruCache`2.ChainedCache"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`2.#ctor(System.Int64,System.Converter{`1,`0},System.Func{`1,System.Int64},Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`2.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`2.KeyExtractor"/> property value.</param>
            <param name="sizeExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`2.SizeExtractor"/> property value.</param>
            <param name="chainedCache"><see cref="P:Xtensive.Core.Caching.LruCache`2.ChainedCache"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.SizeExtractor">
            <summary>
            Gets the size extractor delegate.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.ChainedCache">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.MaxSize">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.Size">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`2.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Caching.WeakestCache`2">
            <summary>
            A set of weekly referenced items identified by weekly referenced keys.
            Stores the references while the underlying keys or items aren't collected by GC.
            </summary>
            <typeparam name="TKey">The key of the item.</typeparam>
            <typeparam name="TItem">The type of the item to cache.</typeparam>
        </member>
        <member name="T:Xtensive.Core.IHasGarbage">
            <summary>
            Describes a class that might have some "garbage" inside it during the operation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IHasGarbage.CollectGarbage">
            <summary>
            Collects the garbage.
            </summary>
            <remarks>
            <note type="caution" id="Caution">This method usually takes the time proportional to the size of the object it is invoked on.</note>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.Caching.WeakestCache`2.NoGcCount">
            <summary>
            Minimal <see cref="P:Xtensive.Core.Caching.WeakestCache`2.Count"/> value, until which <see cref="M:Xtensive.Core.Caching.WeakestCache`2.CollectGarbage"/> doesn't start at all.
            Value is <see langword="1024"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.CollectGarbage">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.#ctor(System.Boolean,System.Boolean,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="trackKeyResurrection">The <see cref="P:Xtensive.Core.Caching.WeakestCache`2.TrackKeyResurrection"/> property value.</param>
            <param name="trackItemResurrection">The <see cref="P:Xtensive.Core.Caching.WeakestCache`2.TrackItemResurrection"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.WeakestCache`2.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakestCache`2.Finalize">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor" copy="true"/>
            /// </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.ChainedCache">
            <summary>
            Always <see langword="null" /> in this class.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.TrackKeyResurrection">
            <summary>
            Gets a value indicating whether this cache tracks key resurrection.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.TrackItemResurrection">
            <summary>
            Gets a value indicating whether this cache tracks item resurrection.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakestCache`2.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Caching.WeakCache`2">
            <summary>
            A set of weekly referenced items.
            Stores the references while the underlying items aren't collected by GC.
            </summary>
            <typeparam name="TKey">The key of the item.</typeparam>
            <typeparam name="TItem">The type of the item to cache.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Caching.WeakCache`2.DefaultEfficiencyFactor">
            <summary>
            Default <see cref="!:EfficiencyFactor"/> value.
            Value is <see langword="1"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Caching.WeakCache`2.NoGcCount">
            <summary>
            Minimal <see cref="P:Xtensive.Core.Caching.WeakCache`2.Count"/> value, until which <see cref="M:Xtensive.Core.Caching.WeakCache`2.CollectGarbage"/> doesn't start at all.
            Value is <see langword="1024"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Caching.WeakCache`2.ImmediateGcCount">
            <summary>
            Maximal <see cref="P:Xtensive.Core.Caching.WeakCache`2.Count"/> value, at which <see cref="M:Xtensive.Core.Caching.WeakCache`2.CollectGarbage"/> starts immediately.
            Value is <see langword="64*1024*1024"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.CollectGarbage">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.#ctor(System.Boolean,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="trackResurrection">The <see cref="P:Xtensive.Core.Caching.WeakCache`2.TrackResurrection"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.WeakCache`2.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.WeakCache`2.Finalize">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor" copy="true"/>
            /// </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakCache`2.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakCache`2.ChainedCache">
            <summary>
            Always <see langword="null" /> in this class.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakCache`2.TrackResurrection">
            <summary>
            Gets a value indicating whether this cache tracks resurrection.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakCache`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.WeakCache`2.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.IOperationSequence">
            <summary>
            General operation sequence contract.
            Allows to replay the operations contained in it later.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IOperationSequence.Replay(System.Object)">
            <summary>
            Replays the operations contained in sequence on <paramref name="target"/> object.
            </summary>
            <param name="target">The target object to replay the sequence at.</param>
            <returns>The result of execution.</returns>
        </member>
        <member name="T:Xtensive.Core.IoC.ServiceConstructorAttribute">
            <summary>
            An attribute tagging default service constructor to use.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.MemberCompilerProvider`1">
            <summary>
            Default implementation of <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/>.
            </summary>
            <typeparam name="T"><inheritdoc/></typeparam>
        </member>
        <member name="T:Xtensive.Core.Helpers.LockableBase">
            <summary>
            Base class for <see cref="T:Xtensive.Core.ILockable"/> implementors.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ILockable">
            <summary>
            Lockable contract.
            Should be implemented by classes, that can
            became immutable at some point of time.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ILockable.Lock">
            <summary>
            Locks the instance (non-recursively).
            </summary>
        </member>
        <member name="M:Xtensive.Core.ILockable.Lock(System.Boolean)">
            <summary>
            Locks the instance and (possibly) all dependent objects.
            </summary>
            <param name="recursive"><see langword="True"/> if all dependent objects should be locked as well.</param>
        </member>
        <member name="P:Xtensive.Core.ILockable.IsLocked">
            <summary>
            Determines whether the instance of class implementing this interface
            is immutable (locked).
            </summary>
            <remarks>
            The implementor of setter of this property should consider, that this
            property should not change its value from <see langword="true"/> to 
            <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Helpers.LockableBase.Lock">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.LockableBase.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.LockableBase.Unlock">
            <summary>
            Unlocks the object.
            Sets <see cref="P:Xtensive.Core.Helpers.LockableBase.IsLocked"/> to <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.LockableBase.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.LockableBase.#ctor(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isLocked">Initial <see cref="P:Xtensive.Core.Helpers.LockableBase.IsLocked"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Helpers.LockableBase.IsLocked">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Linq.IMemberCompilerProvider`1">
            <summary>
            Interface for compiler providers.
            </summary>
            <typeparam name="T">Type which compiler should produce.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Linq.IMemberCompilerProvider.RegisterCompilers(System.Type)">
            <summary>
            Registers compilers found in specified type.
            Conflicts are resolved as <see cref="F:Xtensive.Core.Linq.ConflictHandlingMethod.ReportError"/> were specified.
            </summary>
            <param name="typeWithCompilers">Type to search for compiler methods.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.IMemberCompilerProvider.RegisterCompilers(System.Type,Xtensive.Core.Linq.ConflictHandlingMethod)">
            <summary>
            Registers compilers found in specified type.
            In case of multiple compilers exist for the same <see cref="T:System.Reflection.MethodInfo"/>
            implementor should use specified <see cref="T:Xtensive.Core.Linq.ConflictHandlingMethod"/>.
            </summary>
            <param name="typeWithCompilers">Type to search for compiler methods.</param>
            <param name="conflictHandlingMethod">Determines how provider would resolve conflicts.</param>
        </member>
        <member name="P:Xtensive.Core.Linq.IMemberCompilerProvider.ExpressionType">
            <summary>
            Gets the type of expression.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.IMemberCompilerProvider`1.GetCompiler(System.Reflection.MemberInfo)">
            <summary>
            Finds compiler for specified <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
            <param name="source"><see cref="T:System.Reflection.MemberInfo"/> to search compiler for.</param>
            <returns>compiler associated with <see cref="T:System.Reflection.MethodInfo"/>
            or <see langword="null"/> if compiler is not found.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.IMemberCompilerProvider`1.GetCompiler(System.Reflection.MemberInfo,System.Reflection.MethodInfo@)">
            <summary>
            Finds compiler for specified <see cref="T:System.Reflection.MemberInfo"/>
            </summary>
            <param name="source"><see cref="T:System.Reflection.MemberInfo"/> to search compiler for.</param>
            <param name="compilerMethod"><see cref="T:System.Reflection.MethodInfo"/> of method which is called by returned delegate</param>
            <returns>compiler associated with <see cref="T:System.Reflection.MethodInfo"/>
            or <see langword="null"/> if compiler is not found.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.MemberCompilerProvider`1.GetCompiler(System.Reflection.MemberInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.MemberCompilerProvider`1.GetCompiler(System.Reflection.MemberInfo,System.Reflection.MethodInfo@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.MemberCompilerProvider`1.RegisterCompilers(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.MemberCompilerProvider`1.RegisterCompilers(System.Type,Xtensive.Core.Linq.ConflictHandlingMethod)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Linq.MemberCompilerProvider`1.ExpressionType">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Location">
            <summary>
            A unique identifier of a location.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Location.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Location.Equals(Xtensive.Core.Location)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Location.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Location.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Location.op_Equality(Xtensive.Core.Location,Xtensive.Core.Location)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Location.op_Inequality(Xtensive.Core.Location,Xtensive.Core.Location)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Location.FromUrl(Xtensive.Core.UrlInfo)">
            <summary>
            Builds a <see cref="T:Xtensive.Core.Location"/> from <see cref="T:Xtensive.Core.UrlInfo"/>.
            </summary>
            <param name="url">The URL.</param>
            <returns>Location that corrensponds to <paramref name="url"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Location.#ctor(System.String,System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">The provider.</param>
            <param name="resource">The address.</param>
        </member>
        <member name="P:Xtensive.Core.Location.Provider">
            <summary>
            Gets the provider for this location.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Location.Resource">
            <summary>
            Gets the resource.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.MappingDescription">
            <summary>
            Description of a mapping.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.GetMappedTargetType(System.Type)">
            <summary>
            Gets the target type corresponding to <paramref name="sourceType"/>.
            </summary>
            <param name="sourceType">The source type.</param>
            <returns>The description of the target type.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.GetMappedSourceType(System.Type)">
            <summary>
            Gets the source type corresponding to <paramref name="targetType"/>.
            </summary>
            <param name="targetType">The source type.</param>
            <returns>The description of the source type.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.GetTargetType(System.Type)">
            <summary>
            Gets the description of the target type.
            </summary>
            <param name="targetType">The target system type.</param>
            <returns>The description of the target type.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.GetSourceType(System.Type)">
            <summary>
            Gets the description of the source type.
            </summary>
            <param name="sourceType">The source system type.</param>
            <returns>The description of the source type.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.ExtractTargetKey(System.Object)">
            <summary>
            Extracts a key from an object of a target type.
            </summary>
            <param name="target">The object of the target type.</param>
            <returns>The extracted key.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.MappingDescription.ExtractSourceKey(System.Object)">
            <summary>
            Extracts a key from an object of a source type.
            </summary>
            <param name="source">The object of the source type.</param>
            <returns>The extracted key.</returns>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.MappingDescription.TargetTypes">
            <summary>
            Gets the target types.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.MappingDescription.SourceTypes">
            <summary>
            Gets the source types.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ArraySegmentExtensions">
            <summary>
            <see cref="T:System.ArraySegment`1"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ArraySegmentExtensions.GetItem``1(System.ArraySegment{``0},System.Int32)">
            <summary>
            Gets the element of <see cref="T:System.ArraySegment`1"/> by its index.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="segment">The array segment.</param>
            <param name="index">The index of item.</param>
            <returns>The item from the mapped array segment.</returns>
        </member>
        <member name="M:Xtensive.Core.ArraySegmentExtensions.SetItem``1(System.ArraySegment{``0},System.Int32,``0)">
            <summary>
            Sets the element of <see cref="T:System.ArraySegment`1"/> by its index.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="segment">The array segment.</param>
            <param name="index">The index of the item to set.</param>
        </member>
        <member name="M:Xtensive.Core.ArraySegmentExtensions.AsEnumerable``1(System.ArraySegment{``0})">
            <summary>
            Converts <see cref="T:System.ArraySegment`1"/> to <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of array element.</typeparam>
            <param name="segment">The array segment to convert to a sequence.</param>
            <returns>A sequence enumerating all the items from the array segment.</returns>
        </member>
        <member name="T:Xtensive.Core.Caching.LruCache`3">
            <summary>
            A set of items limited by the maximal amount of memory it can use, or by any other measure.
            Stores as many most frequently accessed items in memory as long as it is possible
            while maintaining the total size of cached items less or equal to <see cref="P:Xtensive.Core.Caching.LruCache`3.MaxSize"/>.
            </summary>
            <typeparam name="TKey">The key of the item.</typeparam>
            <typeparam name="TItem">The type of the item to cache.</typeparam>
            <typeparam name="TCached">The type of cached representation of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.#ctor(System.Int64,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`3.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`3.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.#ctor(System.Int64,System.Converter{`1,`0},Xtensive.Core.Conversion.Biconverter{`1,`2})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`3.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`3.KeyExtractor"/> property value.</param>
            <param name="cacheConverter"><see cref="P:Xtensive.Core.Caching.LruCache`3.CacheConverter"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.#ctor(System.Int64,System.Converter{`1,`0},Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`3.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`3.KeyExtractor"/> property value.</param>
            <param name="chainedCache"><see cref="P:Xtensive.Core.Caching.LruCache`3.ChainedCache"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.LruCache`3.#ctor(System.Int64,System.Converter{`1,`0},Xtensive.Core.Conversion.Biconverter{`1,`2},Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxSize"><see cref="P:Xtensive.Core.Caching.LruCache`3.MaxSize"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.LruCache`3.KeyExtractor"/> property value.</param>
            <param name="cacheConverter"><see cref="P:Xtensive.Core.Caching.LruCache`3.CacheConverter"/> property value.</param>
            <param name="chainedCache"><see cref="P:Xtensive.Core.Caching.LruCache`3.ChainedCache"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.CacheConverter">
            <summary>
            Gets the cache converter.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.ChainedCache">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.MaxSize">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.Size">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.LruCache`3.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.Configuration.TypeRegistrationElement">
            <summary>
            Type registration element within a configuration file.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Configuration.ConfigurationCollectionElementBase">
            <summary>
            Abstract base class for a configuration element within a configuration file
            that is nested to a collection of similar ones.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IIdentified">
            <summary>
            Describes an object having <see cref="P:Xtensive.Core.IIdentified.Identifier"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IIdentified.Identifier">
            <summary>
            Gets object identifier.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationCollectionElementBase.Identifier">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.ToNative">
            <summary>
            Converts the element to a native configuration object it corresponds to - 
            i.e. to a <see cref="T:Xtensive.Core.Collections.TypeRegistration"/> object.
            </summary>
            <returns>The result of conversion.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.Identifier">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.Type">
            <summary>
            Gets or sets the name of the type to register.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.Assembly">
            <summary>
            Gets or sets the assembly where types to register are located.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.Namespace">
            <summary>
            Gets or sets the namespace withing the <see cref="P:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.Assembly"/>, 
            where types to register are located.
            If <see langword="null"/> or <see cref="F:System.String.Empty"/>, 
            all the persistent types from the <see cref="P:Xtensive.Core.Collections.Configuration.TypeRegistrationElement.Assembly"/> will be registered.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.ReadOnlyHashSet`1">
            <summary>
            Read-only set (<see cref="T:Xtensive.Core.Collections.ISet`1"/>) wrapper.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.ISet`1">
            <summary>
            Generic set of items.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet`1.Add(`0)">
            <summary>
            Adds the specified element to the <see cref="T:Xtensive.Core.Collections.ISet`1"/>.
            </summary>
            <param name="item">Item to add to the set.</param>
            <returns><see langword="True"/> if the element is added to the <see cref="T:Xtensive.Core.Collections.ISet`1"/> object; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet`1.RemoveWhere(System.Predicate{`0})">
            <summary>
            Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:Xtensive.Core.Collections.ISet`1"/> collection.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1"/> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements that were removed from the <see cref="T:Xtensive.Core.Collections.ISet`1"/> collection.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.ISet`1.Item(`0)">
            <summary>
            Gets the specified item.
            </summary>
            <value>The item.</value>
        </member>
        <member name="P:Xtensive.Core.Collections.ISet`1.Count">
            <summary>
            Gets the number of elements contained in set.
            </summary>
            <value>The number of elements contained in set.</value>
        </member>
        <member name="P:Xtensive.Core.Collections.ISet`1.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> object 
            that is used to determine equality for the values in this instance.
            </summary>
            <value>The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> object 
            that is used to determine equality for the values in this instance.</value>
        </member>
        <member name="T:Xtensive.Core.IReadOnly">
            <summary>
            Marks that implementing type is read-only analogue of 
            base type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.Add(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.Remove(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.RemoveWhere(System.Predicate{`0})">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.Clear">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.#ctor(System.Collections.Generic.HashSet{`0},System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="set">The set to copy or wrap.</param>
            <param name="copy">Indicates whether <paramref name="set"/> must be copied or wrapped.</param> 
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyHashSet`1.#ctor(System.Collections.Generic.HashSet{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="set">The set to wrap.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyHashSet`1.Item(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyHashSet`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyHashSet`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyHashSet`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyHashSet`1.Comparer">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.DifferentialDictionary`2">
            <summary>
            The dictionary storing its content as difference to its <see cref="P:Xtensive.Core.Collections.DifferentialDictionary`2.Origin"/>.
            <see cref="P:Xtensive.Core.Collections.DifferentialDictionary`2.Origin"/> must not be modified during 
            <see cref="T:Xtensive.Core.Collections.DifferentialDictionary`2"/> lifetime (usage period).
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.ApplyChanges">
            <summary>
            Commits the changes (<see cref="P:Xtensive.Core.Collections.DifferentialDictionary`2.Difference"/>) to the <see cref="P:Xtensive.Core.Collections.DifferentialDictionary`2.Origin"/> dictionary.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.CancelChanges">
            <summary>
            Cancels (cleans up) all the changes (<see cref="P:Xtensive.Core.Collections.DifferentialDictionary`2.Difference"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.Add(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="origin">The original dictionary.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.Origin">
            <summary>
            Gets the origin.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.Difference">
            <summary>
            Gets the difference of the current state with <see cref="P:Xtensive.Core.Collections.DifferentialDictionary`2.Origin"/>.
            This method requires constant time 
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.Item(`0)">
            <summary>
            Gets the <see cref="!:TValue"/> with the specified key.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.Keys">
            <summary>
            <inheritdoc/>
            This property requires <see langword="O(Count)" /> time to return the result.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionary`2.Values">
            <summary>
            <inheritdoc/>
            This property requires <see langword="O(Count)" /> time to return the result.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.DifferentialDictionaryDifference`2">
            <summary>
            Describes complete <see cref="T:Xtensive.Core.Collections.DifferentialDictionary`2"/> change set.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.DifferentialDictionaryDifference`2.#ctor(Xtensive.Core.Collections.ReadOnlyDictionary{`0,`1},Xtensive.Core.Collections.ReadOnlyDictionary{`0,`1},Xtensive.Core.Collections.ReadOnlyHashSet{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="addedItems">The added items.</param>
            <param name="removedItems">The removed items.</param>
            <param name="changedItems">The changed items.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionaryDifference`2.AddedItems">
            <summary>
            Gets added items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionaryDifference`2.RemovedItems">
            <summary>
            Gets removed items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DifferentialDictionaryDifference`2.ChangedItems">
            <summary>
            Gets the keys of all changed items, including keys of added, removed or changed items.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Configuration.ConfigurationSetBase`1">
            <summary>
            Base class for a configuration described by a set of named configurations 
            (<typeparamref name="TItem"/>s) contract.
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate" copy="true"/></para>
            </remarks>
            <typeparam name="TItem">Type of particular named configuration.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Configuration.ConfigurationBase">
            <summary>
            Base class for <see cref="T:Xtensive.Core.IConfiguration"/> implementors.
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.IConfiguration">
            <summary>
            A configuration contract (for <see cref="T:Xtensive.Core.IConfigurable`1"/>).
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate"/></para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.IConfiguration.Validate">
            <summary>
            Validates the configuration.
            Should always be invoked by <see cref="M:Xtensive.Core.ILockable.Lock(System.Boolean)"/> method 
            before actually locking the configuration.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationBase.Validate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationBase.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationBase.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationBase.CreateClone">
            <summary>
            Creates a new instance of this class.
            Used by <see cref="M:Xtensive.Core.Configuration.ConfigurationBase.Clone"/> method implementation.
            </summary>
            <returns>New instance of this class.</returns>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationBase.Clone(Xtensive.Core.Configuration.ConfigurationBase)">
            <summary>
            Copies the properties from the <paramref name="source"/>
            configuration to this one.
            Used by <see cref="M:Xtensive.Core.Configuration.ConfigurationBase.Clone"/> method implementation.
            </summary>
            <param name="source">The configuration to copy properties from.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.IConfigurationSet`1">
            <summary>
            A configuration described by a set of named configurations 
            (<typeparamref name="TItem"/>s) contract.
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate" copy="true"/></para>
            </remarks>
            <typeparam name="TItem">Type of particular named configuration.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IConfigurationSet`1.IndexOf(`0)">
            <summary>
            Determines the index of a specified item in this instance.
            </summary>
            <param name="item">The item.</param>
            <returns>The index of value if found in this instance; otherwise, <see langword="-1"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IConfigurationSet`1.Add(`0)">
            <summary>
            Adds the specified item into this instance.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IConfigurationSet`1.Remove(System.String)">
            <summary>
            Removes the specified item from this instance.
            </summary>
            <param name="name">The name of the item.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IConfigurationSet`1.Clear">
            <summary>
            Removes all the items from this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IConfigurationSet`1.Item(System.String)">
            <summary>
            Gets the item by the specified name.
            </summary>
            <param name="name">Name of the item to get.</param>
            <value><typeparamref name="TItem"/> instance or null.</value>
        </member>
        <member name="P:Xtensive.Core.Collections.IConfigurationSet`1.Item(System.Int32)">
            <summary>
            Gets the item by the specified index.
            </summary>
            <param name="index">Index of the item to get.</param>
            <value><typeparamref name="TItem"/> instance or null.</value>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.GetItemName(`0)">
            <summary>
            Gets the name of the <paramref name="item"/>.
            </summary>
            <param name="item">Item to get the name of.</param>
            <returns>Name of the item.</returns>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.Remove(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.System#Collections#Generic#IEnumerable{Xtensive#Core#Pair{System#String@TItem}}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.Validate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.Clone(Xtensive.Core.Configuration.ConfigurationBase)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSetBase`1.#ctor(`0,`0[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The item to add first.</param>
            <param name="items">The items to add.</param>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationSetBase`1.Items">
            <summary>
            Gets the inner list of the items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationSetBase`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationSetBase`1.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationSetBase`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.ArrayExtensions">
            <summary>
            <see cref="T:System.Array"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Copy``1(``0[])">
            <summary>
            Clones the array.
            </summary>
            <typeparam name="TItem">The type of array items.</typeparam>
            <param name="source">Array to clone.</param>
            <returns>An array containing all the items from the <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Copy``1(``0[],``0[],System.Int32)">
            <summary>
            Copies the items from <paramref name="source"/> array
            to <paramref name="target"/> starting from specified
            <paramref name="targetIndex"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">Source array to copy from.</param>
            <param name="target">Target array to copy to.</param>
            <param name="targetIndex">Index in <paramref name="target"/> array to start from.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetIndex"/> is out of range.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="target"/> array is too small.</exception>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Cast``2(``0[])">
            <summary>
            Clones <paramref name="source"/> array with type case.
            </summary>
            <typeparam name="TItem">The type of source array items.</typeparam>
            <typeparam name="TNewItem">The type of result array items.</typeparam>
            <param name="source">Collection to convert.</param>
            <returns>An array containing all the items from the <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Convert``2(``0[],System.Converter{``0,``1})">
            <summary>
            Clones <paramref name="source"/> array with element conversion.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <typeparam name="TNewItem">The type of item to convert to.</typeparam>
            <param name="source">The array to convert.</param>
            <param name="converter">A delegate that converts each element.</param>
            <returns>An array of converted elements.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.IndexOf``1(``0[],``0)">
            <summary>
            Gets the index of first occurrence of the <paramref name="item"/>
            in the <paramref name="items"/> array, if found;
            otherwise returns <see langword="-1"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="items">Array to search for the item.</param>
            <param name="item">Item to locate in the array.</param>
            <returns>
            Index of first occurrence of the <paramref name="item"/>
            in the <paramref name="items"/> array, if found;
            otherwise, <see langword="-1"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Segment``1(``0[],System.Int32,System.Int32)">
            <summary>
            Enumerates segment of an array.
            </summary>
            <typeparam name="TItem">The type of the array item.</typeparam>
            <param name="items">The array to enumerate the segment of.</param>
            <param name="offset">Segment offset.</param>
            <param name="length">Segment length.</param>
            <returns>An enumerable iterating through the segment.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.IndexOf``1(``0[],``0,System.Boolean)">
            <summary>
            Gets the index of first occurrence of the <paramref name="item"/>
            in the <paramref name="items"/> array, if found;
            otherwise returns <see langword="-1"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="items">Array to search for the item.</param>
            <param name="item">Item to locate in the array.</param>
            <param name="byReference">Indicates whether just references
            should be compared.</param>
            <returns>
            Index of first occurrence of the <paramref name="item"/>
            in the <paramref name="items"/> array, if found;
            otherwise, <see langword="-1"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">Value type is passed instead of class.</exception>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Select``1(``0[],System.Func{``0,``0,System.Int32},System.Int32)">
            <summary>
            Selects the specified item from the ordered sequence of items
            produced by ordering the <paramref name="items"/>.
            The original sequence will be partially reordered!
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="items">The items to select from.</param>
            <param name="index">The offset of the item to select from the ordered sequence.</param>
            <returns>The specified item from the ordered sequence of items.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Prepend``1(``0[],``0)">
            <summary>
            Creates new array consisting of <paramref name="items"/>
            and <paramref name="item"/> added before array elements.
            If <paramref name="items"/> is <see langword="null"/>
            returns array that contains just <paramref name="item"/>.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="items">The items.</param>
            <param name="item">The prefix item.</param>
            <returns>Result array.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Append``1(``0[],``0)">
            <summary>
            Creates new array consisting of <paramref name="items"/>
            and <paramref name="item"/> added after array elements.
            If <paramref name="items"/> is <see langword="null"/>
            returns array that contains just <paramref name="item"/>.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="items">The items.</param>
            <param name="item">The prefix item.</param>
            <returns>Result array.</returns>
        </member>
        <member name="M:Xtensive.Core.ArrayExtensions.Combine``1(``0[],``0[])">
            <summary>
            Combines the specified source and target arrays into new one.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="source">The source.</param>
            <param name="target">The target.</param>
            <returns></returns>
        </member>
        <member name="T:Xtensive.Core.Collections.IntDictionary`1">
            <summary>
            The fast dictionary-like collection using keys of type <see cref="T:System.Int32"/>.
            </summary>
            <typeparam name="TValue">The type of a value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Tries to get a value by the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns><see langword="true" /> if the key was found; 
            otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.Add(System.Int32,`0)">
            <summary>
            Adds the item to the collection.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.InvalidOperationException">Key already exists.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.Remove(System.Int32)">
            <summary>
            Removes the item with the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns><see langword="true" /> if an item was found and removed; 
            otherwise <see langword="false" />.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.Clear">
            <summary>
            Removes all items.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.InsertIntoBucket(System.Collections.Generic.KeyValuePair{System.Int32,`0}[],System.Collections.Generic.KeyValuePair{System.Int32,`0})">
            <exception cref="T:System.InvalidOperationException">Key already exists.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.RemoveFromBucket(System.Collections.Generic.KeyValuePair{System.Int32,`0}[]@,System.Int32)">
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Specified key not found.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.GetCapacity(System.Int32)">
            <exception cref="T:System.OverflowException">Capacity limit is reached.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.IntDictionary`1.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="capacity">The initial capacity.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.IntDictionary`1.Count">
            <summary>
            Gets the number of elements contained in a collection.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IntDictionary`1.Item(System.Int32)">
            <summary>
            Gets a value by the specified key.
            </summary>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Specified key not found.</exception>
        </member>
        <member name="T:Xtensive.Core.Collections.ITypeRegistrationProcessor">
            <summary>
            Processes <see cref="T:Xtensive.Core.Collections.TypeRegistration"/>s in <see cref="T:Xtensive.Core.Collections.TypeRegistry"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ITypeRegistrationProcessor.Process(Xtensive.Core.Collections.TypeRegistry,Xtensive.Core.Collections.TypeRegistration)">
            <summary>
            Processes the specified type registration.
            </summary>
            <param name="registry">The type registry.</param>
            <param name="registration">The action to process.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.SetUtils`1">
            <summary>
            <see cref="T:Xtensive.Core.Collections.ISet"/> related utilities.
            </summary>
            <typeparam name="TItem">Type of set item.</typeparam>
        </member>
        <member name="P:Xtensive.Core.Collections.SetUtils`1.EmptySet">
            <summary>
            Gets empty set of items of <typeparamref name="TItem"/> type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.Deque`1">
            <summary>
            Double-ended queue.
            </summary>
            <typeparam name="T">The type of queued elements.</typeparam>
            <remarks>
            <para>
            <see cref="T:Xtensive.Core.Collections.Deque`1"/> it is a sequence that supports random access to its elements, 
            constant time of insertion and removal of elements at the both ends of the sequence, 
            and linear time of insertion and removal of elements in the middle.
            </para>
            <para>
            The capacity of a <see cref="T:Xtensive.Core.Collections.Deque`1"/> is the number of elements the <see cref="T:Xtensive.Core.Collections.Deque`1"/> can hold.
            In this implementation, the default initial capacity for a <see cref="T:Xtensive.Core.Collections.Deque`1"/> is 16;
            however, that default might change in future versions.
            </para>
            <para>
            As elements are added to a <see cref="T:Xtensive.Core.Collections.Deque`1"/>, the capacity is automatically increased as required
            by reallocating the internal array. The capacity can be decreased by calling <see cref="M:Xtensive.Core.Collections.Deque`1.TrimExcess"/>.
            </para>
            <para>
            The growth factor is the number by which the current capacity is multiplied when a greater capacity
            is required. The growth factor is determined when the <see langword="Deque"/> is constructed.
            </para>
            <para>
            <see cref="T:Xtensive.Core.Collections.Deque`1"/> accepts a <see langword="null"/>
            as a valid value for reference types and allows duplicate elements.
            </para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Collections.IDeque`1">
            <summary>
            double-ended queue contract.
            </summary>
            <typeparam name="T">The type of queued elements.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IDeque`1.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>,
            if that number is less than 90 percent of current capacity.
            </summary>
            <remarks>
            This method can be used to minimize a collection's memory overhead 
            if no new elements will be added to the collection. 
            <para>
            The cost of reallocating and copying a large <see cref="T:Xtensive.Core.Collections.IDeque`1"/> can be considerable, however,
            so the <see cref="M:Xtensive.Core.Collections.IDeque`1.TrimExcess"/> method does nothing if the deque is at more than 90 percent of capacity.
            This avoids incurring a large reallocation cost for a relatively small gain.
            </para>
            <para>
            This method is an O(n) operation, where n is <see cref="P:Xtensive.Core.Collections.ICountable.Count"/>.
            </para>
            To reset a <see cref="T:Xtensive.Core.Collections.IDeque`1"/> to its initial state, call the <see cref="M:System.Collections.IList.Clear"/> method
            before calling <see cref="M:Xtensive.Core.Collections.IDeque`1.TrimExcess"/> method. 
            Trimming an empty <see cref="T:Xtensive.Core.Collections.IDeque`1"/> sets the capacity of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>
            to the default capacity.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IDeque`1.AddHead(`0)">
            <summary>
            Adds <paramref name="element"/> to the <see cref="T:Xtensive.Core.Collections.IDeque`1"/> head.
            </summary>
            <param name="element">
            The element to add to the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.
            The value can be a <see langword="null"/> for reference types.
            </param>
            <remarks>
            <para>
            If <see cref="P:Xtensive.Core.Collections.ICountable.Count"/> already equals the <see cref="P:Xtensive.Core.Collections.IDeque`1.Capacity"/>,
            the <see cref="P:Xtensive.Core.Collections.IDeque`1.Capacity"/> of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/> is increased by 
            automatically reallocating the internal array, and the existing elements 
            are copied to the new array before the new element is added.
            </para>
            <para>
            If <see cref="P:Xtensive.Core.Collections.ICountable.Count"/> is less than the <see cref="P:Xtensive.Core.Collections.IDeque`1.Capacity"/> of the internal array,
            this method is an O(1) operation. 
            If the internal array needs to be reallocated to accommodate the new element,
            this method becomes an O(n) operation, where n is <see cref="P:Xtensive.Core.Collections.ICountable.Count"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IDeque`1.AddTail(`0)">
            <summary>
            Adds <paramref name="element"/> to the <see cref="T:Xtensive.Core.Collections.IDeque`1"/> tail.
            </summary>
            <param name="element">
            The element to add to the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.
            The value can be a <see langword="null"/> for reference types.
            </param>
            <remarks>
            <para>
            If <see cref="P:Xtensive.Core.Collections.ICountable.Count"/> already equals the <see cref="P:Xtensive.Core.Collections.IDeque`1.Capacity"/>,
            the <see cref="P:Xtensive.Core.Collections.IDeque`1.Capacity"/> of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/> is increased by 
            automatically reallocating the internal array, and the existing elements 
            are copied to the new array before the new element is added.
            </para>
            <para>
            If <see cref="P:Xtensive.Core.Collections.ICountable.Count"/> is less than the <see cref="P:Xtensive.Core.Collections.IDeque`1.Capacity"/> of the internal array,
            this method is an O(1) operation. 
            If the internal array needs to be reallocated to accommodate the new element,
            this method becomes an O(n) operation, where n is <see cref="P:Xtensive.Core.Collections.ICountable.Count"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IDeque`1.ExtractHead">
            <summary>
            Removes and returns the element at the head of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.
            </summary>
            <returns>The element that is removed from the head of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:Xtensive.Core.Collections.IDeque`1"/> is empty.</exception>
            <remarks>
            This method is an O(1) operation.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IDeque`1.ExtractTail">
            <summary>
            Removes and returns the element at the tail of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.
            </summary>
            <returns>The element that is removed from the tail of the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.</returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="T:Xtensive.Core.Collections.IDeque`1"/> is empty.</exception>
            <remarks>
            This method is an O(1) operation.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IDeque`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Removes a range of items at the given index in the Deque. All items at indexes 
            greater than <paramref name="index"/> move down <paramref name="count"/> indices
            in the Deque.
            </summary>
            <param name="index">The index in the list to remove the range at. The
            first item in the list has index 0.</param>
            <param name="count">The number of items to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index"/> is
            less than zero or greater than or equal to Count, or <paramref name="count"/> is less than zero
            or too large.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.IDeque`1.Capacity">
            <summary>
            Gets or sets the size of an internal array.
            </summary>
            <value>
            Indicates the size of an internal array.
            The minimally allowed value which is also the default one is 16.
            </value>
            <remarks>
            As elements are added to a <see cref="T:Xtensive.Core.Collections.IDeque`1"/>, the capacity is automatically increased as required
            by reallocating the internal array. The capacity can be decreased by calling <see cref="M:Xtensive.Core.Collections.IDeque`1.TrimExcess"/>.
            </remarks>
        </member>
        <member name="P:Xtensive.Core.Collections.IDeque`1.Head">
            <summary>
            Gets head element in the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IDeque`1.Tail">
            <summary>
            Gets tail element in the <see cref="T:Xtensive.Core.Collections.IDeque`1"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.TrimExcess">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.AddHead(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.AddTail(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.ExtractHead">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.ExtractTail">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.RemoveRange(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.Clone">
            <summary>
            Creates a shallow copy of the <see cref="T:Xtensive.Core.Collections.Deque`1"/>.
            </summary>
            <returns>A shallow copy of the <see cref="T:Xtensive.Core.Collections.Deque`1"/>.</returns>
            <remarks>
            <para>
            A shallow copy of a collection copies only the elements of the collection,
            whether they are reference types or value types, but it does not copy 
            the objects that the references refer to. The references in the new collection 
            point to the same objects that the references in the original collection point to.
            </para>
            <para>
            In contrast, a deep copy of a collection copies the elements and 
            everything directly or indirectly referenced by the elements.
            </para>
            <para>
            This method is an O(n) operation, where n is <see langword="Count"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="initialCapacity">The initial <see cref="P:Xtensive.Core.Collections.Deque`1.Capacity"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.#ctor(System.Int32,System.Single)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="initialCapacity">The initial <see cref="P:Xtensive.Core.Collections.Deque`1.Capacity"/> property value.</param>
            <param name="growFactor">The factor by which the capacity of the <see cref="T:Xtensive.Core.Collections.Deque`1"/> is expanded.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The initial contents of the <see cref="T:Xtensive.Core.Collections.Deque`1"/>.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Single)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The initial contents of the <see cref="T:Xtensive.Core.Collections.Deque`1"/>.</param>
            <param name="growFactor">The factor by which the capacity of the <see cref="T:Xtensive.Core.Collections.Deque`1"/> is expanded.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Collections.Deque`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.Head">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.Tail">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.System#Collections#IList#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.System#Collections#ICollection#SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.System#Collections#ICollection#IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Deque`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.DictionaryExtensions">
            <summary>
            <see cref="T:System.Collections.Generic.Dictionary`2"/> related extensions.
            </summary>
        </member>
        <member name="M:Xtensive.Core.DictionaryExtensions.Union``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Unions the specified <see cref="T:System.Collections.Generic.IDictionary`2"/> with <paramref name="right"/> enumerable int new <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="left">The left dictionary.</param>
            <param name="right">The right enumerable.</param>
        </member>
        <member name="M:Xtensive.Core.DictionaryExtensions.EqualsTo``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Determines whether this <see cref="T:System.Collections.Generic.Dictionary`2"/> equals to another, i.e. contains the same keys and corresponding values.
            </summary>
            <typeparam name="TKey">The type of keys in dictionary.</typeparam>
            <typeparam name="TValue">The type of values in dictionary.</typeparam>
            <param name="dictionary">This dictionary.</param>
            <param name="other">The dictionary to compare with.</param>
            <returns>
              <see langword="true"/> if this dictionary equals to the specified dictionary; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Collections.EmptyCountable`1">
            <summary>
            Empty <see cref="T:Xtensive.Core.Collections.ICountable`1"/> implementation.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.EmptyCountable`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.EmptyCountable`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.EmptyCountable`1.Count">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.EnumerableExtensions">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Indicates whether enumerable is empty or not 
            by attempting to cast it to <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:Xtensive.Core.Collections.ICountable`1"/> and <see cref="T:System.Linq.IQueryable`1"/>.
            May return false negative response.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="items">Items to check.</param>
            <returns><see langword="True"/> if collection is definitely <see langword="null"/> or empty;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.TryGetLongCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the count of items (as <see cref="T:System.Int64"/>) of <see cref="T:System.Collections.Generic.IEnumerable`1"/>, if it is actually
            <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:Xtensive.Core.Collections.ICountable`1"/> or <see cref="T:System.Linq.IQueryable`1"/>.
            Otherwise returns <see langword="null"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="items">Items to get count of.</param>
            <returns>The count of items, if it's possible to get it;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.TryGetCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Gets the count of items of <see cref="T:System.Collections.Generic.IEnumerable`1"/>, if it is actually
            <see cref="T:System.Collections.Generic.ICollection`1"/>, <see cref="T:Xtensive.Core.Collections.ICountable`1"/> or <see cref="T:System.Linq.IQueryable`1"/>.
            Otherwise returns <see langword="null"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="items">Items to get count of.</param>
            <returns>The count of items, if it's possible to get it;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.Run``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            "Runs" the specified <paramref name="sequence"/> by enumerating it.
            </summary>
            <typeparam name="T">Type of the sequence item.</typeparam>
            <param name="sequence">The sequence to run.</param>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Applies the specified <paramref name="action"/> to all the items 
            from the <paramref name="items"/> sequence.
            </summary>
            <typeparam name="T">Type of the sequence item.</typeparam>
            <param name="items">The sequence to apply the <paramref name="action"/> to.</param>
            <param name="action">The action to apply.</param>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Applies the specified <paramref name="action"/> to all the items 
            from the <paramref name="items"/> sequence.
            </summary>
            <typeparam name="T">Type of the sequence item.</typeparam>
            <param name="items">The sequence to apply the <paramref name="action"/> to.</param>
            <param name="action">The action to apply.</param>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the sequence to the <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
            <typeparam name="T">The type of sequence item.</typeparam>
            <param name="source">The sequence to convert.</param>
            <returns>A new <see cref="T:System.Collections.Generic.HashSet`1"/> instance containing 
            all the unique items from the <paramref name="source"/> sequence.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Converts the sequence to the <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
            <typeparam name="T">The type of sequence item.</typeparam>
            <param name="source">The sequence to convert.</param>
            <param name="ensureNoDuplicates">If set to <see langword="true"/>, an exception 
            will be thrown if there are duplicates;
            otherwise result will contain only unique items.</param>
            <returns>A new <see cref="T:System.Collections.Generic.HashSet`1"/> instance containing 
            all the unique items from the <paramref name="source"/> sequence.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.Convert``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <summary>
            Converts the elements of <paramref name="source"/> sequence 
            using specified <paramref name="converter"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <typeparam name="TNewItem">The type of item to convert to.</typeparam>
            <param name="source">The sequence to convert.</param>
            <param name="converter">A delegate that converts each element.</param>
            <returns>A sequence of converted elements.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.CalculateHashCode``1(System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Calculates hash code of <see cref="T:System.Collections.Generic.IEnumerable`1"/> by XOR hash codes of it's items.
             </summary>
            <param name="items">Enumerable to calculate hash for.</param>
             <typeparam name="TItem">The type of item.</typeparam>
            <returns>Hash code, calculated by enumerable items. If enumerable is null or empty returns 0.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToCommaDelimitedString``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the <paramref name="source"/> to comma-delimited string.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">The sequence to convert.</param>
            <returns>Comma-delimited string containing string representation 
            of all the items from <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToCommaDelimitedString(System.Collections.IEnumerable)">
            <summary>
            Converts the <paramref name="source"/> to comma-delimited string.
            </summary>
            <param name="source">The sequence to convert.</param>
            <returns>Comma delimited string combining string representations
            of all the items from <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToDelimitedString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Converts the <paramref name="source"/> to a delimited string.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">The sequence to convert.</param>
            <param name="delimiter">The delimiter.</param>
            <returns>A delimited string combining string representations
            of all the items from <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToDelimitedString(System.Collections.IEnumerable,System.String)">
            <summary>
            Converts the <paramref name="source"/> to delimited string.
            </summary>
            <param name="source">The sequence to convert.</param>
            <param name="separator">The delimiter.</param>
            <returns>Delimited string containing string representation 
            of all the items from <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.EqualsTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether this <see cref="T:System.Collections.Generic.IEnumerable`1"/> equals to another, 
            i.e. contains the same items in the same order.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="items">This <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <param name="other">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to compare with.</param>
            <returns>
            <see langword="true"/> if this <see cref="T:System.Collections.Generic.IEnumerable`1"/> equals to the specified <see cref="T:System.Collections.Generic.IEnumerable`1"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Constructs <see cref="T:System.Collections.Generic.IEnumerable`1"/> from
            this <see cref="T:System.Collections.Generic.IEnumerable`1"/> and specified <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            by creating a <see cref="T:Xtensive.Core.Pair`2"/> from each pair of items.
            If one input <see cref="T:System.Collections.Generic.IEnumerable`1"/> is short,
            excess elements of the longer <see cref="T:System.Collections.Generic.IEnumerable`1"/> are discarded.
            </summary>
            <typeparam name="TLeft">Type of first <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TRight">Type of second <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="leftSequence">First <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <param name="rightSequence">Second <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <returns>Zip result.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ZipExtend``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Constructs <see cref="T:System.Collections.Generic.IEnumerable`1"/> from
            this <see cref="T:System.Collections.Generic.IEnumerable`1"/> and specified <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            by applying <paramref name="projector"/> for each pair of items.
            If one input <see cref="T:System.Collections.Generic.IEnumerable`1"/> is short, it is extended with default values.
            </summary>
            <typeparam name="TLeft">Type of first <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TRight">Type of second <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TResult">Type of result.</typeparam>
            <param name="leftSequence">First <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <param name="rightSequence">Second <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <param name="projector">A delegate constructing <typeparamref name="TResult"/> from 
            <typeparamref name="TLeft"/> and <typeparamref name="TRight"/> values.</param>
            <returns>Result of applying <paramref name="projector"/> for each pair of items.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ZipExtend``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Constructs <see cref="T:System.Collections.Generic.IEnumerable`1"/> from
            this <see cref="T:System.Collections.Generic.IEnumerable`1"/> and specified <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            by creating a <see cref="T:Xtensive.Core.Pair`2"/> from each pair of items.
            If one input <see cref="T:System.Collections.Generic.IEnumerable`1"/> is short, it is extended with default values.
            </summary>
            <typeparam name="TLeft">Type of first <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TRight">Type of second <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <param name="leftSequence">First <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <param name="rightSequence">Second <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</param>
            <returns>Zip result.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ToArraySafely``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            If <paramref name="sequence"/> is not <see langword="null"/>, creates an array from <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Otherwise, returns empty array.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="sequence">The sequence.</param>
            <returns>Array of elements of <paramref name="sequence"/>
            or empty array, if <paramref name="sequence"/> is <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.GetItems(Xtensive.Core.Segment{System.Int32})">
            <summary>
            Gets the items from the segment.
            </summary>
            <param name="segment">The segment.</param>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.GetItems(Xtensive.Core.Segment{System.Int64})">
            <summary>
            Gets the items from the segment.
            </summary>
            <param name="segment">The segment.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.GetItems(Xtensive.Core.Segment{System.Int16})">
            <summary>
            Gets the items from the segment.
            </summary>
            <param name="segment">The segment.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.AddOne``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Safely adds one value to sequence.
            </summary>
            <typeparam name="T">The type of enumerated items.</typeparam>
            <param name="source">Source sequence.</param>
            <param name="value">Value to add to sequence.</param>
            <returns>New sequence with both <paramref name="source"/> and <paramref name="value"/> items inside without duplicates.</returns>
            <remarks>If source sequence is null, it's equals to empty sequence. If value is null, it will not added to result sequence.</remarks>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Splits the specified <see cref="T:System.Collections.Generic.IEnumerable`1"/> into batches.
            </summary>
            <typeparam name="T">The type of enumerated items.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="firstFastCount">The count of the source sequence's items 
            which will be returned without batching.</param>
            <param name="initialBatchSize">The initial size of a batch.</param>
            <param name="maximalBatchSize">The maximal sized of a batch.</param>
            <returns>The source sequence split into batches.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Splits the specified <see cref="T:System.Collections.Generic.IEnumerable`1"/> into batches.
            </summary>
            <typeparam name="T">The type of enumerated items.</typeparam>
            <param name="source">The source sequence.</param>
            <returns>The source sequence split into batches.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Splits the specified <see cref="T:System.Collections.Generic.IEnumerable`1"/> into batches.
            </summary>
            <typeparam name="T">The type of enumerated items.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="firstFastCount">The count of the source sequence's items 
            which will be returned without batching.</param>
            <returns>The source sequence split into batches.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ApplyBefore``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Action)">
            <summary>
            Invokes the specified delegate before the enumeration of each batch.
            </summary>
            <typeparam name="T">The type of enumerated items.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="action">The delegate that will be invoked before 
            the enumeration of each batch.</param>
            <returns>The source sequence.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.ApplyAfter``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Action)">
            <summary>
            Invokes the specified delegate after the enumeration of each batch.
            </summary>
            <typeparam name="T">The type of enumerated items.</typeparam>
            <param name="source">The source sequence.</param>
            <param name="action">The delegate that will be invoked after 
            the enumeration of each batch.</param>
            <returns>The source sequence.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.EnumerableExtensions.ApplyBeforeAndAfter``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Action,System.Action)" -->
        <member name="M:Xtensive.Core.EnumerableExtensions.Flatten``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Action{``0},System.Boolean)">
            <summary>
            Flattens the item's hierarchy.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="root">The root of the hierarchy.</param>
            <param name="childrenExtractor">The children extractor. It's always executed 
            before a root item will be returned.</param>
            <param name="exitAction">This action is always executed after a root item 
            was returned.</param>
            <param name="rootFirst">If set to <see langword="true"/> then a root item 
            will be returned before its children.</param>
            <returns>The <see cref="T:System.Collections.Generic.IEnumerable`1"/> containing all items in the 
            specified hierarchy.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.AtLeast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whenever specified sequence contains at least <see cref="!:numberOfElements"/>.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="sequence">The sequence.</param>
            <param name="numberOfElements">The number of elements.</param>
            <returns><see langword="true"/> if <paramref name="sequence"/> contains at least <paramref name="numberOfElements"/>;
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Xtensive.Core.EnumerableExtensions.AtMost``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Determines whenever specified sequence contains at most <see cref="!:numberOfElements"/>.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="sequence">The sequence.</param>
            <param name="numberOfElements">The number of elements.</param>
            <returns><see langword="true"/> if <paramref name="sequence"/> contains at most <paramref name="numberOfElements"/>;
            <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.EnumerableUtils">
            <summary>
            <see cref="T:System.Collections.IEnumerable"/> related utilities.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.EnumerableUtils.One``1(``0)">
            <summary>
            Gets the enumerable with one element.
            </summary>
            <typeparam name="TItem">The type of enumerated item.</typeparam>
            <returns>Sequence with value inside.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.EnumerableUtils.Unfold``1(``0,System.Func{``0,``0})">
            <summary>
            Unfolds the whole sequence from its <paramref name="first"/> item.
            If <paramref name="first"/> is <see langword="null" />,
            an empty sequence is returned.
            </summary>
            <typeparam name="TItem">The type of enumerated item.</typeparam>
            <param name="first">The first item.</param>
            <param name="next">The delegate returning the next item by the current one.
            The enumeration continues until it returns <see langword="null" />.</param>
            <returns>Unfolded sequence of items 
            starting from the <paramref name="first"/> one.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.EnumerableUtils.Unfold``1(``0,System.Func{``0,System.Boolean},System.Func{``0,``0})">
            <summary>
            Unfolds the whole sequence from its <paramref name="first"/> item.
            </summary>
            <typeparam name="TItem">The type of enumerated item.</typeparam>
            <param name="first">The first item.</param>
            <param name="include">The delegate indicating whether to include the current item
            into the sequence or not. Enumeration continues until this method returns
            <see langword="false" />.</param>
            <param name="next">The delegate returning the next item by the current one.</param>
            <returns>
            Unfolded sequence of items
            starting from the <paramref name="first"/> one.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Collections.EnumerableUtils`1">
            <summary>
            <see cref="T:System.Collections.IEnumerable"/> related utilities.
            </summary>
            <typeparam name="TItem">The type of enumerated item.</typeparam>
        </member>
        <member name="P:Xtensive.Core.Collections.EnumerableUtils`1.Empty">
            <summary>
            Gets the empty sequence.
            </summary>
            <returns>Empty sequence.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.EnumerableUtils`1.EmptyEnumerator">
            <summary>
            Gets the enumerator of empty sequence.
            </summary>
            <returns>The enumerator of empty sequence.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.ExtensionCollection">
            <summary>
            Default <see cref="T:Xtensive.Core.Collections.IExtensionCollection"/> implementation (<see cref="T:Xtensive.Core.ILockable">lockable</see>).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.IExtensionCollection">
            <summary>
            A collection of type-based extensions.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.IExtensionCollection.Get``1">
            <summary>
            Gets the extension of type <typeparamref name="T"/> from the collection.
            </summary>
            <typeparam name="T">The type of extension to get.</typeparam>
            <returns>The extension of type <typeparamref name="T"/>, if exists;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IExtensionCollection.Get(System.Type)">
            <summary>
            Gets the extension of type <paramref name="extensionType"/> from the collection.
            </summary>
            <param name="extensionType">The type of extension to get.</param>
            <returns>The extension of type <paramref name="extensionType"/>, if exists;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IExtensionCollection.Set``1(``0)">
            <summary>
            Adds \ replaces the extension of type <typeparamref name="T"/> in the collection.
            </summary>
            <typeparam name="T">The type of extension to add \ replace.</typeparam>
            <param name="value">The extension to add \ replace.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IExtensionCollection.Set(System.Type,System.Object)">
            <summary>
            Adds \ replaces the extension of type <paramref name="extensionType"/> in the collection.
            </summary>
            <param name="extensionType">The type of extension to add \ replace.</param>
            <param name="value">The extension to add \ replace.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IExtensionCollection.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Get``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Get(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Set``1(``0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Set(System.Type,System.Object)">
            <inheritdoc/>
            <exception cref="T:System.ArgumentException">Wrong arguments.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ExtensionCollection.#ctor(Xtensive.Core.Collections.IExtensionCollection)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The source to copy into this collection.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ExtensionCollection.Count">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.FlagRegistry`2">
            <summary>
            Flag registry. An item could be registered multiple times with the different flags. 
            Flags usually is an <see cref="T:System.Enum"/> descendant.
            </summary>
            <typeparam name="TFlag">The type of the flag.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagRegistry`2.Register(`1)">
            <summary>
            Registers the specified item in this instance.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagRegistry`2.GetFlags">
            <summary>
            Gets the flags.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagRegistry`2.GetItems(`0)">
            <summary>
            Gets the items by specified flag.
            </summary>
            <param name="flag">The flag.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagRegistry`2.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagRegistry`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagRegistry`2.#ctor(System.Func{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="flagExtractor">The flag extractor.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagRegistry`2.Count">
            <summary>
            Gets the total count of items registered in this instance.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ListExtensions">
            <summary>
            <see cref="T:System.Collections.Generic.ICollection`1"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ListExtensions.Copy``1(System.Collections.Generic.IList{``0},``0[],System.Int32)">
            <summary>
            Copies the items from <paramref name="source"/> collection
            to <paramref name="target"/> array starting from specified
            <paramref name="targetIndex"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">Source collection to copy from.</param>
            <param name="target">Target array to copy to.</param>
            <param name="targetIndex">Index in <paramref name="target"/> array to start from.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>targetIndex</c> is out of range.</exception>
            <exception cref="T:System.ArgumentException">Destination array is too small.</exception>
        </member>
        <member name="M:Xtensive.Core.ListExtensions.Copy``1(System.Collections.Generic.IList{``0},System.Array,System.Int32)">
            <summary>
            Copies the items from <paramref name="source"/> collection
            to <paramref name="target"/> array starting from specified
            <paramref name="targetIndex"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">Source collection to copy from.</param>
            <param name="target">Target array to copy to.</param>
            <param name="targetIndex">Index in <paramref name="target"/> array to start from.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>targetIndex</c> is out of range.</exception>
            <exception cref="T:System.ArgumentException">Destination array is too small or multidimensional.</exception>
        </member>
        <member name="M:Xtensive.Core.ListExtensions.Reverse``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns an enumerable enumerating specified <paramref name="list"/> in backward direction.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="list">The list to enumerate in backward direction.</param>
            <returns>Enumerable enumerating specified <paramref name="list"/> in backward direction.</returns>
        </member>
        <member name="M:Xtensive.Core.ListExtensions.Segment``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Enumerates segment of a list.
            </summary>
            <typeparam name="TItem">The type of the list item.</typeparam>
            <param name="items">The list to enumerate the segment of.</param>
            <param name="offset">Segment offset.</param>
            <param name="length">Segment length.</param>
            <returns>An enumerable iterating through the segment.</returns>
        </member>
        <member name="M:Xtensive.Core.ListExtensions.EnsureIndexIsValid``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Ensures <paramref name="index"/> is in range of <paramref name="list"/> indexes.
            </summary>
            <param name="list">List to use the index range of.</param>
            <param name="index">Index value to check.</param>
            <exception cref="T:System.IndexOutOfRangeException">Specified index is not valid for the specified list.</exception>
        </member>
        <member name="M:Xtensive.Core.ListExtensions.EnsureIndexIsValid(System.Collections.IList,System.Int32)">
            <summary>
            Ensures <paramref name="index"/> is in range of <paramref name="list"/> indexes.
            </summary>
            <param name="list">List to use the index range of.</param>
            <param name="index">Index value to check.</param>
            <exception cref="T:System.IndexOutOfRangeException">Specified index is not valid for the specified list.</exception>
        </member>
        <member name="T:Xtensive.Core.Collections.ItemRemovedEventArgs`1">
            <summary>
            Event arguments for <see cref="E:Xtensive.Core.Collections.IExpiringItemCollection`1.ItemRemoved"/> and <see cref="E:Xtensive.Core.Collections.IPoolBase`1.ItemRemoved"/> event.
            </summary>
            <typeparam name="TItem">The type of collection item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.ItemRemovedEventArgs`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The removing item.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ItemRemovedEventArgs`1.Item">
            <summary>
             Gets the expiring item.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Collections.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.OrderBy">
            <summary>
            A helper static type to use in conjunction with <see cref="T:Xtensive.Core.Collections.OrderBy`1"/>.
            Provides more descriptive ways to construct <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> instance - 
            i.e. <see cref="M:Xtensive.Core.Collections.OrderBy.Asc``1(``0[])"/> and <see cref="M:Xtensive.Core.Collections.OrderBy.Desc``1(``0[])"/> methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.OrderBy.Asc``1(``0[])">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> containing "item0, item1, ..." list.
            </summary>
            <param name="items">Items to include into the list.</param>
            <returns>New <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> containing "item0, item1, ..." list.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.OrderBy.Desc``1(``0[])">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> containing "item0 desc, item1 desc, ... desc" list.
            </summary>
            <param name="items">Items to include into the list.</param>
            <returns>New <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> containing "item0 desc, item1 desc, ... desc" list.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.OrderBy`1">
            <summary>
            "Order by" clause descriptor - a helper type allowing to describe "order by" clauses with ease.
            You must use <see cref="T:Xtensive.Core.Collections.OrderBy"/> type to create the instances of this struct.
            </summary>
            <typeparam name="T">The type of order by clause item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.OrderBy`1.Asc(`0[])">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> with joined ", item0, item1, ..." tail.
            </summary>
            <param name="items">Items to join to the tail.</param>
            <returns>New <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> with joined ", item0, item1, ..." tail.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.OrderBy`1.Desc(`0[])">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> with joined ", item0 desc, item1 desc, ... desc" tail.
            </summary>
            <param name="items">Items to join to the tail.</param>
            <returns>New <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> with joined ", item0 desc, item1 desc, ... desc" tail.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.OrderBy`1.op_Implicit(Xtensive.Core.Collections.OrderBy{`0})~Xtensive.Core.Collections.DirectionCollection{`0}">
            <summary>
            Implicitly converts <see cref="T:Xtensive.Core.Collections.OrderBy`1"/> to <see cref="T:Xtensive.Core.Collections.DirectionCollection`1"/>.
            </summary>
            <param name="source">The "order by" clause descriptor to convert.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.ReadOnlySet`1">
            <summary>
            Read-only set (<see cref="T:Xtensive.Core.Collections.ISet`1"/>) wrapper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.Add(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.Remove(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.RemoveWhere(System.Predicate{`0})">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.Clear">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.#ctor(Xtensive.Core.Collections.ISet{`0},System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="set">The set to copy or wrap.</param>
            <param name="copy">Indicates whether <paramref name="set"/> must be copied or wrapped.</param> 
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlySet`1.#ctor(Xtensive.Core.Collections.ISet{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="set">The set to wrap.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlySet`1.Item(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlySet`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlySet`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlySet`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlySet`1.Comparer">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.TypeRegistration">
            <summary>
            Describes a single type registration call to <see cref="T:Xtensive.Core.Collections.TypeRegistry"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.Equals(Xtensive.Core.Collections.TypeRegistration)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.op_Equality(Xtensive.Core.Collections.TypeRegistration,Xtensive.Core.Collections.TypeRegistration)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.op_Inequality(Xtensive.Core.Collections.TypeRegistration,Xtensive.Core.Collections.TypeRegistration)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.#ctor(System.Type)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type to register.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.#ctor(System.Reflection.Assembly)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="assembly">The assembly to register.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistration.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="assembly">The assembly to register.</param>
            <param name="namespace">The namespace to register.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistration.Type">
            <summary>
            Gets the type registered by this action.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistration.Assembly">
            <summary>
            Gets the assembly registered by this action.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistration.Namespace">
            <summary>
            Gets the namespace registered by this action.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.TypeRegistrationProcessorBase">
            <summary>
            Abstract base class for <see cref="T:Xtensive.Core.Collections.ITypeRegistrationProcessor"/> implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistrationProcessorBase.Process(Xtensive.Core.Collections.TypeRegistry,Xtensive.Core.Collections.TypeRegistration)">
            <summary>
            Processes the specified registration in the specified registration context.
            </summary>
            <param name="registry">The type registry.</param>
            <param name="registration">The action.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistrationProcessorBase.Process(Xtensive.Core.Collections.TypeRegistry,Xtensive.Core.Collections.TypeRegistration,System.Type)">
            <summary>
            Processes the single type registration.
            </summary>
            <param name="registry">The type registry.</param>
            <param name="registration">The registration.</param>
            <param name="type">The type.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistrationProcessorBase.IsAcceptable(Xtensive.Core.Collections.TypeRegistry,Xtensive.Core.Collections.TypeRegistration,System.Type)">
            <summary>
            Determines whether the specified type is acceptable for registration.
            </summary>
            <param name="registry">The type registry.</param>
            <param name="registration">The currently processed registration.</param>
            <param name="type">The type to check.</param>
            <returns>
              <see langword="true"/> if the specified type is acceptable for registration;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistrationProcessorBase.BaseType">
            <summary>
            Gets base type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.TypeRegistry">
            <summary>
            <see cref="T:System.Type"/> registration endpoint.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Contains(System.Type)">
            <summary>
            Determines whether the specified <see cref="T:System.Type"/> is contained in this instance.
            </summary>
            <param name="type"><see cref="T:System.Type"/> to search for.</param>
            <returns><see langword="True"/> if the <see cref="T:System.Type"/> is found; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Register(System.Type)">
            <summary>
            Registers the specified type.
            </summary>
            <param name="type">The type to register.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Register(System.Reflection.Assembly)">
            <summary>
            Invoke this method to register types from the specified <see cref="T:System.Reflection.Assembly"/>.
            Search is restricted by assembly only.
            </summary>
            <param name="assembly">Assembly to search for types.</param>
            <exception cref="T:System.InvalidOperationException">When <see cref="M:System.Reflection.Assembly.GetTypes"/> 
            method call has thrown an exception or if no suitable types were found.</exception>
            <exception cref="T:System.ArgumentNullException">When <paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Register(System.Reflection.Assembly,System.String)">
            <summary>
            Invoke this method to register types from the specified <see cref="T:System.Reflection.Assembly"/>.
            Search is restricted by assembly and namespace.
            </summary>
            <param name="assembly">Assembly to search for types.</param>
            <param name="namespace">Namespace to search for types.</param>
            <exception cref="T:System.InvalidOperationException">When <see cref="M:System.Reflection.Assembly.GetTypes"/> 
            method call has thrown an exception or if no suitable types were found.</exception>
            <exception cref="T:System.ArgumentNullException">When <paramref name="assembly"/> is null 
            or <paramref name="namespace"/> is empty string.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Register(Xtensive.Core.Collections.TypeRegistration)">
            <summary>
            Registers the specified <see cref="T:Xtensive.Core.Collections.TypeRegistration"/> for delayed processing.
            </summary>
            <param name="action">The type registration to register.</param>
            <returns><see langword="true"/> if specified registration was successfully added;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.Clone">
            <summary>
            Clones this instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.#ctor(Xtensive.Core.Collections.ITypeRegistrationProcessor)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="processor">The registry action processor.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypeRegistry.#ctor(Xtensive.Core.Collections.TypeRegistry)">
            <summary>
            This constructor is used to clone the instance.
            </summary>
            <param name="source">The type registry to clone the state of.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistry.Assemblies">
            <summary>
            Gets assemblies containing registered types.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistry.Count">
            <summary>
            Gets the number of types registered in this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.TypeRegistry.Xtensive#Core#Collections#ICountable#Count">
            <summary>
            Gets the number of types registered in this instance.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.CastingComparer`2">
            <summary>
            Casting comparer - wraps some other comparer for type <typeparamref name="TTarget"/>
            </summary>
            <typeparam name="TSource">The type to compare.</typeparam>
            <typeparam name="TTarget">The base type of <typeparamref name="TSource"/> to provide a comparer for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Comparison.AdvancedComparerBase`1">
            <summary>
            Base class for <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> implementations.
            </summary>
            <typeparam name="T">The type to compare.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Comparison.IAdvancedComparer`1">
            <summary>
            Interface for any comparer supported by <see cref="T:Xtensive.Core.Comparison.ComparerProvider"/>.
            </summary>
            <typeparam name="T">The type of values this comparer can compare.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Comparison.IAdvancedComparerBase">
            <summary>
            Very base interface for any comparer supported by <see cref="T:Xtensive.Core.Comparison.IComparerProvider"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.IAdvancedComparerBase.Provider">
            <summary>
            Gets the provider this comparer is associated with.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.IAdvancedComparerBase.ComparisonRules">
            <summary>
            Gets comparison rules used by this comparer.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.IHasRangeInfo`1">
            <summary>
            "An object providing <see cref="P:Xtensive.Core.Comparison.IHasRangeInfo`1.ValueRangeInfo"/>" contract.
            </summary>
            <typeparam name="T">Type of the value range boundaries.</typeparam>
        </member>
        <member name="P:Xtensive.Core.Comparison.IHasRangeInfo`1.ValueRangeInfo">
            <summary>
            Gets the <see cref="P:Xtensive.Core.Comparison.IHasRangeInfo`1.ValueRangeInfo"/> object describing the range of type <typeparamref name="T"/>.
            </summary>
            <value>The <see cref="P:Xtensive.Core.Comparison.IHasRangeInfo`1.ValueRangeInfo"/> object.</value>
        </member>
        <member name="T:Xtensive.Core.Comparison.INearestValueProvider`1">
            <summary>
            Provides nearest values for the specified value of specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of values.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Comparison.INearestValueProvider`1.GetNearestValue(`0,Xtensive.Core.Direction)">
            <summary>
            Gets the nearest value in the specified direction.
            </summary>
            <param name="value">The initial value for which nearest value should be provided.</param>
            <param name="direction">The direction of the nearest value relative to <paramref name="value"/>.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.IAdvancedComparer`1.ApplyRules(Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            Creates a new instance of <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> 
            with specified comparison rules applied.
            </summary>
            <param name="rules">Rules to apply (relatively to <see cref="T:Xtensive.Core.Comparison.ComparisonRules"/> of this comparer).</param>
            <returns>New instance of <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.IAdvancedComparer`1.GetAsymmetric``1">
            <summary>
            Gets the instance of <see cref="T:Xtensive.Core.Comparison.IComparer`2"/> (asymmetric comparer)
            for <typeparamref name="T"/>-<typeparamref name="TSecond"/> pair, if supported.
            </summary>
            <typeparam name="TSecond">Type of the second argument to compare.</typeparam>
            <exception cref="T:System.InvalidOperationException">Complex comparer could not be 
            created for <typeparamref name="T"/>-<typeparamref name="TSecond"/> pair.</exception>
            <returns><see cref="T:Xtensive.Core.Comparison.IComparer`2"/> asymmetric comparer.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.IAdvancedComparer`1.Cast``1">
            <summary>
            Wraps this instance with the <see cref="T:Xtensive.Core.Comparison.CastingComparer`2"/>.
            </summary>
            <typeparam name="TTarget">The type to provide the comparer for (by wrapping this comparer).</typeparam>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerBase`1.ComparisonRules">
            <summary>
            Gets comparison rules used by this comparer.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerBase`1.DefaultDirectionMultiplier">
            <summary>
            Multiplier for default direction in <see cref="F:Xtensive.Core.Comparison.AdvancedComparerBase`1.ComparisonRules"/>
            (either <see langword="1"/> or <see langword="-1"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.ApplyRules(Xtensive.Core.Comparison.ComparisonRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.GetAsymmetric``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.GetNearestValue(`0,Xtensive.Core.Direction)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.GetArithmetic">
            <summary>
            Gets default <see cref="T:Xtensive.Core.Arithmetic.IArithmetic`1"/> for type <typeparamref name="T"/>.
            </summary>
            <returns>Default arithmetic.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.Cast``1">
            <summary>
            Wraps this instance with the <see cref="T:Xtensive.Core.Comparison.CastingComparer`2"/>.
            </summary>
            <typeparam name="TTarget">The type to provide the comparer for (by wrapping this comparer).</typeparam>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.CreateNew(Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            Creates new comparer of the same type, but using different comparison rules.
            </summary>
            <param name="rules">Comparison rules for the new comparer (relatively to this one).</param>
            <returns>New comparer of the same type, but using different comparison rules.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.#ctor(Xtensive.Core.Comparison.IComparerProvider,Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Comparer provider this comparer is bound to.</param>
            <param name="comparisonRules">Comparison rules.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerBase`1.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Comparison.AdvancedComparerBase`1.Provider">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Comparison.AdvancedComparerBase`1.Xtensive#Core#Comparison#IAdvancedComparerBase#ComparisonRules">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Comparison.AdvancedComparerBase`1.ValueRangeInfo">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.CreateNew(Xtensive.Core.Comparison.ComparisonRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.Compare(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.Equals(`1,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.GetHashCode(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.GetNearestValue(`1,Xtensive.Core.Direction)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.GetAsymmetric``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.CastingComparer`2.#ctor(Xtensive.Core.Comparison.AdvancedComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.IComparer`2">
            <summary>
            Coompares type <typeparamref name="TX"/> with <typeparamref name="TY"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.IComparer`2.Compare(`0,`1)">
            <summary>
            Compares <paramref name="x"/> and <paramref name="y"/>.
            </summary>
            <param name="x">First value to compare.</param>
            <param name="y">Second value to compare.</param>
            <returns><see langword="-1"/> if <c>x &lt; y</c>, <see langword="1"/> if <c>x &gt; y</c>; 
            otherwise, <see langword="0"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.Comparison.ISystemComparer`1">
            <summary>
            Tagging interface specifying that comparer overrides
            <see cref="T:Xtensive.Core.Comparison.SystemComparer`1"/> for type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to override the system comparer for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Comparison.WrappingComparer`2">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/>s.
            </summary>
            <typeparam name="T">The type to compare.</typeparam>
            <typeparam name="TBase">Base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Comparison.WrappingComparer`2.BaseComparer">
            <summary>
            Comparer delegates for <typeparamref name="TBase"/> type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.WrappingComparer`2.#ctor(Xtensive.Core.Comparison.IComparerProvider,Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Comparer provider this comparer is bound to.</param>
            <param name="comparisonRules">Comparison rules.</param>
        </member>
        <member name="T:Xtensive.Core.Comparison.AdvancedComparerStruct`1">
            <summary>
            A struct providing faster access for key <see cref="T:Xtensive.Core.Comparison.AdvancedComparer`1"/> delegates.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.Default">
            <summary>
            Gets <see cref="T:Xtensive.Core.Comparison.AdvancedComparerStruct`1"/> for <see cref="P:Xtensive.Core.Comparison.AdvancedComparer`1.Default"/> comparer.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.System">
            <summary>
            Gets <see cref="T:Xtensive.Core.Comparison.AdvancedComparerStruct`1"/> for <see cref="P:Xtensive.Core.Comparison.AdvancedComparer`1.System"/> comparer.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.Comparer">
            <summary>
            Gets the underlying comparer for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.Compare">
            <summary>
            Gets <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.Equals">
            <summary>
            Gets <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.GetHashCode">
            <summary>
            Gets <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.GetNearestValue">
            <summary>
            Gets <see cref="M:Xtensive.Core.Comparison.INearestValueProvider`1.GetNearestValue(`0,Xtensive.Core.Direction)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparerStruct`1.ValueRangeInfo">
            <summary>
            Gets <see cref="P:Xtensive.Core.Comparison.IHasRangeInfo`1.ValueRangeInfo"/> value used by the underlying comparer.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerStruct`1.Cast``1">
            <summary>
            Wraps this instance with the <see cref="T:Xtensive.Core.Comparison.CastingComparer`2"/>.
            </summary>
            <typeparam name="TTarget">The type to provide the comparer for (by wrapping this comparer).</typeparam>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerStruct`1.op_Implicit(Xtensive.Core.Comparison.AdvancedComparer{`0})~Xtensive.Core.Comparison.AdvancedComparerStruct{`0}">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.Comparison.AdvancedComparer`1"/> to <see cref="T:Xtensive.Core.Comparison.AdvancedComparerStruct`1"/>.
            </summary>
            <param name="comparer">Comparer to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerStruct`1.#ctor(Xtensive.Core.Comparison.AdvancedComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="comparer">Comparer to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerStruct`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparerStruct`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.NoSystemComparerHandler`1.CompareTo(`0)">
            <exception cref="T:System.NotSupportedException"><c>NotSupportedException</c>.</exception>
        </member>
        <member name="M:Xtensive.Core.Comparison.NoSystemComparerHandler`1.Equals(`0)">
            <exception cref="T:System.NotSupportedException"><c>NotSupportedException</c>.</exception>
        </member>
        <member name="M:Xtensive.Core.Comparison.NoSystemComparerHandler`1.GetHashCode">
            <exception cref="T:System.NotSupportedException"><c>NotSupportedException</c>.</exception>
        </member>
        <member name="T:Xtensive.Core.Comparison.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.ReferenceEqualityComparer`1">
            <summary>
            Compares two objects by their reference values.
            </summary>
            <typeparam name="T">Type of the object to compare.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.Comparison.ReferenceEqualityComparer`1.Instance">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ReferenceEqualityComparer`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ReferenceEqualityComparer`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Comparison.SystemComparer`1">
            <summary>
            <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> wrapper for system comparers.
            </summary>
            <typeparam name="T">Type to compare.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Comparison.SystemComparer`1.Instance">
            <summary>
            Gets the only instance of this class.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.SystemComparer`1.CreateNew(Xtensive.Core.Comparison.ComparisonRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.SystemComparer`1.Compare(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.SystemComparer`1.Equals(`0,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.SystemComparer`1.GetHashCode(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Comparison.SystemComparerProvider">
            <summary>
            Provides <see cref="T:Xtensive.Core.Comparison.AdvancedComparer`1"/> wrappers for system comparers.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.ComparerProvider">
            <summary>
            Default <see cref="T:System.Collections.Generic.IComparer`1"/> provider. 
            Provides default comparer for the specified type.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Comparison.IComparerProvider">
            <summary>
            Provides <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> comparers.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.IComparerProvider.GetComparer``1">
            <summary>
            Gets comparer for the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to get the comparer for.</typeparam>
            <returns>Comparer for <typeparamref name="T"/> type.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparerProvider.GetComparer``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparerProvider.CreateAssociate``2(System.Type@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparerProvider.ConvertAssociate``3(``1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparerProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparerProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparerProvider.System">
            <summary>
            Gets system comparer provider.
            A shortcut to <see cref="P:Xtensive.Core.Comparison.SystemComparerProvider.Instance"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.SystemComparerProvider.CreateAssociate``2(System.Type@)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Comparison.SystemComparerProvider.Instance">
            <summary>
            Gets the only instance of this class.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.WellKnown">
            <summary>
            Various well-known constants related to this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.WellKnown.OrdinalMaxChar">
            <summary>
            Returns <see cref="F:System.Char.MaxValue"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.WellKnown.CultureSensitiveMaxChar">
            <summary>
            Returns "\uDBFF\uDFFF"
            </summary>
        </member>
        <member name="T:Xtensive.Core.Configuration.ConfigurationCollection`1">
            <summary>
            A typed version of <see cref="T:System.Configuration.ConfigurationElementCollection"/>.
            </summary>
            <typeparam name="T">The type of the collection item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationCollection`1.CreateNewElement">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationCollection`1.GetElementKey(System.Configuration.ConfigurationElement)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationCollection`1.Item(System.String)">
            <summary>
            Gets the element by specified identifier.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ConnectionInfo">
            <summary>
            A wrapper representing connection information.
            Connection can be specified by either <see cref="P:Xtensive.Core.ConnectionInfo.ConnectionString"/> or <see cref="P:Xtensive.Core.ConnectionInfo.ConnectionUrl"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.Equals(Xtensive.Core.ConnectionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.op_Equality(Xtensive.Core.ConnectionInfo,Xtensive.Core.ConnectionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.op_Inequality(Xtensive.Core.ConnectionInfo,Xtensive.Core.ConnectionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.#ctor(System.String,System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">A value for <see cref="P:Xtensive.Core.ConnectionInfo.Provider"/>.</param>
            <param name="connectionString">A value for <see cref="P:Xtensive.Core.ConnectionInfo.ConnectionString"/>.</param>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.#ctor(Xtensive.Core.UrlInfo)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="connectionUrl">A value for <see cref="P:Xtensive.Core.ConnectionInfo.ConnectionUrl"/>.</param>
        </member>
        <member name="M:Xtensive.Core.ConnectionInfo.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="connectionUrl">The connection URL.</param>
        </member>
        <member name="P:Xtensive.Core.ConnectionInfo.Provider">
            <summary>
            Gets the name of the provider.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ConnectionInfo.ConnectionString">
            <summary>
            Gets the connection string.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ConnectionInfo.ConnectionUrl">
            <summary>
            Gets the connection URL.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Conversion.IBiconverter`2">
            <summary>
            Provides bidirectional conversion support.
            </summary>
            <typeparam name="TFrom">The 1st type to convert.</typeparam>
            <typeparam name="TTo">The 2nd type to convert.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Conversion.IBiconverter`2.ConvertForward(`0)">
            <summary>
            Converts the value forward.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="M:Xtensive.Core.Conversion.IBiconverter`2.ConvertBackward(`1)">
            <summary>
            Converts the value backward.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="T:Xtensive.Core.Conversion.AdvancedConverterBase">
            <summary>
            Base class for any advanced converter.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Conversion.IAdvancedConverterBase">
            <summary>
            Tagging interface for any converter supported by
            <see cref="T:Xtensive.Core.Conversion.AdvancedConverterProvider"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Conversion.IAdvancedConverterBase.Provider">
            <summary>
            Gets the provider this converter is associated with.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterBase.#ctor(Xtensive.Core.Conversion.IAdvancedConverterProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">The provider this advanced converter is bound to.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterBase.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)"/>
        </member>
        <member name="P:Xtensive.Core.Conversion.AdvancedConverterBase.Provider">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Conversion.IAdvancedConverter`2">
            <summary>
            Converts values or instances of type <typeparamref name="TFrom"/> to 
            values or instances of type <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">The type of value to convert.</typeparam>
            <typeparam name="TTo">The type of converted value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Conversion.IAdvancedConverter`2.Convert(`0)">
            <summary>
             Converts specified value of <typeparamref name="TFrom"/> type
             to <typeparamref name="TTo"/> type.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>Converted value.</returns>
        </member>
        <member name="P:Xtensive.Core.Conversion.IAdvancedConverter`2.IsRough">
            <summary>
            Gets <see langword="true"/> if converter is rough, otherwise gets <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.StrictAdvancedConverterBase`1.Convert(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Conversion.StrictAdvancedConverterBase`1.IsRough">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Conversion.RoughAdvancedConverterBase.IsRough">
            <summary>
            Gets <see langword="true"/> if converter is rough, otherwise gets <see langword="false"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Conversion.IAdvancedConverterFactory`1">
            <summary>
            A factory class creating complex <see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/>.
            Usually implemented instead of converter for some complex type, e.g.
            <see cref="T:System.Nullable`1"/> to handle requests for its converters.
            </summary>
            <typeparam name="TFrom">The source type (the type to convert from).</typeparam>
        </member>
        <member name="M:Xtensive.Core.Conversion.IAdvancedConverterFactory`1.CreateForwardConverter``1">
            <summary>
            Creates forward-converting converter.
            </summary>
            <typeparam name="TTo">The destination type (the type to convert to).</typeparam>
            <returns>Forward-converting converter.</returns>
        </member>
        <member name="M:Xtensive.Core.Conversion.IAdvancedConverterFactory`1.CreateBackwardConverter``1">
            <summary>
            Creates backward-converting converter.
            </summary>
            <typeparam name="TTo">The destination type (the type to convert to).</typeparam>
            <returns>Backward-converting converter.</returns>
        </member>
        <member name="T:Xtensive.Core.Conversion.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Cached`1">
            <summary>
            A structure caching a single value of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of the value to cache.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Cached`1.GetValue(System.Func{`0})">
            <summary>
            Gets the cached value or generates it using specified <paramref name="generator"/> and caches.
            </summary>
            <param name="generator">The value generator.</param>
            <returns>Cached value.</returns>
        </member>
        <member name="M:Xtensive.Core.Cached`1.GetValue``1(System.Func{``0,`0},``0)">
            <summary>
            Gets the cached value or generates it using specified <paramref name="generator"/> and caches.
            </summary>
            <typeparam name="T1">The type of the <paramref name="argument"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="generator">The value generator.</param>
            <param name="argument">The argument to pass to the <paramref name="generator"/>.</param>
            <returns>Cached value.</returns>
        </member>
        <member name="M:Xtensive.Core.Cached`1.GetValue``2(System.Func{``0,``1,`0},``0,``1)">
            <summary>
            Gets the cached value or generates it using specified <paramref name="generator"/> and caches.
            </summary>
            <typeparam name="T1">The type of the <paramref name="argument1"/> to pass to the <paramref name="generator"/>.</typeparam>
            <typeparam name="T2">The type of the <paramref name="argument2"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="generator">The value generator.</param>
            <param name="argument1">The first argument to pass to the <paramref name="generator"/>.</param>
            <param name="argument2">The second argument to pass to the <paramref name="generator"/>.</param>
            <returns>Cached value.</returns>
        </member>
        <member name="M:Xtensive.Core.Cached`1.Equals(Xtensive.Core.Cached{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Cached`1.CompareTo(Xtensive.Core.Cached{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Cached`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Cached`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Cached`1.op_Equality(Xtensive.Core.Cached{`0},Xtensive.Core.Cached{`0})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Cached`1.op_Inequality(Xtensive.Core.Cached{`0},Xtensive.Core.Cached{`0})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Cached`1.EnsureHasValue">
            <exception cref="T:System.InvalidOperationException">No value is cached.</exception>
        </member>
        <member name="M:Xtensive.Core.Cached`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.Configuration.ConfigurationSection">
            <summary>
            A root element of diagnostics configuration section within a configuration file.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.Configuration.ConfigurationSection.DefaultSectionName">
            <summary>
            Gets default section name for diagnostics configuration.
            Value is "Xtensive.Core.Diagnostics".
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.ConfigurationSection.Logs">
            <summary>
            Gets the collection of domain configurations.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.Configuration.LogElement">
            <summary>
            Log configuration element.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.Name">
            <summary>
            Gets or sets the name of the log.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.Identifier">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.Provider">
            <summary>
            Gets or sets log provider name.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.Format">
            <summary>
            Gets or sets log format kind.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.Events">
            <summary>
            Gets or sets logged event types.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.FileName">
            <summary>
            Gets or sets the name of the log file, if underlying <see cref="P:Xtensive.Core.Diagnostics.Configuration.LogElement.Provider"/> requires this.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.Configuration.LogElement.FormatString">
            <summary>
            Gets or sets the format string to use.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.ConsoleLog">
            <summary>
            Console log implementation.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.TextualLogImplementationBase">
            <summary>
            Base class for logs producing textual output.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.RealLogImplementationBase">
            <summary>
            Base class for any <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/> implementation.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.IRealLog">
            <summary>
            Real log implementation.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.ILogBase">
            <summary>
            Common <see cref="T:Xtensive.Core.Diagnostics.ILog"/> and <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/> methods and properties.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILogBase.IsLogged(Xtensive.Core.Diagnostics.LogEventTypes)">
            <summary>
            Determines whether the specified event type is logged.
            </summary>
            <param name="eventType">Type of the event to check.</param>
            <returns><see langword="True"/> if the specified event type is logged; 
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILogBase.UpdateCachedProperties">
            <summary>
            Updates cached log properties.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.ILogBase.Name">
            <summary>
            Gets the name of the log.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.ILogBase.Text">
            <summary>
            Gets the logged text.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.ILogBase.LoggedEventTypes">
            <summary>
            Gets the event types this log logs.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.IRealLog.LogEvent(Xtensive.Core.Diagnostics.LogEventTypes,System.Object,System.Exception,Xtensive.Core.Diagnostics.IRealLog,Xtensive.Core.Diagnostics.LogCaptureScope)">
            <summary>
            Logs the event.
            </summary>
            <param name="eventType">The type of event to log.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
            <param name="sentTo">The original log, to which message was sent 
            (useful e.g. when <see cref="T:Xtensive.Core.Diagnostics.LogCaptureScope"/> is used to capture the events sent to another log).</param>
            <param name="capturedBy">The scope that captured the event, if any.</param>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.IRealLog.Log">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object wrapping this <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/>.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Diagnostics.IRealLog.OnLogEvent">
            <summary>
            Raised on any <see cref="M:Xtensive.Core.Diagnostics.IRealLog.LogEvent(Xtensive.Core.Diagnostics.LogEventTypes,System.Object,System.Exception,Xtensive.Core.Diagnostics.IRealLog,Xtensive.Core.Diagnostics.LogCaptureScope)"/> call.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.RealLogImplementationBase.IsLogged(Xtensive.Core.Diagnostics.LogEventTypes)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.RealLogImplementationBase.LogEvent(Xtensive.Core.Diagnostics.LogEventTypes,System.Object,System.Exception,Xtensive.Core.Diagnostics.IRealLog,Xtensive.Core.Diagnostics.LogCaptureScope)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.RealLogImplementationBase.UpdateCachedProperties">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.RealLogImplementationBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.RealLogImplementationBase.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RealLogImplementationBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RealLogImplementationBase.Text">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RealLogImplementationBase.Log">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RealLogImplementationBase.LoggedEventTypes">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Diagnostics.RealLogImplementationBase.OnLogEvent">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.TextualLogImplementationBase.LogEvent(Xtensive.Core.Diagnostics.LogEventTypes,System.Object,System.Exception,Xtensive.Core.Diagnostics.IRealLog,Xtensive.Core.Diagnostics.LogCaptureScope)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.TextualLogImplementationBase.LogEventText(System.String)">
            <summary>
            Logs the formatted event text.
            </summary>
            <param name="text">The text to log.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.TextualLogImplementationBase.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.TextualLogImplementationBase.LoggedEventTypes">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.TextualLogImplementationBase.Format">
            <summary>
            Gets the log format.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.TextualLogImplementationBase.FormatString">
            <summary>
            Gets or sets the custom format string of logged messages.
            Setting value of this property sets <see cref="P:Xtensive.Core.Diagnostics.TextualLogImplementationBase.Format"/>
            to <see cref="F:Xtensive.Core.Diagnostics.LogFormat.Custom"/> as well.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.TextualLogImplementationBase.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ConsoleLog.LogEventText(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ConsoleLog.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.FileLog">
            <summary>
            Console log implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.FileLog.LogEventText(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.FileLog.#ctor(System.String,System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
            <param name="fileName">Name of the file.</param>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.ErrorLog">
            <summary>
            Error log implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ErrorLog.LogEventText(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ErrorLog.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.DebugLog">
            <summary>
            Debug log implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.DebugLog.LogEventText(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.DebugLog.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogProviderType">
            <summary>
            Enumerates supported log providers.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogProviderType.Null">
            <summary>
            Refers to <see cref="T:Xtensive.Core.Diagnostics.NullLog"/> provider.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogProviderType.Console">
            <summary>
            Refers to <see cref="T:Xtensive.Core.Diagnostics.ConsoleLog"/> provider.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogProviderType.Debug">
            <summary>
            Refers to <see cref="T:Xtensive.Core.Diagnostics.DebugLog"/> provider.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogProviderType.Error">
            <summary>
            Refers to <see cref="T:Xtensive.Core.Diagnostics.DebugLog"/> provider.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogProviderType.File">
            <summary>
            Refers to <see cref="T:Xtensive.Core.Diagnostics.FileLog"/> provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILogProvider.GetLog(System.String)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object by its <paramref name="key"/>.
            </summary>
            <param name="key">The key to get the log for.</param>
            <returns>The <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object.</returns>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogEventTypesExtensions">
            <summary>
            <see cref="T:Xtensive.Core.Diagnostics.LogEventTypes"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogEventTypesExtensions.ToShortString(Xtensive.Core.Diagnostics.LogEventTypes)">
            <summary>
            Converts <see cref="T:Xtensive.Core.Diagnostics.LogEventTypes"/> to short string.
            </summary>
            <param name="logEventType">Type of event to convert.</param>
            <returns>Short representation of <paramref name="logEventType"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogFormat">
            <summary>
            Log format.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogFormat.Default">
            <summary>
            Default log format.
            The same as <see cref="F:Xtensive.Core.Diagnostics.LogFormat.Comprehensive"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogFormat.Comprehensive">
            <summary>
            Comprehensive log format.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogFormat.Simple">
            <summary>
            Simple log format.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogFormat.Custom">
            <summary>
            Custom log format.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogProvider">
            <summary>
            Provides (creates or resolves) <see cref="T:Xtensive.Core.Diagnostics.ILog"/> instances by their name.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProvider.GetLog(System.String)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object by its <paramref name="key"/>.
            </summary>
            <param name="key">The key to get the log for.</param>
            <returns>The <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProvider.GetLog(System.Type)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object for the specified <paramref name="type"/>.
            </summary>
            <param name="type">The type to get the log for.</param>
            <returns>The <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object.</returns>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProvider.Instance">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProvider.NullLog">
            <summary>
            Gets <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object forwarding logging messages to nothing.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProvider.ConsoleLog">
            <summary>
            Gets <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object forwarding logging messages to console.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProvider.DebugLog">
            <summary>
            Gets <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object forwarding logging messages to debug output.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProvider.ErrorLog">
            <summary>
            Gets <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object forwarding logging messages to error output.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogProviderImplementation">
            <summary>
            Default <see cref="T:Xtensive.Core.Diagnostics.ILogProvider"/> implementation.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogProviderImplementationBase">
            <summary>
            Base type for log providers.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProviderImplementationBase.GetLog(System.String)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object by its <paramref name="key"/>.
            </summary>
            <param name="key">The key to get the log for.</param>
            <returns>The <see cref="T:Xtensive.Core.Diagnostics.ILog"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProviderImplementationBase.CreateLog(System.String)">
            <summary>
            Creates the log.
            </summary>
            <param name="key">The key.</param>
            <returns><see cref="T:Xtensive.Core.Diagnostics.ILog"/> instance.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProviderImplementationBase.GetLogImplementation(Xtensive.Core.Diagnostics.IRealLog)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.ILog"/> instance.
            </summary>
            <param name="realLog">The real log.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProviderImplementationBase.GetRealLog(System.String)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/> instance.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProviderImplementationBase.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogProviderImplementationBase.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProviderImplementation.GetLogImplementation(Xtensive.Core.Diagnostics.IRealLog)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogProviderImplementation.GetRealLog(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogImplementationBase">
            <summary>
            Actual <see cref="T:Xtensive.Core.Diagnostics.ILog"/> implementation
            forwarding all the events to its <see cref="P:Xtensive.Core.Diagnostics.LogImplementationBase.RealLog"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.ILog">
            <summary>
            Log implementation.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IoC.IContext`1">
            <summary>
            Context contract.
            </summary>
            <typeparam name="TScope">The type of <see cref="T:Xtensive.Core.IoC.Scope`1"/> of the context.</typeparam>
            <seealso cref="T:Xtensive.Core.IoC.Scope`1"/>
        </member>
        <member name="T:Xtensive.Core.IoC.IContext">
            <summary>
            Base interface for any <see cref="T:Xtensive.Core.IoC.IContext`1"/> contract.
            </summary>
            <seealso cref="T:Xtensive.Core.IoC.IContext`1"/>
            <seealso cref="T:Xtensive.Core.IoC.Scope`1"/>
        </member>
        <member name="M:Xtensive.Core.IoC.IContext.Activate">
            <summary>
            Activates the current context.
            </summary>
            <returns><see cref="T:System.IDisposable"/> object (normally - <see cref="T:Xtensive.Core.IoC.Scope`1"/> descendant)
            that can be used to deactivate the context by disposing it.</returns>
            <seealso cref="P:Xtensive.Core.IoC.IContext.IsActive"/>
        </member>
        <member name="P:Xtensive.Core.IoC.IContext.IsActive">
            <summary>
            Indicates whether current context is active.
            </summary>
            <seealso cref="M:Xtensive.Core.IoC.IContext.Activate"/>
        </member>
        <member name="M:Xtensive.Core.IoC.IContext`1.Activate">
            <summary>
            Activates the current context.
            </summary>
            <returns><typeparamref name="TScope"/> object (normally - <see cref="T:Xtensive.Core.IoC.Scope`1"/> descendant)
            that can be used to deactivate the context by disposing it.</returns>
            <seealso cref="P:Xtensive.Core.IoC.IContext.IsActive"/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Debug(System.String,System.Object[])">
            <summary>
            Writes debug message to log.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Debug(System.Exception,System.String,System.Object[])">
            <summary>
            Writes debug message to log.
            </summary>
            <param name="exception">The internal exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Debug(System.Exception)">
            <summary>
            Writes debug message to log.
            </summary>
            <param name="exception">The internal exception.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.DebugRegion(System.String,System.Object[])">
            <summary>
            Creates an indented and titled region in log.
            The region boundaries are logged as debug messages.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
            <returns>An <see cref="T:System.IDisposable"/>, which disposal will
            "close" the region.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Info(System.String,System.Object[])">
            <summary>
            Writes info message to log.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Info(System.Exception,System.String,System.Object[])">
            <summary>
            Writes info message to log.
            </summary>
            <param name="exception">The internal exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Info(System.Exception)">
            <summary>
            Writes info message to log.
            </summary>
            <param name="exception">The internal exception.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.InfoRegion(System.String,System.Object[])">
            <summary>
            Creates an indented and titled region in log.
            The region boundaries are logged as info messages.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
            <returns>
            An <see cref="T:System.IDisposable"/>, which disposal will "close" the region.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Warning(System.String,System.Object[])">
            <summary>
            Writes warning message to log.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Warning(System.Exception,System.String,System.Object[])">
            <summary>
            Writes warning message to log.
            </summary>
            <param name="exception">The internal exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Warning(System.Exception)">
            <summary>
            Writes warning message to log.
            </summary>
            <param name="exception">The internal exception.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Error(System.String,System.Object[])">
            <summary>
            Writes error message to log.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Writes error message to log.
            </summary>
            <param name="exception">The internal exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.Error(System.Exception)">
            <summary>
            Writes error message to log.
            </summary>
            <param name="exception">The internal exception.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.FatalError(System.String,System.Object[])">
            <summary>
            Writes fatal error message to log.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.FatalError(System.Exception,System.String,System.Object[])">
            <summary>
            Writes fatal error message to log.
            </summary>
            <param name="exception">The internal exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.ILog.FatalError(System.Exception)">
            <summary>
            Writes fatal error message to log.
            </summary>
            <param name="exception">The internal exception.</param>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.ILog.RealLog">
            <summary>
            Gets <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/> object that finally processes all the calls 
            to this <see cref="T:Xtensive.Core.Diagnostics.ILog"/> implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.IsLogged(Xtensive.Core.Diagnostics.LogEventTypes)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.UpdateCachedProperties">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.GetFormattedMessage(System.String,System.Object[])">
            <summary>
            Gets the formatted message.
            </summary>
            <param name="format">The format.</param>
            <param name="args">The arguments.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Debug(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Debug(System.Exception,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Debug(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.DebugRegion(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Info(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Info(System.Exception,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Info(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.InfoRegion(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Warning(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Warning(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Error(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Error(System.Exception,System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Error(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.FatalError(System.String,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.FatalError(System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Xtensive#Core#IoC#IContext#Activate">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.Xtensive#Core#IoC#IContext{Xtensive#Core#Diagnostics#LogCaptureScope}#Activate">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogImplementationBase.#ctor(Xtensive.Core.Diagnostics.IRealLog)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="realLog">Real log to wrap.</param>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogImplementationBase.Name">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogImplementationBase.Text">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogImplementationBase.RealLog">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogImplementationBase.LoggedEventTypes">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogImplementationBase.Xtensive#Core#IoC#IContext#IsActive">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.NullLog">
            <summary>
            Null log implementation. Does nothing.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.NullLog.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="T:Xtensive.Core.ActivationException">
            <summary>
            Thrown by <see cref="T:Xtensive.Core.IoC.ServiceContainerBase"/> on activation errors.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ActivationException.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.ActivationException.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Xtensive.Core.ActivationException.#ctor(System.String,System.Exception)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="message">The message.</param>
            <param name="innerException">The inner exception.</param>
        </member>
        <member name="M:Xtensive.Core.ActivationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Cloner">
            <summary>
            Object cloning helper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Cloner.Clone``1(``0)">
            <summary>
            Clones the <paramref name="source"/> using 
            provided <see cref="P:Xtensive.Core.Cloner.Formatter"/>.
            </summary>
            <param name="source">The source to clone.</param>
        </member>
        <member name="M:Xtensive.Core.Cloner.CreateStream">
            <summary>
            Creates the stream to use for cloning.
            </summary>
            <returns>Newly created stream.</returns>
        </member>
        <member name="M:Xtensive.Core.Cloner.#ctor(System.Runtime.Serialization.IFormatter)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="formatter">The <see cref="P:Xtensive.Core.Cloner.Formatter"/>.</param>
        </member>
        <member name="P:Xtensive.Core.Cloner.Formatter">
            <summary>
            Gets the formatter used by this cloner.
            </summary>
        </member>
        <member name="T:Xtensive.Core.DelegateBindExtensions">
            <summary>
            Extension methods for binding delegates to parameters.
            </summary>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``2(System.Func{``0,``1},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``3(System.Func{``0,``1,``2},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``3(System.Func{``0,``1,``2},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Func{``0,``1,``2,``3},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Func{``0,``1,``2,``3},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Func{``0,``1,``2,``3},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Func{``0,``1,``2,``3,``4},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Func{``0,``1,``2,``3,``4},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Func{``0,``1,``2,``3,``4},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Func{``0,``1,``2,``3,``4},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Func{``0,``1,``2,``3,``4,``5},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Func{``0,``1,``2,``3,``4,``5},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Func{``0,``1,``2,``3,``4,``5},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Func{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Func{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Func{``0,``1,``2,``3,``4,``5,``6},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Func{``0,``1,``2,``3,``4,``5,``6},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Func{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Func{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Func{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Func{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>Binds first 14 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>Binds first 14 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>Binds first 15 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>Binds first 14 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>Binds first 15 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``17(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15,``16},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15)">
            <summary>Binds first 16 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``1(System.Action{``0},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``2(System.Action{``0,``1},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``2(System.Action{``0,``1},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``3(System.Action{``0,``1,``2},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``3(System.Action{``0,``1,``2},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Action{``0,``1,``2,``3},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Action{``0,``1,``2,``3},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Action{``0,``1,``2,``3},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Action{``0,``1,``2,``3,``4},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Action{``0,``1,``2,``3,``4},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Action{``0,``1,``2,``3,``4},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Action{``0,``1,``2,``3,``4},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``5(System.Action{``0,``1,``2,``3,``4},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Action{``0,``1,``2,``3,``4,``5},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Action{``0,``1,``2,``3,``4,``5},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Action{``0,``1,``2,``3,``4,``5},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Action{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Action{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``6(System.Action{``0,``1,``2,``3,``4,``5},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``7(System.Action{``0,``1,``2,``3,``4,``5,``6},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``11(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``12(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``13(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``14(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>Binds first 14 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>Binds first 14 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``15(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>Binds first 15 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0)">
            <summary>Binds first 1 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1)">
            <summary>Binds first 2 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2)">
            <summary>Binds first 3 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3)">
            <summary>Binds first 4 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4)">
            <summary>Binds first 5 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5)">
            <summary>Binds first 6 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6)">
            <summary>Binds first 7 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Binds first 8 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>Binds first 9 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>Binds first 10 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10)">
            <summary>Binds first 11 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11)">
            <summary>Binds first 12 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12)">
            <summary>Binds first 13 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13)">
            <summary>Binds first 14 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14)">
            <summary>Binds first 15 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="M:Xtensive.Core.DelegateBindExtensions.Bind``16(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15},``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15)">
            <summary>Binds first 16 argument(s) to specified delegate.</summary>
            <returns> A delegate that takes the rest of arguments of original delegate.</returns>
        </member>
        <member name="T:Xtensive.Core.ExpressionExtensions">
            <summary>
            <see cref="T:System.Linq.Expressions.Expression"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ExpressionExtensions.ToString(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Formats the <paramref name="expression"/>.
            </summary>
            <param name="expression">The expression to format.</param>
            <param name="inCSharpNotation">If set to <see langword="true"/>, 
            the result will be returned in C# notation 
            (<see cref="T:Xtensive.Core.Linq.ExpressionWriter"/> will be used).</param>
            <returns>A string containing formatted expression.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionExtensions.BindParameters(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.Expression[])">
            <summary>
            Bind parameter expressions to <see cref="T:System.Linq.Expressions.LambdaExpression"/>.
            </summary>
            <param name="lambdaExpression"><see cref="T:System.Linq.Expressions.LambdaExpression"/> to bind parameters.</param>
            <param name="parameters"><see cref="T:System.Linq.Expressions.Expression"/>s to bind to <paramref name="lambdaExpression"/></param>
            <returns>Body of <paramref name="lambdaExpression"/> with lambda's parameters replaced with corresponding expression from <paramref name="parameters"/></returns>
            <exception cref="T:System.InvalidOperationException">Something went wrong :(.</exception>
        </member>
        <member name="M:Xtensive.Core.ExpressionExtensions.ToSerializableExpression(System.Linq.Expressions.Expression)">
            <summary>
            Converts specified <see cref="T:System.Linq.Expressions.Expression"/> to <see cref="T:Xtensive.Core.Linq.SerializableExpressions.SerializableExpression"/>.
            </summary>
            <param name="expression">The expression to convert.</param>
            <returns>Serializable expression that represents <paramref name="expression"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionExtensions.ToExpression(Xtensive.Core.Linq.SerializableExpressions.SerializableExpression)">
            <summary>
            Converts specified <see cref="T:Xtensive.Core.Linq.SerializableExpressions.SerializableExpression"/> to <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
            <param name="expression">The expression to convert.</param>
            <returns></returns>
        </member>
        <member name="T:Xtensive.Core.IoC.ServiceAttribute">
            <summary>
            An attribute describing mapping of service implementation to service.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceAttribute.#ctor(System.Type)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type of the service.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceAttribute.#ctor(System.Type,System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type of the service.</param>
            <param name="type">The name of the service.</param>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceAttribute.Type">
            <summary>
            Gets or sets the type of the service.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceAttribute.Name">
            <summary>
            Gets or sets the name of the service.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceAttribute.Singleton">
            <summary>
            Gets or sets a value indicating whether this service is singleton.
            Default value is <see langword="true" />.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceAttribute.Default">
            <summary>
            Gets or sets a value indicating whether this is default service implementation or not.
            Default value is <see langword="false" />.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IoC.Configuration.ConfigurationSection">
            <summary>
            A root element of diagnostics configuration section within a configuration file.
            </summary>
        </member>
        <member name="F:Xtensive.Core.IoC.Configuration.ConfigurationSection.DefaultSectionName">
            <summary>
            Gets default section name for IoC configuration.
            Value is "Xtensive.Core.IoC".
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ConfigurationSection.Containers">
            <summary>
            Gets the collection of container configurations.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ContainerElement.Identifier">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ContainerElement.Name">
            <summary>
            Gets or sets the name of the container. 
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ContainerElement.Type">
            <summary>
            Gets or sets the type of the container. 
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ContainerElement.Parent">
            <summary>
            Gets or sets the name of the parent container. 
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ContainerElement.Explicit">
            <summary>
            Gets the collection of service configurations.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ContainerElement.Auto">
            <summary>
            Gets the automatic .
            </summary>
            <value>The types.</value>
        </member>
        <member name="T:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement">
            <summary>
            Service mapping configuration element.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement.ToNative">
            <summary>
            Converts the element to a native configuration object it corresponds to - 
            i.e. to a <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> object.
            </summary>
            <returns>The result of conversion.</returns>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement.Identifier">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement.Type">
            <summary>
            Gets or sets the type of the service.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement.Name">
            <summary>
            Gets or sets the name of the service.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement.MapTo">
            <summary>
            Gets or sets the type to map the service to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Configuration.ServiceRegistrationElement.Singleton">
            <summary>
            Indicates whether instance of service is container-level singleton or not.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IoC.InheritableScope`2">
            <summary>
            Inheritable <see cref="T:Xtensive.Core.IoC.Scope`1"/> version.
            </summary>
            <typeparam name="TContext">The type of the context.</typeparam>
            <typeparam name="TBaseAncestor">The type of the very base ancestor.</typeparam>
        </member>
        <member name="T:Xtensive.Core.IoC.Scope`1">
            <summary>
            Provides access to the thread-bound stack of contextual information 
            (<typeparamref name="TContext"/>).
            </summary>
            <typeparam name="TContext">The type of the context.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IoC.Scope`1.Activate(`0)">
            <summary>
            Initializes the scope.
            </summary>
            <param name="newContext">The new context.</param>
            <exception cref="T:System.NotSupportedException"><see cref="P:Xtensive.Core.IoC.Scope`1.Context"/> is already initialized.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.Scope`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="context">The context of this scope.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.Scope`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            Does not invoke <see cref="M:Xtensive.Core.IoC.Scope`1.Activate(`0)"/> method.
            </summary>
            <exception cref="T:System.Security.SecurityException">Only one ancestor of each instance
            of this generic type is allowed.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.Scope`1.Dispose(System.Boolean)">
            <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
            <param name="disposing"><see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to release only unmanaged resources.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.Scope`1.Dispose">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Current scope differs from this one.</exception>
        </member>
        <member name="P:Xtensive.Core.IoC.Scope`1.CurrentContext">
            <summary>
            Gets the current context of this type of scope.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Scope`1.CurrentScope">
            <summary>
            Gets the current scope.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Scope`1.Context">
            <summary>
            Gets the context of this scope.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Scope`1.OuterScope">
            <summary>
            Gets the outer <see cref="T:Xtensive.Core.IoC.Scope`1"/> of this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.Scope`1.IsNested">
            <summary>
            Gets a value indicating whether this scope is nested to another one.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.InheritableScope`2.#ctor(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IoC.InheritableScope`2.#ctor">
            <inheritdoc/>
            <exception cref="T:System.Security.SecurityException">Only one ancestor of each instance
            of this generic type is allowed.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.InheritableScope`2.#cctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.TypeInitializer" copy="true"/>
            </summary>
            <exception cref="T:System.Security.SecurityException">Only one ancestor of each instance
            of this generic type is allowed.</exception>
        </member>
        <member name="T:Xtensive.Core.IoC.IServiceContainer">
            <summary>
            Inversion of control container contract.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IHasServices">
            <summary>
            Service provider contract.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IHasServices.GetService``1">
            <summary>
            Gets the service of the specified type <typeparamref name="T"/>.
            Returns <see langword="null" />, if there is no such service.
            </summary>
            <typeparam name="T">The type of the service to get.</typeparam>
            <returns>The service of specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.IServiceContainer.GetAll``1">
            <summary>
            Gets all the instances of type <typeparamref name="TService"/>
            from the container.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns>
            A sequence of all the requested instances.
            </returns>
        </member>
        <member name="M:Xtensive.Core.IoC.IServiceContainer.GetAll(System.Type)">
            <summary>
            Gets all the instances of type <paramref name="serviceType"/>
            from the container.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns>
            A sequence of all the requested instances.
            </returns>
        </member>
        <member name="M:Xtensive.Core.IoC.IServiceContainer.Get``1">
            <summary>
            Gets the instance of <typeparamref name="TService"/> type
            from the container.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <returns>Requested instance.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.IServiceContainer.Get``1(System.String)">
            <summary>
            Gets the instance of <typeparamref name="TService"/> type
            identified by the specified <paramref name="name"/>
            from the container.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="name">The identifier of the service to get.</param>
            <returns>Requested instance.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.IServiceContainer.Get(System.Type)">
            <summary>
            Gets the instance of <paramref name="serviceType"/>
            from the container.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <returns>Requested instance.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.IServiceContainer.Get(System.Type,System.String)">
            <summary>
            Gets the instance of <paramref name="serviceType"/>
            identified by the specified <paramref name="name"/>
            from the container.
            </summary>
            <param name="serviceType">Type of the service.</param>
            <param name="name">The identifier of the service to get.</param>
            <returns>Requested instance.</returns>
        </member>
        <member name="P:Xtensive.Core.IoC.IServiceContainer.Parent">
            <summary>
            Gets the parent service container.
            Parent service container usually resolves services that 
            can't be resolved by the current container.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IoC.ServiceContainerBase">
            <summary>
            Abstract base class for <see cref="T:Xtensive.Core.IoC.IServiceContainer"/>
            implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.GetAll``1">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.GetAll(System.Type)">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Get``1">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Get``1(System.String)">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Get(System.Type)">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.GetService(System.Type)">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Get(System.Type,System.String)">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.GetService``1">
            <inheritdoc/>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s).</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.HandleGetAll(System.Type)">
            <summary>
            Actual implementation of <see cref="M:Xtensive.Core.IoC.ServiceContainerBase.GetAll(System.Type)"/> method.
            </summary>
            <param name="serviceType">Type of the services to get.</param>
            <returns>The sequence of requested services.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.HandleGet(System.Type,System.String)">
            <summary>
            Actual implementation of <see cref="M:Xtensive.Core.IoC.ServiceContainerBase.Get(System.Type,System.String)"/> method.
            </summary>
            <param name="serviceType">Type of the service to get.</param>
            <param name="name">The name of the service. <see langword="null"/>, if name is not specified.</param>
            <returns>The requested service.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.FormatActivationErrorMessage(System.Exception,System.Type)">
            <summary>
            Formats the activation error message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="serviceType">Type of the service.</param>
            <returns>Formatted error message.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.FormatActivationErrorMessage(System.Exception,System.Type,System.String)">
            <summary>
            Formats the activation error message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="serviceType">Type of the service.</param>
            <param name="name">The service name.</param>
            <returns>Formatted error message.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.#ctor(Xtensive.Core.IoC.IServiceContainer)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="parent"><see cref="P:Xtensive.Core.IoC.ServiceContainerBase.Parent"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Dispose(System.Boolean)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)"/>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose"/>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainerBase.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor"/>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceContainerBase.Parent">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.IoC.ServiceContainer">
            <summary>
            Default IoC (inversion of control) container implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.HandleGet(System.Type,System.String)">
            <inheritdoc/>
            <exception cref="T:System.Reflection.AmbiguousMatchException">Multiple services match to the specified arguments.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.HandleGetAll(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.CreateInstance(Xtensive.Core.IoC.ServiceRegistration)">
            <summary>
            Creates the service instance for the specified <paramref name="serviceInfo"/>.
            </summary>
            <param name="serviceInfo">The service info.</param>
            <returns>Specified service instance.</returns>
            <exception cref="T:Xtensive.Core.ActivationException">Something went wrong.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create(System.Type)">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> of the specified type.
            </summary>
            <param name="containerType">Type of the container to create.</param>
            <returns>Created service container.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create(System.Type,Xtensive.Core.IoC.IServiceContainer)">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> of the specified type
            and with the specified <see cref="P:Xtensive.Core.IoC.IServiceContainer.Parent"/>.
            </summary>
            <param name="containerType">Type of the container to create.</param>
            <param name="parent">The parent container.</param>
            <returns>Created service container.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create(System.Type,System.Object)">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> of the specified type
            with specified <paramref name="configuration"/>.
            </summary>
            <param name="containerType">Type of the container to create.</param>
            <param name="configuration">The container's configuration.</param>
            <returns>Created service container.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create(System.Type,System.Object,Xtensive.Core.IoC.IServiceContainer)">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> of the specified type
            with the specified <see cref="P:Xtensive.Core.IoC.IServiceContainer.Parent"/>
            and <paramref name="configuration"/>.
            </summary>
            <param name="containerType">Type of the container to create.</param>
            <param name="configuration">The container's configuration.</param>
            <param name="parent">The parent container.</param>
            <returns>Created service container.</returns>
            <exception cref="T:System.ArgumentException">Wrong container type.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> by default configuration.
            </summary>
            <returns><see cref="T:Xtensive.Core.IoC.IServiceContainer"/> for the default configuration.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create(System.String)">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> by its configuration.
            </summary>
            <param name="name">The name of container configuration to create container for.</param>
            <returns><see cref="T:Xtensive.Core.IoC.IServiceContainer"/> for the specified named configuration.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.Create(Xtensive.Core.IoC.Configuration.ConfigurationSection,System.String)">
            <summary>
            Creates <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> by its configuration.
            </summary>
            <param name="section">IoC configuration section.</param>
            <param name="name">The name of container configuration to create container for.</param>
            <returns><see cref="T:Xtensive.Core.IoC.IServiceContainer"/> for the specified named configuration.</returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.#ctor(System.Collections.Generic.IEnumerable{Xtensive.Core.IoC.ServiceRegistration})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceContainer.#ctor(System.Collections.Generic.IEnumerable{Xtensive.Core.IoC.ServiceRegistration},Xtensive.Core.IoC.IServiceContainer)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="configuration">The configuration.</param>
            <param name="parent">The parent container.</param>
        </member>
        <member name="T:Xtensive.Core.ServiceContainerExtensions">
            <summary>
            <see cref="T:Xtensive.Core.IoC.IServiceContainer"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ServiceContainerExtensions.Demand``1(Xtensive.Core.IoC.IServiceContainer)">
            <summary>
            Demands the specified service 
            using <see cref="M:Xtensive.Core.IoC.IServiceContainer.Get``1"/> method
            and ensures the result is not <see langword="null"/>.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="container">The container to demand the service on.</param>
            <returns></returns>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s),
            or service is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.ServiceContainerExtensions.Demand``1(Xtensive.Core.IoC.IServiceContainer,System.String)">
            <summary>
            Demands the specified service
            using <see cref="M:Xtensive.Core.IoC.IServiceContainer.Get``1(System.String)"/> method
            and ensures the result is not <see langword="null"/>.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="container">The container to demand the service on.</param>
            <param name="name">The service name.</param>
            <returns></returns>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s),
            or service is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.ServiceContainerExtensions.Demand(Xtensive.Core.IoC.IServiceContainer,System.Type)">
            <summary>
            Demands the specified service
            using <see cref="M:Xtensive.Core.IoC.IServiceContainer.Get(System.Type)"/> method
            and ensures the result is not <see langword="null"/>.
            </summary>
            <param name="container">The container to demand the service on.</param>
            <param name="serviceType">Type of the service.</param>
            <returns></returns>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s),
            or service is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.ServiceContainerExtensions.Demand(Xtensive.Core.IoC.IServiceContainer,System.Type,System.String)">
            <summary>
            Demands the specified service
            using <see cref="M:Xtensive.Core.IoC.IServiceContainer.Get(System.Type,System.String)"/> method
            and ensures the result is not <see langword="null"/>.
            </summary>
            <param name="container">The container to demand the service on.</param>
            <param name="serviceType">Type of the service.</param>
            <param name="name">The service name.</param>
            <returns></returns>
            <exception cref="T:Xtensive.Core.ActivationException">There was an error on activation of some instance(s),
            or service is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.ServiceContainerExtensions.EnsureNotNull(System.Object,System.Type,System.String)">
            <exception cref="T:Xtensive.Core.ActivationException">Service is not available.</exception>
        </member>
        <member name="T:Xtensive.Core.IoC.ServiceRegistration">
            <summary>
            Describes single service mapping entry for <see cref="T:Xtensive.Core.IoC.ServiceContainer"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceRegistration.CreateAll(System.Type)">
            <summary>
            Creates an array of <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> objects
            for the specified <paramref name="type"/>
            by scanning it <see cref="T:Xtensive.Core.IoC.ServiceAttribute"/>s.
            </summary>
            <param name="type">The type to provide <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> objects for.</param>
            <returns>
            An array of <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> objects.
            </returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceRegistration.CreateAll(System.Type,System.Boolean)">
            <summary>
            Creates an array of <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> objects
            for the specified <paramref name="type"/>
            by scanning it <see cref="T:Xtensive.Core.IoC.ServiceAttribute"/>s.
            </summary>
            <param name="type">The type to provide <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> objects for.</param>
            <param name="defaultOnly">Return just registrations for which 
            <see cref="P:Xtensive.Core.IoC.ServiceAttribute.Default"/>==<see langword="true"/>.</param>
            <returns>
            An array of <see cref="T:Xtensive.Core.IoC.ServiceRegistration"/> objects.
            </returns>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceRegistration.#ctor(System.Type,System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type of the service.</param>
            <param name="mappedInstance">The instance it is mapped to.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceRegistration.#ctor(System.Type,System.String,System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type of the service.</param>
            <param name="name">The name of the service.</param>
            <param name="mappedInstance">The instance it is mapped to.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceRegistration.#ctor(System.Type,System.Type,System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type of the service.</param>
            <param name="mappedType">The type it is mapped to.</param>
            <param name="singleton">A value indicating whether this service is singleton.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ServiceRegistration.#ctor(System.Type,System.String,System.Type,System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type of the service.</param>
            <param name="name">The name of the service.</param>
            <param name="mappedType">The type it is mapped to.</param>
            <param name="singleton">A value indicating whether this service is singleton.</param>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceRegistration.Type">
            <summary>
            Gets the type of the service.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceRegistration.Name">
            <summary>
            Gets the name of the service.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceRegistration.MappedType">
            <summary>
            Gets the type it is mapped to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceRegistration.MappedInstance">
            <summary>
            Gets the instance it is mapped to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ServiceRegistration.Singleton">
            <summary>
            Gets a value indicating whether this service is singleton.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ExpressionCompileExtensions">
            <summary>
            Extension methods for compiling strictly typed lambda expressions.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``6(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``7(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``8(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``9(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``10(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``11(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``12(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``13(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``14(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``15(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``16(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14,``15}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile(System.Linq.Expressions.Expression{System.Action})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``5(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``6(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``7(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``8(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``9(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``10(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``11(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``12(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``13(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``14(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="M:Xtensive.Core.ExpressionCompileExtensions.CachingCompile``15(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``14}})">
            <summary>Compiles the specified lambda and caches the result of compilation.</summary>
            <returns>Compiled lambda.</returns>
        </member>
        <member name="T:Xtensive.Core.Linq.ExpressionTree">
            <summary>
            A wrapper for <see cref="T:System.Linq.Expressions.Expression"/>.
            that can be used for comparing expression trees and calculating their hash codes.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionTree.ToExpression">
            <summary>
            Gets the underlying <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionTree.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionTree.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionTree.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionTree.Equals(Xtensive.Core.Linq.ExpressionTree)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionTree.op_Equality(Xtensive.Core.Linq.ExpressionTree,Xtensive.Core.Linq.ExpressionTree)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns><see langword="true"/> if <paramref name="left"/> is equal to <paramref name="right"/>.
            Otherwise, <see langword="false"/>.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Linq.ExpressionTree.op_Inequality(Xtensive.Core.Linq.ExpressionTree,Xtensive.Core.Linq.ExpressionTree)" -->
        <member name="T:Xtensive.Core.Linq.ConstantExtractor">
            <summary>
            An <see cref="T:Xtensive.Core.Linq.ExpressionVisitor"/> specialized for extracting constants from specified <see cref="T:System.Linq.Expressions.Expression"/>.
            This class can be used to produce "normalized" expression with all constants extracted to additional parameter.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.ExpressionVisitor">
            <summary>
            An abstract base implementation of <see cref="T:Xtensive.Core.Linq.ExpressionVisitor`1"/>
            returning <see cref="T:System.Linq.Expressions.Expression"/> as its visit result.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.ExpressionVisitor`1">
            <summary>
            Abstract <see cref="T:System.Linq.Expressions.Expression"/> visitor class.
            </summary>
            <typeparam name="TResult">Type of the visit result.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.Visit(System.Linq.Expressions.Expression)">
            <summary>
            Visits the specified expression.
            </summary>
            <param name="e">The expression to visit.</param>
            <returns>Visit result.</returns>
            <remarks>
            <see cref="P:Xtensive.Core.Linq.ExpressionVisitor`1.IsCaching"/> policy is enforced by this method.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitExpressionList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
            <summary>
            Visits the expression list.
            </summary>
            <param name="expressions">The expression list.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitUnknown(System.Linq.Expressions.Expression)">
            <summary>
            Visits the unknown expression.
            </summary>
            <param name="e">The unknown expression.</param>
            <returns>Visit result.</returns>
            <exception cref="T:System.NotSupportedException">Thrown by the base implementation of this method, 
            if unknown expression isn't recognized by its overrides.</exception>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Visits the unary expression.
            </summary>
            <param name="u">The unary expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Visits the binary expression.
            </summary>
            <param name="b">The binary expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <summary>
            Visits the "type is" expression.
            </summary>
            <param name="tb">The "type is" expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Visits the constant expression.
            </summary>
            <param name="c">The constant expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Visits the conditional expression.
            </summary>
            <param name="c">The conditional expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visits the parameter expression.
            </summary>
            <param name="p">The parameter expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <summary>
            Visits the member access expression.
            </summary>
            <param name="m">The member access expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Visits the method call expression.
            </summary>
            <param name="mc">The method call expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Visits the lambda expression.
            </summary>
            <param name="l">The lambda expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Visits the "new" expression.
            </summary>
            <param name="n">The "new" expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Visits the member initialization expression.
            </summary>
            <param name="mi">The member initialization expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <summary>
            Visits the list initialization expression.
            </summary>
            <param name="li">The list initialization expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Visits the "new array" expression.
            </summary>
            <param name="na">The "new array" expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <summary>
            Visits the invocation expression.
            </summary>
            <param name="i">The invocation expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor`1.#ctor(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isCaching">Indicates whether visit result 
            should be cached and resolved by cache when possible.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Xtensive.Core.Linq.ExpressionVisitor`1.IsCaching" -->
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
            <summary>
            Visits the element initializer expression.
            </summary>
            <param name="initializer">The initializer.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitElementInitializerList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ElementInit})">
            <summary>
            Visits the element initializer list.
            </summary>
            <param name="original">The original element initializer list.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <summary>
            Visits the member assignment expression.
            </summary>
            <param name="ma">The member assignment expression.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitBinding(System.Linq.Expressions.MemberBinding)">
            <summary>
            Visits the member binding.
            </summary>
            <param name="binding">The member binding.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <summary>
            Visits the member member binding.
            </summary>
            <param name="binding">The member member binding.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.VisitBindingList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.MemberBinding})">
            <summary>
            Visits the binding list.
            </summary>
            <param name="original">The original binding list.</param>
            <returns>Visit result.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionVisitor.#ctor(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ConstantExtractor.GetConstants">
            <summary>
            Gets an array of extracted constants.
            </summary>
            <value></value>
        </member>
        <member name="M:Xtensive.Core.Linq.ConstantExtractor.Process">
            <summary>
            Extracts constants from <see cref="T:System.Linq.Expressions.LambdaExpression"/> specified in constructor.
            Result is a <see cref="T:System.Linq.Expressions.LambdaExpression"/> with one additional parameter (array of objects).
            Extra parameter is added to first position.
            </summary>
            <returns><see cref="T:System.Linq.Expressions.LambdaExpression"/> with all constants extracted to additional parameter.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ConstantExtractor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ConstantExtractor.#ctor(System.Linq.Expressions.LambdaExpression)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="lambda">An expression to process.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ConstantExtractor.#ctor(System.Linq.Expressions.LambdaExpression,System.Func{System.Linq.Expressions.ConstantExpression,System.Boolean})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="lambda">An expression to process.</param>
            <param name="constantFilter">The constant filter.
            This delegate invoked on each occurrence of <see cref="T:System.Linq.Expressions.ConstantExpression"/>.
            If it returns <see langword="true"/>, constant is extracted, otherwise left untouched.
            </param>
        </member>
        <member name="T:Xtensive.Core.Linq.FastExpression">
            <summary>
            Factory methods for various descendants of <see cref="T:System.Linq.Expressions.Expression"/> that are faster 
            than original ones.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.FastExpression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
            <summary>
            Generates <see cref="T:System.Linq.Expressions.LambdaExpression"/> faster than <see cref="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])"/>.
            </summary>
            <param name="delegateType">A type that represents a delegate type.</param>
            <param name="body">The body of lambda expression.</param>
            <param name="parameters">The parameters of lambda expression.</param>
            <returns>Constructed lambda expression.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.FastExpression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Generates <see cref="T:System.Linq.Expressions.LambdaExpression"/> faster than <see cref="M:System.Linq.Expressions.Expression.Lambda(System.Type,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})"/>.
            </summary>
            <param name="delegateType">A type that represents a delegate type.</param>
            <param name="body">The body of lambda expression.</param>
            <param name="parameters">The parameters of lambda expression.</param>
            <returns>Constructed lambda expression.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.FastExpression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])">
            <summary>
            Generates <see cref="T:System.Linq.Expressions.LambdaExpression"/> faster than <see cref="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])"/>.
            </summary>
            <param name="body">The body of lambda expression.</param>
            <param name="parameters">The parameters of lambda expression.</param>
            <returns>Constructed lambda expression.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.FastExpression.Lambda(System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression})">
            <summary>
            Generates <see cref="T:System.Linq.Expressions.LambdaExpression"/> faster than <see cref="M:System.Linq.Expressions.Expression.Lambda(System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression[])"/>.
            </summary>
            <param name="body">The body of lambda expression.</param>
            <param name="parameters">The parameters of lambda expression.</param>
            <returns>Constructed lambda expression.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionComparer.VisitMemberInit(System.Linq.Expressions.MemberInitExpression,System.Linq.Expressions.MemberInitExpression)">
            <summary>
            Visits the member init.
            </summary>
            <param name="x">The x.</param>
            <param name="y">The y.</param>
            <returns></returns>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableElementInit">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.ElementInit"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableElementInit.AddMethod">
            <summary>
            <see cref="P:System.Linq.Expressions.ElementInit.AddMethod"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableElementInit.Arguments">
            <summary>
            <see cref="P:System.Linq.Expressions.ElementInit.Arguments"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberListBinding">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MemberListBinding"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberBinding">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MemberBinding"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberBinding.BindingType">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberBinding.BindingType"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberBinding.Member">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberBinding.Member"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberListBinding.Initializers">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableListInitExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.ListInitExpression"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableExpression.NodeType">
            <summary>
            <see cref="P:System.Linq.Expressions.Expression.NodeType"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableExpression.Type">
            <summary>
            <see cref="P:System.Linq.Expressions.Expression.Type"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableListInitExpression.NewExpression">
            <summary>
            <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableListInitExpression.Initializers">
            <summary>
            <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableBinaryExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.BinaryExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableBinaryExpression.IsLiftedToNull">
            <summary>
            <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableBinaryExpression.Left">
            <summary>
            <see cref="P:System.Linq.Expressions.BinaryExpression.Left"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableBinaryExpression.Right">
            <summary>
            <see cref="P:System.Linq.Expressions.BinaryExpression.Right"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableBinaryExpression.Method">
            <summary>
            <see cref="P:System.Linq.Expressions.BinaryExpression.Method"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableConditionalExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.ConditionalExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableConditionalExpression.Test">
            <summary>
            <see cref="P:System.Linq.Expressions.ConditionalExpression.Test"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableConditionalExpression.IfTrue">
            <summary>
            <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableConditionalExpression.IfFalse">
            <summary>
            <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableConstantExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.ConstantExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableConstantExpression.Value">
            <summary>
            <see cref="P:System.Linq.Expressions.ConstantExpression.Value"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableInvocationExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.InvocationExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableInvocationExpression.Expression">
            <summary>
            <see cref="P:System.Linq.Expressions.InvocationExpression.Expression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableInvocationExpression.Arguments">
            <summary>
            <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableLambdaExpression">
            <summary>
            A serializable version of <see cref="T:System.Linq.Expressions.LambdaExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableLambdaExpression.Body">
            <summary>
            <see cref="P:System.Linq.Expressions.LambdaExpression.Body"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableLambdaExpression.Parameters">
            <summary>
            <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberAssignment">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MemberAssignment"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberAssignment.Expression">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberAssignment.Expression"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MemberExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberExpression.Expression">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberExpression.Expression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberExpression.Member">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberExpression.Member"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberInitExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MemberInitExpression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberInitExpression.NewExpression">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberInitExpression.Bindings">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberMemberBinding">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MemberMemberBinding"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMemberMemberBinding.Bindings">
            <summary>
            <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableMethodCallExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.MethodCallExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMethodCallExpression.Arguments">
            <summary>
            <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMethodCallExpression.Method">
            <summary>
            <see cref="P:System.Linq.Expressions.MethodCallExpression.Method"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableMethodCallExpression.Object">
            <summary>
            <see cref="P:System.Linq.Expressions.MethodCallExpression.Object"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableNewArrayExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.NewArrayExpression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableNewArrayExpression.Expressions">
            <summary>
            <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableNewExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.NewExpression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableNewExpression.Arguments">
            <summary>
            <see cref="P:System.Linq.Expressions.NewExpression.Arguments"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableNewExpression.Constructor">
            <summary>
            <see cref="P:System.Linq.Expressions.NewExpression.Constructor"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableNewExpression.Members">
            <summary>
            <see cref="P:System.Linq.Expressions.NewExpression.Members"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableParameterExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.ParameterExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableParameterExpression.Name">
            <summary>
            <see cref="P:System.Linq.Expressions.ParameterExpression.Name"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableTypeBinaryExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.TypeBinaryExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableTypeBinaryExpression.Expression">
            <summary>
            <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableTypeBinaryExpression.TypeOperand">
            <summary>
            <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.SerializableExpressions.SerializableUnaryExpression">
            <summary>
            A serializable representation of <see cref="T:System.Linq.Expressions.UnaryExpression"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableUnaryExpression.Operand">
            <summary>
            <see cref="P:System.Linq.Expressions.UnaryExpression.Operand"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.SerializableExpressions.SerializableUnaryExpression.Method">
            <summary>
            <see cref="P:System.Linq.Expressions.UnaryExpression.Method"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.DefaultMapper">
            <summary>
            Default concrete heir of <see cref="T:Xtensive.Core.ObjectMapping.MapperBase`1"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.MapperBase`1">
            <summary>
            A base class for O2O-mapper implementations.
            </summary>
            <typeparam name="TComparisonResult">The type of graphs comparison result.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.Transform(System.Object)">
            <summary>
            Transforms an object of the source type to an object of the target type.
            </summary>
            <param name="source">The source object.</param>
            <returns>The transformed object.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.Compare(System.Object,System.Object)">
            <summary>
            Compares two object graphs of the target type and generates a set of operations
            which may be used to apply found modifications to source objects.
            </summary>
            <param name="originalTarget">The original object graph.</param>
            <param name="modifiedTarget">The modified object graph.</param>
            <returns>The <see cref="T:Xtensive.Core.ObjectMapping.GraphComparisonResult"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.OnObjectModified(Xtensive.Core.ObjectMapping.Operation)">
            <summary>
            Called when a difference in object graphs has been found.
            </summary>
            <param name="descriptor">The descriptor of operation.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.InitializeComparison(System.Object,System.Object)">
            <summary>
            Initializes comparison process.
            </summary>
            <param name="originalTarget">The original object graph.</param>
            <param name="modifiedTarget">The modified object graph.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.GetComparisonResult(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            Gets the set of operations describing found changes and the mapping from surrogate
            keys to real keys for new objects.
            </summary>
            <param name="originalObjects">The set of objects from the original graph.</param>
            <param name="modifiedObjects">The set of objects from the modified graph.</param>
            <returns>The <see cref="T:Xtensive.Core.ObjectMapping.GraphComparisonResult"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.#ctor(Xtensive.Core.ObjectMapping.Model.MappingDescription)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="mappingDescription">The mapping description.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperBase`1.#ctor(Xtensive.Core.ObjectMapping.Model.MappingDescription,Xtensive.Core.ObjectMapping.MapperSettings)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="mappingDescription">The mapping description.</param>
            <param name="settings">The mapper settings.</param>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.MapperBase`1.MappingDescription">
            <summary>
            Gets the mapping description.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.MapperBase`1.Settings">
            <summary>
            Gets or sets the mapper settings.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultMapper.OnObjectModified(Xtensive.Core.ObjectMapping.Operation)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultMapper.InitializeComparison(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultMapper.GetComparisonResult(System.Collections.Generic.Dictionary{System.Object,System.Object},System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultMapper.#ctor(Xtensive.Core.ObjectMapping.Model.MappingDescription)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="mappingDescription">The mapping description.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultMapper.#ctor(Xtensive.Core.ObjectMapping.Model.MappingDescription,Xtensive.Core.ObjectMapping.MapperSettings)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="mappingDescription">The mapping description.</param>
            <param name="settings">The mapper settings.</param>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.DefaultOperationLog">
            <summary>
            Default implementation of <see cref="T:Xtensive.Core.IOperationSequence"/> and operation logger.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultOperationLog.Replay(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultOperationLog.Add(Xtensive.Core.ObjectMapping.Operation)">
            <summary>
            Adds the specified operation.
            </summary>
            <param name="operation">The operation.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultOperationLog.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.DefaultOperationLog.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.DefaultOperationLog.Count">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.GraphComparisonResult">
            <summary>
            Result of comparison the original graph of target objects with the modified one.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.GraphComparisonResult.Operations">
            <summary>
            The set of operations describing found changes.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.GraphComparisonResult.KeyMapping">
            <summary>
            The mapping from surrogate keys to real keys for new objects.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.GraphComparisonResult.#ctor(Xtensive.Core.IOperationSequence,Xtensive.Core.Collections.ReadOnlyDictionary{System.Object,System.Object})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="operations">The set of operations describing found changes.</param>
            <param name="keyMapping">The mapping from surrogate keys to real keys for new objects.</param>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.GraphTruncationType">
            <summary>
            Action that is taken to truncate a graph. This action is applied
            when a limit of an object graph depth has been exceeded.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.GraphTruncationType.Default">
            <summary>
            Default action.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.GraphTruncationType.Throw">
            <summary>
            Throw the exception.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.GraphTruncationType.SetDefaultValue">
            <summary>
            Set the default value to a property whose value exceeds a graph depth limit.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.IMappingBuilder">
            <summary>
            Contract for classes which build a mapping configuration for an O2O-mapper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilder.MapType``3(System.Func{``0,``2},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <summary>
            Registers the mapping from <typeparamref name="TSource"/> to <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="sourceKeyExtractor">The source key extractor.</param>
            <param name="targetKeyExtractor">The target key extractor.</param>
            <returns>An instance of helper class.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilder.MapType``3(System.Func{``0,``2},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``1,System.Object[]})">
            <summary>
            Registers the mapping from <typeparamref name="TSource"/> to <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <typeparam name="TKey">The type of the key.</typeparam>
            <param name="sourceKeyExtractor">The source key extractor.</param>
            <param name="targetKeyExtractor">The target key extractor.</param>
            <param name="generatorArgumentsProvider">The provider of arguments for an
            algorithm of a new source object creation. For example, it can provide arguments for a custom
            constructor or a key generator.</param>
            <returns>An instance of helper class.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilder.MapStructure``2">
            <summary>
            Registers the mapping from <typeparamref name="TSource"/> to <typeparamref name="TTarget"/>.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
            <returns>An instance of helper class.</returns>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2">
            <summary>
            Contract of classes which helps to build a mapping configuration for an O2O-mapper.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TTarget">The target type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2.MapProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Registers mapping of a source property to a target property.
            </summary>
            <typeparam name="TValue">The type of the property's value.</typeparam>
            <param name="source">The expression that calculates a value to be assigned to target property.
            It may contain the access to a target property or an arbitrary delegate.</param>
            <param name="target">The target property's expression.</param>
            <returns><see langword="this" /></returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2.IgnoreProperty``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <summary>
            Specifies that the property won't be converted and its modifications won't be detected.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="target">The target property's expression.</param>
            <returns><see langword="this" /></returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2.TrackChanges``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Boolean)">
            <summary>
            Specifies whether modification of the given property will be tracked.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="target">The target property's expression.</param>
            <param name="isEnabled">if set to <see langword="true"/> then changes will be tracked.</param>
            <returns><see langword="this"/></returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2.Inherit``3">
            <summary>
            Registers mapping from the <typeparamref name="TDescendantSource"/>
            to the <typeparamref name="TDescendantTarget"/>.
            </summary>
            <typeparam name="TTargetBase">The ancestor of the <typeparamref name="TDescendantTarget"/>.</typeparam>
            <typeparam name="TDescendantSource">The source type.</typeparam>
            <typeparam name="TDescendantTarget">The target type.</typeparam>
            <returns>A new instance of helper class.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2.Inherit``3(System.Func{``2,System.Object[]})">
            <summary>
            Registers mapping from the <typeparamref name="TDescendantSource"/>
            to the <typeparamref name="TDescendantTarget"/>.
            </summary>
            <typeparam name="TTargetBase">The ancestor of the <typeparamref name="TDescendantTarget"/>.</typeparam>
            <typeparam name="TDescendantSource">The source type.</typeparam>
            <typeparam name="TDescendantTarget">The target type.</typeparam>
            <param name="generatorArgumentsProvider">The provider of arguments for an
            algorithm of a new source object creation. For example, it can provide arguments for a custom
            constructor or a key generator.</param>
            <returns>A new instance of helper class.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.IMappingBuilderAdapter`2.Build">
            <summary>
            Completes creation of the mapping.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.MapProperty``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.IgnoreProperty``1(System.Linq.Expressions.Expression{System.Func{`1,``0}})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.TrackChanges``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.MapType``3(System.Func{``0,``2},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.MapType``3(System.Func{``0,``2},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``1,System.Object[]})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.MapStructure``2">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.Inherit``3">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.Inherit``3(System.Func{``2,System.Object[]})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.Build">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilderAdapter`2.#ctor(Xtensive.Core.ObjectMapping.MappingBuilder)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="realBuilder">The real mapper.</param>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.MapperSettings">
            <summary>
            Settings for O2O-mapper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MapperSettings.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.MapperSettings.GraphTruncationType">
            <summary>
            Gets or sets the action that is taken to truncate a graph.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.MapperSettings.GraphDepthLimit">
            <summary>
            Gets the limit of a graph depth.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.MapperSettings.EnableDynamicSourceHierarchies">
            <summary>
            Gets or sets a value indicating whether hierarchies of source types
            can be expanded by the mapper. If this option is enabled the mapper
            can transform instance of class which hasn't been registered in the mapping,
            but is descendant of a class that has been registered.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.MappingBuilder">
            <summary>
            Builder of mapping for <see cref="T:Xtensive.Core.ObjectMapping.MapperBase`1"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilder.MapType``3(System.Func{``0,``2},System.Linq.Expressions.Expression{System.Func{``1,``2}})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilder.MapType``3(System.Func{``0,``2},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``1,System.Object[]})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.MappingBuilder.MapStructure``2">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.ObjectKind">
            <summary>
            Kind of an object whose type described by a <see cref="T:Xtensive.Core.ObjectMapping.Model.TypeDescription"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.ObjectKind.Entity">
            <summary>
            The entity.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.ObjectKind.UserStructure">
            <summary>
            The user structure.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.ObjectKind.Primitive">
            <summary>
            The primitive type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.SourcePropertyDescription">
            <summary>
            Descriptor of a property of a source mapped type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.PropertyDescription">
            <summary>
            Description of a property of a mapped class.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.PropertyDescription.SystemProperty">
            <summary>
            Gets the underlying system property.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.PropertyDescription.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.PropertyDescription.#ctor(System.Reflection.PropertyInfo,Xtensive.Core.ObjectMapping.Model.TypeDescription)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemProperty">The system property.</param>
            <param name="reflectedType">The the type that was used to obtain this description.</param>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.PropertyDescription.ReflectedType">
            <summary>
            Gets the type that was used to obtain this description.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.PropertyDescription.IsCollection">
            <summary>
            Gets a value indicating whether this instance is collection property.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.PropertyDescription.CountProperty">
            <summary>
            Gets the descriptor of the collection's "Count" property.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.PropertyDescription.AddMethod">
            <summary>
            Gets the descriptor of the collection's "Add" method.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.SourcePropertyDescription.#ctor(System.Reflection.PropertyInfo,Xtensive.Core.ObjectMapping.Model.SourceTypeDescription)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemProperty">The system property.</param>
            <param name="reflectedType">The the type that was used to obtain this description.</param>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.SourcePropertyDescription.ReflectedType">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.SourceTypeDescription">
            <summary>
            Description of source mapped type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.TypeDescription">
            <summary>
            Description of mapped type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.TypeDescription.KeyExtractor">
            <summary>
            Delegate that can be used to extract a key of an object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.TypeDescription.Properties">
            <summary>
            Collection of properties contained in the type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.TypeDescription.SystemType">
            <summary>
            Underlying system type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.TypeDescription.ObjectKind">
            <summary>
            Kind of an object whose type described by this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TypeDescription.GetProperty(System.Reflection.PropertyInfo)">
            <summary>
            Gets the property.
            </summary>
            <param name="systemProperty">The system property.</param>
            <returns>The <see cref="T:Xtensive.Core.ObjectMapping.Model.PropertyDescription"/> for the specified <see cref="T:System.Reflection.PropertyInfo"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TypeDescription.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TypeDescription.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TypeDescription.AddProperty(Xtensive.Core.ObjectMapping.Model.PropertyDescription)">
            <summary>
            Adds the property.
            </summary>
            <param name="property">The property.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TypeDescription.#ctor(System.Type,System.Func{System.Object,System.Object})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemType">The system type.</param>
            <param name="keyExtractor">The key extractor.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TypeDescription.#ctor(System.Type)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemType">The system type.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.SourceTypeDescription.GetProperty(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.SourceTypeDescription.AddProperty(Xtensive.Core.ObjectMapping.Model.SourcePropertyDescription)">
            <summary>
            Adds the property.
            </summary>
            <param name="property">The property.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.SourceTypeDescription.#ctor(System.Type,System.Func{System.Object,System.Object})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemType">The system type.</param>
            <param name="keyExtractor">The key extractor.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.SourceTypeDescription.#ctor(System.Type)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemType">The system type.</param>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.SourceTypeDescription.TargetType">
            <summary>
            Gets the corresponding target type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.OperationType">
            <summary>
            Type of modification detected in an object graph.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.OperationType.CreateObject">
            <summary>
            Creating an object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.OperationType.RemoveObject">
            <summary>
            Removing an object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.OperationType.SetProperty">
            <summary>
            Setting a property value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.OperationType.AddItem">
            <summary>
            Adding an item to a collection.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.OperationType.RemoveItem">
            <summary>
            Removing an item from a collection.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Operation">
            <summary>
            Provides information about an operation that modified state of mapped object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Operation.Object">
            <summary>
            The target (mapped) object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Operation.PropertyPath">
            <summary>
            The path to the property that has been modified.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Operation.Type">
            <summary>
            The operation type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Operation.Value">
            <summary>
            The new property value or the collection item, if any.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Operation.#ctor(System.Object,Xtensive.Core.ObjectMapping.OperationType,Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription[],System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="obj">The value of <see cref="F:Xtensive.Core.ObjectMapping.Operation.Object"/>.</param>
            <param name="type">The value of <see cref="F:Xtensive.Core.ObjectMapping.Operation.Type"/>.</param>
            <param name="propertyPath">The value of <see cref="F:Xtensive.Core.ObjectMapping.Operation.PropertyPath"/>.</param>
            <param name="value">The value of <see cref="F:Xtensive.Core.ObjectMapping.Operation.Value"/>.</param>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.GraphTransformer">
            <summary>
            Object graph transformer.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.GraphTransformer.Transform(System.Object)">
            <summary>
            Transforms an object graph.
            </summary>
            <param name="source">The source graph.</param>
            <returns>The transformed graph.</returns>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.GraphTransformer.#ctor(Xtensive.Core.ObjectMapping.Model.MappingDescription,Xtensive.Core.ObjectMapping.MapperSettings)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="mappingDescription">The mapping description.</param>
            <param name="mapperSettings">The mapper settings.</param>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription">
            <summary>
            Descriptor of a property of a target mapped type.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription.#ctor(System.Reflection.PropertyInfo,Xtensive.Core.ObjectMapping.Model.TargetTypeDescription)" -->
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription.ReflectedType">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription.ValueType">
            <summary>
            Gets the type of the value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription.SourceProperty">
            <summary>
            Gets the source property bound to this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription.IsIgnored">
            <summary>
            Gets a value indicating whether modifications of this property are ignored.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription.IsChangeTrackingDisabled">
            <summary>
            Gets a value indicating whether change tracking for this property is disabled.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription">
            <summary>
            Description of target mapped type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.GeneratorArgumentsProvider">
            <summary>
            Gets the provider of arguments for an algorithm of a new source 
            object creation. For example, it can provide arguments for a custom
            constructor or a key generator.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.GetProperty(System.Reflection.PropertyInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.AddProperty(Xtensive.Core.ObjectMapping.Model.TargetPropertyDescription)">
            <summary>
            Adds the property.
            </summary>
            <param name="property">The property.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.#ctor(System.Type,System.Func{System.Object,System.Object},System.Func{System.Object,System.Object[]})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemType">The system type.</param>
            <param name="keyExtractor">The key extractor.</param>
            <param name="generatorArgumentsProvider">The provider of arguments for an algorithm of a new source 
            object creation. For example, it can provide arguments for a custom
            constructor or a key generator.</param>
        </member>
        <member name="M:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.#ctor(System.Type)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="systemType">The system type.</param>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.SourceType">
            <summary>
            Gets the corresponding source type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.PrimitiveProperties">
            <summary>
            Gets the collection of primitive properties.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.ComplexProperties">
            <summary>
            Gets the collection of complex properties.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.MutableProperties">
            <summary>
            Gets mutable properties.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.DirectDescendants">
            <summary>
            Gets direct descendants.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ObjectMapping.Model.TargetTypeDescription.Ancestor">
            <summary>
            Gets the ancestor.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Parameters.ParameterContextExtensions">
            <summary>
            Various extension methods related to this namespace.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterContextExtensions.ActivateSafely(Xtensive.Core.Parameters.ParameterContext)">
            <summary>
            Activates specified <see cref="T:Xtensive.Core.Parameters.ParameterContext"/> if it is not null;
            otherwise does nothing.
            </summary>
            <param name="context">The context to activate.</param>
            <returns><see cref="T:Xtensive.Core.Parameters.ParameterScope"/> if <paramref name="context"/> is not <see langword="null"/>;
            otherwise <see langword="null"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.IoC.SimpleScope`1">
            <summary>
            Provides access to the thread-bound stack of contextual information
            (<typeparamref name="TVariator"/>).
            </summary>
            <typeparam name="TVariator">The type of the variator. Must be an internal type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IoC.SimpleScope`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <exception cref="T:System.Security.SecurityException">Only one ancestor of each instance 
            of this generic type is allowed.</exception>
        </member>
        <member name="M:Xtensive.Core.IoC.SimpleScope`1.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.SimpleScope`1.Dispose">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Scope can't be disposed.</exception>
        </member>
        <member name="P:Xtensive.Core.IoC.SimpleScope`1.Current">
            <summary>
            Gets the current scope.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.SimpleScope`1.Outer">
            <summary>
            Gets the outer <see cref="T:Xtensive.Core.IoC.Scope`1"/> of this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.SimpleScope`1.IsNested">
            <summary>
            Gets a value indicating whether this scope is nested to another one.
            </summary>
        </member>
        <member name="T:Xtensive.Core.DirectionExtensions">
            <summary>
              <see cref="T:Xtensive.Core.Direction"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.DirectionExtensions.Invert(Xtensive.Core.Direction)">
            <summary>
            Inverts the specified direction.
            </summary>
            <param name="direction">The direction to invert.</param>
            <returns>Inverted direction.</returns>
        </member>
        <member name="M:Xtensive.Core.DirectionExtensions.Combine(Xtensive.Core.Direction,Xtensive.Core.Direction)">
            <summary>
            Combines the <paramref name="direction"/> with the <paramref name="combineWith"/>.
            In fact, multiplies integer values of both directions.
            </summary>
            <param name="direction">The original direction.</param>
            <param name="combineWith">The direction to combine with.</param>
            <returns>The result of combination.</returns>
        </member>
        <member name="T:Xtensive.Core.Disposing.JoiningDisposable">
            <summary>
            Disposes two <see cref="T:System.IDisposable"/> objects.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Disposing.JoiningDisposable.op_BitwiseAnd(Xtensive.Core.Disposing.JoiningDisposable,System.IDisposable)">
            <summary>
            Joins the <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> and <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="first">The first disposable to join.</param>
            <param name="second">The second disposable to join.</param>
            <returns>New <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal</returns>
        </member>
        <member name="M:Xtensive.Core.Disposing.JoiningDisposable.#ctor(System.IDisposable,System.IDisposable)">
            <summary>
              <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="disposable1">The first disposable.</param>
            <param name="disposable2">The second disposable.</param>
        </member>
        <member name="M:Xtensive.Core.Disposing.JoiningDisposable.Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Disposing.JoiningDisposable.First">
            <summary>
            Gets the first object to dispose.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Disposing.JoiningDisposable.Second">
            <summary>
            Gets the second object to dispose.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Disposing.DisposingState">
            <summary>
            State of disposable object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Disposing.DisposingState.None">
            <summary>
            The object is not disposed or being disposed; operational state.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Disposing.DisposingState.Disposing">
            <summary>
            The object is in disposing state.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Disposing.DisposingState.Disposed">
            <summary>
            The object has been disposed.
            </summary>
        </member>
        <member name="T:Xtensive.Core.EnumerationState">
            <summary>
            Describes possible enumeration states.
            </summary>
        </member>
        <member name="F:Xtensive.Core.EnumerationState.NotStarted">
            <summary>
            Enumeration isn't started yet - i.e. there were no calls to <see cref="M:System.Collections.IEnumerator.MoveNext"/>.
            Next state can be <see cref="F:Xtensive.Core.EnumerationState.Started"/>, <see cref="F:Xtensive.Core.EnumerationState.Finishing"/> or <see cref="F:Xtensive.Core.EnumerationState.Finished"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.EnumerationState.Started">
            <summary>
            Enumeration is started - i.e. there were just sucessful calls to <see cref="M:System.Collections.IEnumerator.MoveNext"/>.
            Next state can be <see cref="F:Xtensive.Core.EnumerationState.Finishing"/> or <see cref="F:Xtensive.Core.EnumerationState.Finished"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.EnumerationState.Finishing">
            <summary>
            Enumeration is finishing - i.e. next call to <see cref="M:System.Collections.IEnumerator.MoveNext"/> will 
            definitely return <see langwrd="false"/>.
            Next state can be <see cref="F:Xtensive.Core.EnumerationState.Finished"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.EnumerationState.Finished">
            <summary>
            Enumeration is finished - i.e. any call to <see cref="M:System.Collections.IEnumerator.MoveNext"/> will fail.
            Next state can be <see cref="F:Xtensive.Core.EnumerationState.Finished"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.AggregateException">
            <summary>
            Aggregates a set of caught exceptions.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IHasExceptions`1">
            <summary>
            An object having <see cref="P:Xtensive.Core.IHasExceptions`1.Exceptions"/> property.
            </summary>
            <typeparam name="TException">The type of the exception.</typeparam>
        </member>
        <member name="T:Xtensive.Core.IHasExceptions">
            <summary>
            "Has exceptions" contract.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHasExceptions.Exceptions">
            <summary>
            Gets the sequence of exceptions associated with the current object.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHasExceptions`1.Exceptions">
            <summary>
            Gets the enumerable of exceptions related to this object.
            </summary>
        </member>
        <member name="M:Xtensive.Core.AggregateException.GetFlatExceptions">
            <summary>
            Gets the "flat" list with all aggregated exceptions. 
            If other <see cref="T:Xtensive.Core.AggregateException"/>s were aggregated, 
            their inner exceptions are included instead of them.
            </summary>
            <returns>Flat list of aggregated exceptions.</returns>
        </member>
        <member name="M:Xtensive.Core.AggregateException.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.AggregateException.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.AggregateException.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="text">Text of message.</param>
        </member>
        <member name="M:Xtensive.Core.AggregateException.#ctor(System.String,System.Exception)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="message">Text of message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="M:Xtensive.Core.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="exceptions">Inner exceptions.</param>
        </member>
        <member name="M:Xtensive.Core.AggregateException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="message">Text of message.</param>
            <param name="exceptions">Inner exceptions.</param>
        </member>
        <member name="M:Xtensive.Core.AggregateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.AggregateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.AggregateException.Exceptions">
            <summary>
            Gets the list of caught exceptions.
            </summary>
        </member>
        <member name="P:Xtensive.Core.AggregateException.Xtensive#Core#IHasExceptions#Exceptions">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.AggregateException.Xtensive#Core#IHasExceptions{System#Exception}#Exceptions">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.HasVersion`2">
            <summary>
            A pair of <see cref="F:Xtensive.Core.HasVersion`2.Value"/> and its <see cref="F:Xtensive.Core.HasVersion`2.Version"/>.
            </summary>
            <typeparam name="TValue">The <see cref="T:System.Type"/> of <see cref="F:Xtensive.Core.HasVersion`2.Value"/>.</typeparam>
            <typeparam name="TVersion">The <see cref="T:System.Type"/> of <see cref="F:Xtensive.Core.HasVersion`2.Version"/>.</typeparam>
        </member>
        <member name="F:Xtensive.Core.HasVersion`2.Value">
            <summary>
            The value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.HasVersion`2.Version">
            <summary>
            The version bound to <see cref="F:Xtensive.Core.HasVersion`2.Value"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.Equals(Xtensive.Core.HasVersion{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.CompareTo(Xtensive.Core.HasVersion{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.op_Equality(Xtensive.Core.HasVersion{`0,`1},Xtensive.Core.HasVersion{`0,`1})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.op_Inequality(Xtensive.Core.HasVersion{`0,`1},Xtensive.Core.HasVersion{`0,`1})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.HasVersion`2.#ctor(`0,`1)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">Initial <see cref="F:Xtensive.Core.HasVersion`2.Value"/> value.</param>
            <param name="version">Initial <see cref="F:Xtensive.Core.HasVersion`2.Version"/> value.</param>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.RuntimeInfo">
            <summary>
            Provides various runtime related information.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RuntimeInfo.PointerSize">
            <summary>
            Gets the size of the pointer (reference field) in bytes.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RuntimeInfo.DefaultStructLayoutPack">
            <summary>
            Gets default struct or class field alignment in bytes.
            See <see cref="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack">StructLayoutAttribute.Pack</see> for further information.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.RuntimeInfo.MinimalObjectSize">
            <summary>
            Gets the minimal size of any object in bytes.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Hashing.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.CompilerContainerAttribute">
            <summary>
            Attribute for specifying user defined extension type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.CompilerContainerAttribute.#ctor(System.Type,Xtensive.Core.Linq.ConflictHandlingMethod)">
            <summary>
              <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="extensionType">The type.</param>
            <param name="conflictHandlingMethod">The conflict handling method.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.CompilerContainerAttribute.#ctor(System.Type)">
            <summary>
              <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="extensionType">The type.</param>
        </member>
        <member name="P:Xtensive.Core.Linq.CompilerContainerAttribute.ExtensionType">
            <summary>
            Gets the type value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Linq.CompilerContainerAttribute.ConflictHandlingMethod">
            <summary>
            Gets the conflict handling method value.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.ComparisonExtractor">
            <summary>
            Extractor of comparison operation from <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.ComparisonExtractor.Extract(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Boolean})">
            <summary>
            Extracts an information about a comparison operation. A comparison is
            considered regarding a key selected by <paramref name="keySelector"/>.
            </summary>
            <param name="exp">The <see cref="T:System.Linq.Expressions.Expression"/> containing a comparison
            operation.</param>
            <param name="keySelector">The key selector.</param>
            <returns>An information about a comparison operation or <see langword="null"/>,
            if a comparison operation was not found.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ComparisonExtractor.ContainsKey(System.Linq.Expressions.Expression,System.Func{System.Linq.Expressions.Expression,System.Boolean})">
            <summary>
            Determines whether <paramref name="exp"/> contains key.
            </summary>
            <param name="exp">The expression.</param>
            <param name="keySelector">The key selector.</param>
            <returns>
              <see langword="true"/> if <paramref name="exp"/> contains key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Linq.ExpressionExtensions">
            <summary>
            <see cref="T:System.Linq.Expressions.Expression"/> related extension methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Linq.ExpressionExtensions.MakeTupleAccess(System.Linq.Expressions.Expression,System.Type,System.Int32)" -->
        <member name="M:Xtensive.Core.Linq.ExpressionExtensions.MakeIsNullCondition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Makes <c>IsNull</c> condition expression.
            </summary>
            <param name="target">Target expression</param>
            <param name="ifNull">Result expression if <paramref name="target"/> is null.</param>
            <param name="ifNotNull">Result expression if <paramref name="target"/> is not null.</param>
            <returns><see cref="T:System.Linq.Expressions.ConditionalExpression"/></returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionExtensions.StripQuotes(System.Linq.Expressions.Expression)">
            <summary>
            Strips <see cref="M:System.Linq.Expressions.Expression.Quote(System.Linq.Expressions.Expression)"/> expressions.
            </summary>
            <param name="expression">The expression.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionExtensions.StripCasts(System.Linq.Expressions.Expression)">
            <summary>
            Strips <see cref="F:System.Linq.Expressions.ExpressionType.Convert"/> and <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs"/>.
            </summary>
            <param name="expression">The expression.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionExtensions.LiftToNullable(System.Linq.Expressions.Expression)">
            <summary>
            Converts expression type to nullable type (for value types).
            </summary>
            <param name="expression">The expression.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionExtensions.IsNull(System.Linq.Expressions.Expression)">
            <summary>
            Determines whether the specified expression is <see cref="T:System.Linq.Expressions.ConstantExpression"/> 
            with <see langword="null"/> <see cref="P:System.Linq.Expressions.ConstantExpression.Value"/>.
            </summary>
            <param name="expression">The expression.</param>
            <returns>
              <see langword="true"/> if the specified expression is null; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionExtensions.ToExpressionTree(System.Linq.Expressions.Expression)">
            <summary>
            Converts specified <see cref="T:System.Linq.Expressions.Expression"/> to <see cref="T:Xtensive.Core.Linq.ExpressionTree"/>.
            </summary>
            <param name="expression">The expression to convert.</param>
            <returns>Expression tree that wraps <paramref name="expression"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.Linq.IExpressionSource">
            <summary>
            An object that can be converted to <see cref="T:System.Linq.Expressions.Expression"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.IExpressionSource.ToExpression">
            <summary>
            Converts the object to expression.
            </summary>
            <returns>An expression equivalent to (or associated with) this object.</returns>
        </member>
        <member name="T:Xtensive.Core.Linq.ComparisonInfo">
            <summary>
            Information about a comparison operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonInfo.Key">
            <summary>
            The key part of the comparison expression.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonInfo.Value">
            <summary>
            The value part of the comparison expression.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonInfo.Operation">
            <summary>
            The comparison operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonInfo.ComplexMethod">
            <summary>
            Contains the comparison method call expression, in case it is complex;
            otherwise, contains <see langword="null" />.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Linq.ComparisonInfo.IsComplex">
            <summary>
            Gets a value indicating whether a comparison operation is complex.
            </summary>
            <value>
              <see langword="true"/> if <see cref="F:Xtensive.Core.Linq.ComparisonInfo.ComplexMethod"/> is not 
              <see langword="null"/>; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:Xtensive.Core.Linq.ComparisonOperation">
            <summary>
            Comparison operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.Unknown">
            <summary>
            The operation is unknown.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.Equal">
            <summary>
            The equality operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.NotEqual">
            <summary>
            The non-equality operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.LessThan">
            <summary>
            The 'less than' operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.LessThanOrEqual">
            <summary>
            The 'less than or equal' operation
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.GreaterThan">
            <summary>
            The 'greater than' operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.GreaterThanOrEqual">
            <summary>
            The 'greater than or equal' operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.LikeStartsWith">
            <summary>
            The operation corresponding to a call to one of following methods: 
            <see cref="M:System.String.StartsWith(System.String)"/>, 
            <see cref="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)"/>, 
            <see cref="M:System.String.StartsWith(System.String,System.StringComparison)"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.LikeEndsWith">
            <summary>
            The operation corresponding to a call to one of following methods: 
            <see cref="M:System.String.EndsWith(System.String)"/>, 
            <see cref="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)"/>, 
            <see cref="M:System.String.EndsWith(System.String,System.StringComparison)"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.NotLikeStartsWith">
            <summary>
            The negation of the 'like starts with' operation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ComparisonOperation.NotLikeEndsWith">
            <summary>
            The negation of the 'like ends with' operation.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.Normalization.Conjunction`1">
            <summary>
            A conjunction ("and") of multiple operands.
            </summary>
            <typeparam name="T">The type of operand.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1">
            <summary>
            An abstract base class for any operation with multiple operands.
            </summary>
            <typeparam name="T">The type of operand.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1.ToExpression">
            <summary>
            Creates equivalent <see cref="T:System.Linq.Expressions.Expression"/> object.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="single">The single operand.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="operands">The initial <see cref="P:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1.Operands"/> content.</param>
        </member>
        <member name="P:Xtensive.Core.Linq.Normalization.MultiOperandOperation`1.Operands">
            <summary>
            Gets the operands.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Conjunction`1.ToExpression">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">All operands must be <see cref="T:System.Linq.Expressions.Expression"/>s 
            with <see cref="T:System.Boolean"/> type.</exception>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Conjunction`1.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Conjunction`1.#ctor(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Conjunction`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Linq.Normalization.Disjunction`1">
            <summary>
            A disjunction ("or") of multiple operands.
            </summary>
            <typeparam name="T">The type of operand.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Disjunction`1.ToExpression">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">All operands must be Expressions with type Boolean.</exception>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Disjunction`1.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Disjunction`1.#ctor(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.Disjunction`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Linq.Normalization.DisjunctiveNormalized">
            <summary>
            A disjunctive normalized expression 
            ("([not] Arg1 [and [not] Arg2 [and...]]) [or (...)]").
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalized.Validate">
            <summary>
            Validates this instance.
            </summary>
            <exception cref="T:System.InvalidOperationException">Some conjunction operands are not
            <see cref="T:System.Linq.Expressions.Expression"/>s of type <see cref="T:System.Boolean"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalized.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalized.#ctor(Xtensive.Core.Linq.Normalization.Conjunction{System.Linq.Expressions.Expression})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalized.#ctor(System.Collections.Generic.IEnumerable{Xtensive.Core.Linq.Normalization.Conjunction{System.Linq.Expressions.Expression}})">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Linq.Normalization.DisjunctiveNormalized.ConjunctionOperandCount">
            <summary>
            Gets the total conjunction operand count.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.ExpressionReplacer">
            <summary>
            Replaces references to one specific instance of an expression node with another node
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionReplacer.Replace(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Replaces the specified expression.
            </summary>
            <param name="expression">The expression.</param>
            <param name="searchFor">The search for.</param>
            <param name="replaceWith">The replace with.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionReplacer.ReplaceAll(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[],System.Linq.Expressions.Expression[])">
            <summary>
            Replaces all specified expressions.
            </summary>
            <param name="expression">The expression.</param>
            <param name="searchFor">Expressions search for.</param>
            <param name="replaceWith">Expressions replace with.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionReplacer.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.MemberCompilerProviderFactory.Create(System.Type)">
            <summary>
            Creates new instance of <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider"/>.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.MemberCompilerProviderFactory.Create``1">
            <summary>
            Creates new instance of <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/>.
            </summary>
            <typeparam name="T">The type of value.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Linq.Normalization.DisjunctiveNormalizer">
            <summary>
            Transforms <see cref="T:System.Linq.Expressions.Expression"/> to disjunctive normal form.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalizer.Normalize(System.Linq.Expressions.Expression)">
            <summary>
            Transform the specified <paramref name="expression"/> to it disjunctive normal form.
            </summary>
            <param name="expression">The expression to transform.</param>
            <returns>Disjunctive normal representation of <paramref name="expression"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Actual conjunction operand count 
            greater than <see cref="P:Xtensive.Core.Linq.Normalization.DisjunctiveNormalizer.MaxConjunctionOperandCount"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalizer.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="maxConjunctionOperandCount">The maximal allowed conjunction operand count.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.Normalization.DisjunctiveNormalizer.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Linq.Normalization.DisjunctiveNormalizer.MaxConjunctionOperandCount">
            <summary>
            Gets or sets the maximal allowed conjunction operand count.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.ResourceHelper">
            <summary>
            Resources-related helper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.ResourceHelper.GetStringResource(System.Type,System.String)">
            <summary>
            Gets the string resource by specified resource type and resource name.
            </summary>
            <param name="resourceType">The resource type.</param>
            <param name="resourceName">The property name on the resource type.</param>
            <returns>String resource value.</returns>
        </member>
        <member name="T:Xtensive.Core.Reflection.SequenceHelper">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> helper methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.SequenceHelper.GetSequenceType(System.Type)">
            <summary>
            Gets the generic type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> where <paramref name="elementType"/> is generic argument.
            </summary>
            <param name="elementType">Type of the element.</param>
        </member>
        <member name="M:Xtensive.Core.Reflection.SequenceHelper.GetElementType(System.Type)">
            <summary>
            Gets element type of the sequence.
            </summary>
            <param name="sequenceType">Type of the sequence.</param>
        </member>
        <member name="T:Xtensive.Core.Security.AuthenticationService">
            <summary>
            An implementation of authentication service.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.IAuthenticationService">
            <summary>
            Authentication service.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.IAuthenticationService.Authenticate(System.String,System.String)">
            <summary>
            Authenticates the specified user.
            </summary>
            <param name="userName">Name of the user.</param>
            <param name="password">The password.</param>
            <returns>
            Signed (and normally, encrypted) security token;
            <see langword="null"/>, if authentication has failed.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Security.AuthenticationService.Authenticate(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.AuthenticationService.#ctor(Xtensive.Core.Security.IAuthenticationProvider,Xtensive.Core.Security.ISecurityTokenProvider,Xtensive.Core.Security.ISignatureProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="authenticationProvider">The authentication provider.</param>
            <param name="securityTokenProvider">The security token provider.</param>
            <param name="signatureProvider">The signature provider.</param>
        </member>
        <member name="M:Xtensive.Core.Security.AuthenticationService.#ctor(System.Func{System.String,System.String,System.Boolean},System.Func{System.String,System.String,System.String},Xtensive.Core.Security.ISignatureProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="authenticateHandler">The <see cref="M:Xtensive.Core.Security.IAuthenticationProvider.Authenticate(System.String,System.String)"/> handler.</param>
            <param name="getSecurityTokenHandler">The <see cref="M:Xtensive.Core.Security.ISecurityTokenProvider.GetSecurityToken(System.String,System.String)"/> handler.</param>
            <param name="signatureProvider">The signature provider.</param>
        </member>
        <member name="M:Xtensive.Core.Security.AuthenticationService.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.AuthenticationService.AuthenticationProvider">
            <summary>
            Gets or sets the underlying authentication provider.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.AuthenticationService.SecurityTokenProvider">
            <summary>
            Gets or sets the underlying security token provider.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.AuthenticationService.SignatureProvider">
            <summary>
            Gets or sets the underlying signature provider.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.CachingSignatureProvider">
            <summary>
            Caching signature provider: caches decrypted signatures
            to improve performance of signature checks.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.ISignatureProvider">
            <summary>
            Digital signature provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.ISignatureProvider.AddSignature(System.String)">
            <summary>
            Signs (and normally, encrypts) the specified token.
            </summary>
            <param name="token">The token to sign;
            it can't be <see langword="null" /> or an empty string.</param>
            <returns>Signed (and possibly, encrypted) token.</returns>
        </member>
        <member name="M:Xtensive.Core.Security.ISignatureProvider.RemoveSignature(System.String)">
            <summary>
            Checks the specified signed token.
            </summary>
            <param name="signedToken">The signed token to check.</param>
            <returns>Original (decrypted) token, if check has been passed;
            otherwise, <see langword="null" />.</returns>
        </member>
        <member name="M:Xtensive.Core.Security.CachingSignatureProvider.AddSignature(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.CachingSignatureProvider.RemoveSignature(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.CachingSignatureProvider.Initialize">
            <summary>
            Initializes this instance (creates <see cref="P:Xtensive.Core.Security.CachingSignatureProvider.Cache"/> object).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.CachingSignatureProvider.#ctor(System.Int32,Xtensive.Core.Security.ISignatureProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="cacheSize">Size of the <see cref="P:Xtensive.Core.Security.CachingSignatureProvider.Cache"/>.</param>
            <param name="signatureProvider">The underlying signature provider.</param>
        </member>
        <member name="M:Xtensive.Core.Security.CachingSignatureProvider.OnDeserialization(System.Object)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Security.CachingSignatureProvider.CacheSize">
            <summary>
            Gets the <see cref="P:Xtensive.Core.Security.CachingSignatureProvider.Cache"/> capacity.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.CachingSignatureProvider.Cache">
            <summary>
            Gets the cache.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.CachingSignatureProvider.SignatureProvider">
            <summary>
            Gets the underlying signature provider.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.CryptoSignatureProvider">
            <summary>
            Implementation of encrypting signature provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.CryptoSignatureProvider.AddSignature(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.CryptoSignatureProvider.RemoveSignature(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.CryptoSignatureProvider.Encrypt(System.String)">
            <summary>
            Encrypts the specified value.
            </summary>
            <param name="value">The value to encrypt.</param>
            <returns>Encrypted value.</returns>
        </member>
        <member name="M:Xtensive.Core.Security.CryptoSignatureProvider.Decrypt(System.String)">
            <summary>
            Decrypts the specified value.
            </summary>
            <param name="value">The value to decrypt.</param>
            <returns>Decrypted value.</returns>
        </member>
        <member name="M:Xtensive.Core.Security.CryptoSignatureProvider.#ctor(System.Func{System.Security.Cryptography.ICryptoTransform},System.Func{System.Security.Cryptography.ICryptoTransform},Xtensive.Core.Security.ISignatureProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="encryptorConstructor">The encryptor constructor delegate.</param>
            <param name="decryptorConstructor">The decryptor constructor delegate.</param>
            <param name="signatureProvider">The signature provider to use.</param>
        </member>
        <member name="M:Xtensive.Core.Security.CryptoSignatureProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.CryptoSignatureProvider.Encoding">
            <summary>
            Gets or sets the encoding.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.CryptoSignatureProvider.SignatureProvider">
            <summary>
            Gets or sets the signature provider to use.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.CryptoSignatureProvider.EncryptorConstructor">
            <summary>
            Gets or sets the encryptor constructor delegate.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.CryptoSignatureProvider.DecryptorConstructor">
            <summary>
            Gets or sets the decryptor constructor.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.DelegateAuthenticationProvider">
            <summary>
            Delegate-based authentication provider.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.IAuthenticationProvider">
            <summary>
            Underlying authentication provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.IAuthenticationProvider.Authenticate(System.String,System.String)">
            <summary>
            Authenticates the specified user.
            </summary>
            <param name="userName">Name of the user.</param>
            <param name="password">The password.</param>
            <returns>
            Insecure session token;
            <see langword="null"/>, if authentication has failed.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Security.DelegateAuthenticationProvider.Authenticate(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.DelegateAuthenticationProvider.#ctor(System.Func{System.String,System.String,System.Boolean})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="authenticate">The <see cref="M:Xtensive.Core.Security.DelegateAuthenticationProvider.Authenticate(System.String,System.String)"/> handler.</param>
        </member>
        <member name="T:Xtensive.Core.Security.DelegateSecurityTokenProvider">
            <summary>
            Delegate-based security token provider.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Security.ISecurityTokenProvider">
            <summary>
            Security token provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.ISecurityTokenProvider.GetSecurityToken(System.String,System.String)">
            <summary>
            Gets the security token.
            </summary>
            <param name="userName">Name of the user.</param>
            <param name="options">The additional options.</param>
            <returns>Security token for the specified user and options.</returns>
        </member>
        <member name="M:Xtensive.Core.Security.DelegateSecurityTokenProvider.GetSecurityToken(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.DelegateSecurityTokenProvider.#ctor(System.Func{System.String,System.String,System.String})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="getSecurityToken">The <see cref="M:Xtensive.Core.Security.DelegateSecurityTokenProvider.GetSecurityToken(System.String,System.String)"/> handler.</param>
        </member>
        <member name="T:Xtensive.Core.Security.HashingSignatureProvider">
            <summary>
            Implementation of hashing signature provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.HashingSignatureProvider.AddSignature(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.HashingSignatureProvider.RemoveSignature(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Security.HashingSignatureProvider.#ctor(System.Func{System.Security.Cryptography.HashAlgorithm})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="hasherConstructor">The <see cref="P:Xtensive.Core.Security.HashingSignatureProvider.Hasher"/> constructor delegate.</param>
        </member>
        <member name="M:Xtensive.Core.Security.HashingSignatureProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Security.HashingSignatureProvider.OnDeserialization(System.Object)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Security.HashingSignatureProvider.HasherConstructor">
            <summary>
            Gets or sets the hasher constructor delegate.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.HashingSignatureProvider.Hasher">
            <summary>
            Gets the hasher.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.HashingSignatureProvider.Encoding">
            <summary>
            Gets or sets the encoding.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.HashingSignatureProvider.Escape">
            <summary>
            Gets or sets the escape character.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Security.HashingSignatureProvider.Delimiter">
            <summary>
            Gets or sets the delimiter character.
            </summary>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1">
            <summary>
            Base class for any <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/> implementor.
            </summary>
            <typeparam name="T">Type to calculate the size for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1">
            <summary>
            Calculates the size of instances of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to calculate the size for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.ISizeCalculatorBase">
            <summary>
            Base interface for any size calculator supported by
            <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculatorProvider"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculatorBase.GetDefaultSize">
            <summary>
            Gets the default (minimal) size (the size of <see langword="default(T)"/>) 
            for the type handled by this size calculator.
            </summary>
            <returns>Default (minimal) size (the size of <see langword="default(T)"/> in bytes) 
            for the type handled by this size calculator.</returns>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculatorBase.GetInstanceSize(System.Object)">
            <summary>
            Gets the size of the specified <paramref name="instance"/>.
            </summary>
            <param name="instance">Instance to get the size for.</param>
            <returns>Size (in bytes) of the specified <paramref name="instance"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.SizeCalculators.ISizeCalculatorBase.Provider">
            <summary>
            Gets the provider this size calculator is associated with.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculator`1.GetValueSize(`0)">
            <summary>
            Gets the size of the specified <paramref name="value"/> of type <typeparamref name="T"/>.
            </summary>
            <param name="value">Value to get the size for.</param>
            <returns>Size (in bytes) of specified <paramref name="value"/>.</returns>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.IsStruct">
            <summary>
            Indicates whether <typeparamref name="T"/> is a value type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.IsClass">
            <summary>
            Indicates whether <typeparamref name="T"/> is a reference type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.GetDefaultSize">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.GetValueSize(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.Xtensive#Core#SizeCalculators#ISizeCalculatorBase#GetInstanceSize(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.GetPackedStructSize(System.Int32)">
            <summary>
            Gets packed struct size (actual size) for the struct of specified unpacked size.
            </summary>
            <param name="minimalStructSize">Pre-calculated minimal struct size.</param>
            <returns>Actual struct size.</returns>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.#ctor(Xtensive.Core.SizeCalculators.ISizeCalculatorProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">The provider this size calculator is bound to.</param>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.Provider">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.SizeCalculators.SizeCalculatorBase`1.DefaultSize">
            <summary>
            Gets the size of default instance of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Sorting.ConnectionType">
            <summary>
            Type of <see cref="T:Xtensive.Core.Sorting.NodeConnection`2"/> connection.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Sorting.ConnectionType.Breakable">
            <summary>
            Connection may be breaked by topological sorter.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Sorting.ConnectionType.Permanent">
            <summary>
            Connection cannot be breaked by topological sorter.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Sorting.Node`2">
            <summary>
            Sorting node. 
            </summary>
            <typeparam name="TNodeItem">Type of node item.</typeparam>
            <typeparam name="TConnectionItem">Type of connection item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Sorting.Node`2.AddConnection(Xtensive.Core.Sorting.Node{`0,`1},`1)">
            <summary>
            Adds new outgoing connection to node.
            </summary>
            <param name="node">Paired node.</param>
            <param name="connectionItem">Item of connection.</param>
        </member>
        <member name="M:Xtensive.Core.Sorting.Node`2.AddConnection(Xtensive.Core.Sorting.Node{`0,`1},`1,Xtensive.Core.Sorting.ConnectionType)">
            <summary>
            Adds new outgoing connection to node.
            </summary>
            <param name="node">Paired node.</param>
            <param name="connectionItem">Item of connection.</param>
            <param name="connectionType">Type of connection.</param>
        </member>
        <member name="M:Xtensive.Core.Sorting.Node`2.RemoveConnections(Xtensive.Core.Sorting.Node{`0,`1})">
            <summary>
            Removes outgoing connections from node.
            </summary>
            <param name="destination">Paired node.</param>
        </member>
        <member name="M:Xtensive.Core.Sorting.Node`2.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.Item">
            <summary>
            Gets node item.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.IncomingConnections">
            <summary>
            Gets <see cref="T:System.Collections.Generic.HashSet`1"/> of incoming connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.OutgoingConnections">
            <summary>
            Gets <see cref="T:System.Collections.Generic.HashSet`1"/> of outgoing connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.OutgoingConnectionCount">
            <summary>
            Gets count of outgoing connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.BreakableOutgoingConnectionCount">
            <summary>
            Gets count of breakable outgoing connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.PermanentOutgoingConnectionCount">
            <summary>
            Gets count of permanent outgoing connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.BreakableIncomingConnectionCount">
            <summary>
            Gets count of breakable incoming connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.IncomingConnectionCount">
            <summary>
            Gets count of breakable incoming connections.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.Node`2.PermanentIncomingConnectionCount">
            <summary>
            Gets count of permanent incoming connections.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Sorting.NodeConnection`2">
            <summary>
            Connection between two <see cref="T:Xtensive.Core.Sorting.Node`2"/>s.
            </summary>
            <typeparam name="TNodeItem">Type of node item.</typeparam>
            <typeparam name="TConnectionItem">Type of connection item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Sorting.NodeConnection`2.#ctor(Xtensive.Core.Sorting.Node{`0,`1},Xtensive.Core.Sorting.Node{`0,`1},`1)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The source.</param>
            <param name="destination">The destination.</param>
            <param name="connectionItem">The connection item.</param>
        </member>
        <member name="M:Xtensive.Core.Sorting.NodeConnection`2.#ctor(Xtensive.Core.Sorting.Node{`0,`1},Xtensive.Core.Sorting.Node{`0,`1},`1,Xtensive.Core.Sorting.ConnectionType)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The source.</param>
            <param name="destination">The destination.</param>
            <param name="connectionItem">The connection item.</param>
            <param name="connectionType">Connection type.</param>
        </member>
        <member name="P:Xtensive.Core.Sorting.NodeConnection`2.ConnectionItem">
            <summary>
            Gets connection item.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.NodeConnection`2.Source">
            <summary>
            Gets connection source.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.NodeConnection`2.Destination">
            <summary>
            Gets connection destination.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Sorting.NodeConnection`2.ConnectionType">
            <summary>
            Gets connection type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Sorting.TopologicalSorter">
            <summary>
            Topological sorter for oriented graph of the items.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``1(System.Collections.Generic.IEnumerable{``0},Xtensive.Core.Predicate{``0,``0})">
            <summary>
            Sorts the specified oriented graph of the items in their topological order
            (following the outgoing connections provided by <paramref name="connector"/>).
            </summary>
            <param name="items">The items to sort.</param>
            <param name="connector">The connector delegate returning <see langword="true" />
            if there is outgoing connection between the first and the second node.</param>
            <returns>
            Sorting result, if there were no loops;
            otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``1(System.Collections.Generic.IEnumerable{``0},Xtensive.Core.Predicate{``0,``0},System.Collections.Generic.List{Xtensive.Core.Sorting.Node{``0,System.Object}}@)">
            <summary>
            Sorts the specified oriented graph of the items in their topological order
            (following the outgoing connections provided by <paramref name="connector"/>).
            </summary>
            <param name="items">The items to sort.</param>
            <param name="connector">The connector delegate returning <see langword="true"/>
            if there is outgoing connection between the first and the second node.</param>
            <param name="loops">The loops, if found.</param>
            <returns>
            Sorting result, if there were no loops;
            otherwise, <see langword="null"/>.
            In this case <paramref name="loops"/> will contain only the loop edges.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``1(System.Collections.Generic.IEnumerable{``0},Xtensive.Core.Predicate{``0,``0},System.Collections.Generic.List{Xtensive.Core.Sorting.NodeConnection{``0,System.Object}}@)">
            <summary>
            Sorts the specified oriented graph of the items in their topological order
            (following the outgoing connections provided by <paramref name="connector"/>).
            </summary>
            <param name="items">The items to sort.</param>
            <param name="connector">The connector delegate returning <see langword="true"/>
            if there is outgoing connection between the first and the second node.</param>
            <param name="removedEdges">Edges removed to make graph non-cyclic.</param>
            <returns>
            Sorting result
            </returns>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``1(System.Collections.Generic.IEnumerable{``0},Xtensive.Core.Predicate{``0,``0},System.Collections.Generic.List{Xtensive.Core.Sorting.NodeConnection{``0,System.Object}}@,System.Boolean)">
            <summary>
            Sorts the specified oriented graph of the items in their topological order
            (following the outgoing connections provided by <paramref name="connector"/>).
            </summary>
            <param name="items">The items to sort.</param>
            <param name="connector">The connector delegate returning <see langword="true"/>
            if there is outgoing connection between the first and the second node.</param>
            <param name="removedEdges">Edges removed to make graph non-cyclic.</param>
            <param name="removeWholeNode">If <see langword="true"/> removes whole node in the case of loop, otherwise removes only one edge.</param>
            <returns>
            Sorting result
            </returns>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``2(System.Collections.Generic.List{Xtensive.Core.Sorting.Node{``0,``1}},System.Collections.Generic.List{Xtensive.Core.Sorting.Node{``0,``1}}@)">
            <summary>
            Sorts the specified oriented graph of the nodes in their topological order
            (following the outgoing connections).
            </summary>
            <param name="nodes">The nodes.</param>
            <param name="loops">The loops, if found.</param>
            <returns>Sorting result, if there were no loops;
            otherwise, <see langword="null" />. 
            In this case <paramref name="nodes"/> will contain only the loop edges.</returns>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``2(System.Collections.Generic.IEnumerable{Xtensive.Core.Sorting.Node{``0,``1}},System.Collections.Generic.List{Xtensive.Core.Sorting.NodeConnection{``0,``1}}@)">
            <summary>
            Sorts the specified oriented graph of the nodes in their topological order
            (following the outgoing connections).
            </summary>
            <param name="nodes">The nodes.</param>
            <param name="removedEdges">Edges removed to make graph non-cyclic.</param>
            <returns>Sorting result.</returns>
        </member>
        <member name="M:Xtensive.Core.Sorting.TopologicalSorter.Sort``2(System.Collections.Generic.IEnumerable{Xtensive.Core.Sorting.Node{``0,``1}},System.Collections.Generic.List{Xtensive.Core.Sorting.NodeConnection{``0,``1}}@,System.Boolean)">
            <summary>
            Sorts the specified oriented graph of the nodes in their topological order
            (following the outgoing connections).
            </summary>
            <param name="nodes">The nodes.</param>
            <param name="removedEdges">Edges removed to make graph non-cyclic.</param>
            <param name="removeWholeNode">If <see langword="true"/> removes whole node in the case of loop, otherwise removes only one edge.</param>
            <returns>Sorting result.</returns>
        </member>
        <member name="T:Xtensive.Core.Configuration.ConfigurationSectionBase">
            <summary>
            Base class for <see cref="T:Xtensive.Core.IConfiguration"/> implementors with 
            support of reading from application configuration file.
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate"/></para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Lock">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Lock(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Unlock">
            <summary>
            Unlocks the object.
            Sets <see cref="P:Xtensive.Core.Configuration.ConfigurationSectionBase.IsLocked"/> to <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Validate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.CreateClone">
            <summary>
            Creates a new instance of this class.
            Used by <see cref="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Clone"/> method implementation.
            </summary>
            <returns>New instance of this class.</returns>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Clone(Xtensive.Core.Configuration.ConfigurationSectionBase)">
            <summary>
            Copies the properties from the <paramref name="source"/>
            configuration to this one.
            Used by <see cref="M:Xtensive.Core.Configuration.ConfigurationSectionBase.Clone"/> method implementation.
            </summary>
            <param name="source">The configuration to copy properties from.</param>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurationSectionBase.IsLocked">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.StringBuilderExtensions">
            <summary>
            <see cref="T:System.Text.StringBuilder"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.StringBuilderExtensions.AppendIndented(System.Text.StringBuilder,System.Int32,System.String)">
            <summary>
            Appends the specified <see cref="T:System.String"/> indented by specified count of spaces.
            </summary>
            <param name="builder">The builder to write indented string to.</param>
            <param name="indent">Count of spaces to indent.</param>
            <param name="value">The string value to write.</param>    
            <returns>
            A reference to the <paramref name="builder"/> after append operation has completed.
            </returns>
        </member>
        <member name="M:Xtensive.Core.StringBuilderExtensions.AppendIndented(System.Text.StringBuilder,System.Int32,System.String,System.Boolean)">
            <summary>
            Appends the specified <see cref="T:System.String"/> indented by specified count of spaces.
            </summary>
            <param name="builder">The builder to write indented string to.</param>
            <param name="indent">Count of spaces to indent.</param>
            <param name="value">The string value to write.</param>
            <param name="indentFirstLine">if set to <see langword="true"/> first line of string will be indented, otherwise not.</param>
            <returns>
            A reference to the <paramref name="builder"/> after append operation has completed.
            </returns>
        </member>
        <member name="M:Xtensive.Core.StringBuilderExtensions.AppendHexArray(System.Text.StringBuilder,System.Byte[])">
            <summary>
            Appends the specified <see cref="T:System.Byte"/> array in hexidecimal representation.
            These bytes are written from left to right, high part of byte is written first.
            For example {1,2,10} will be appended as 01020A.
            </summary>
            <param name="builder">The builder.</param>
            <param name="values">The values.</param>
        </member>
        <member name="T:Xtensive.Core.IO.StreamSegment">
            <summary>
            Exposes a <see cref="P:Xtensive.Core.IO.StreamSegment.Segment"/> of the specified <see cref="P:Xtensive.Core.IO.StreamSegment.Stream"/> 
            as the independent stream.
            </summary>
            <remarks>
            Any read and write operations on this instance affect on
            <see cref="P:System.IO.Stream.Position"/> of the underlying <see cref="P:Xtensive.Core.IO.StreamSegment.Stream"/>.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
            <exception cref="T:System.ArgumentOutOfRangeException">Either <paramref name="offset"/> or 
            <paramref name="origin"/> is out of range.</exception>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.ReadByte">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.#ctor(System.IO.Stream,Xtensive.Core.Segment{System.Int64})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="stream">The <see cref="P:Xtensive.Core.IO.StreamSegment.Stream"/> to wrap.</param>
            <param name="segment">The <see cref="P:Xtensive.Core.IO.StreamSegment.Segment"/> to expose.</param>
        </member>
        <member name="M:Xtensive.Core.IO.StreamSegment.#ctor(System.IO.Stream,Xtensive.Core.Segment{System.Int64},System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="stream">The <see cref="P:Xtensive.Core.IO.StreamSegment.Stream"/> to wrap.</param>
            <param name="segment">The <see cref="P:Xtensive.Core.IO.StreamSegment.Segment"/> to expose.</param>
            <param name="stripStreamSegments">Indicates whether all <see cref="T:Xtensive.Core.IO.StreamSegment"/>s
            must be stripped from the <paramref name="stream"/>.</param>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.Stream">
            <summary>
            Gets the stream wrapped by this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.Segment">
            <summary>
            Gets or sets the segment exposed by this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.Position">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.Length">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.IO.StreamSegment.CanWrite">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Disposing.IDisposableContainer">
            <summary>
            Defines a <see cref="P:Xtensive.Core.Disposing.IDisposableContainer.DisposingState"/> property for <see cref="T:System.IDisposable"/> implementors.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Disposing.IDisposableContainer.DisposingState">
            <summary>
            Gets the state of the disposing.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.INamedValueCollection">
            <summary>
            Named value collection contract.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.INamedValueCollection.Get(System.String)">
            <summary>
            Gets the specified value by its name.
            </summary>
            <param name="name">The name of the value.</param>
            <returns>
            Specified value, if found;
            otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Collections.INamedValueCollection.Set(System.String,System.Object)">
            <summary>
            Sets the value of the specified name.
            </summary>
            <param name="name">The name to set the value of.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.NamedValueCollection">
            <summary>
            <see cref="T:System.Collections.Generic.Dictionary`2"/>-based 
            <see cref="T:Xtensive.Core.Collections.INamedValueCollection"/> implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.NamedValueCollection.Get(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.NamedValueCollection.Set(System.String,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Linq.CompilerAttribute">
            <summary>
            Attribute for specifying method which acts as compiler
            for desired <see cref="P:Xtensive.Core.Linq.CompilerAttribute.TargetMember"/> of <see cref="P:Xtensive.Core.Linq.CompilerAttribute.TargetType"/>.
            <see cref="T:Xtensive.Core.Linq.MemberCompilerProvider`1"/> scans for this attributes
            via <see cref="M:Xtensive.Core.Linq.MemberCompilerProvider`1.RegisterCompilers(System.Type)"/>  method and registers them.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.CompilerAttribute.#ctor(System.Type,System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="targetMember">The target method.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.CompilerAttribute.#ctor(System.Type,System.String,Xtensive.Core.Linq.TargetKind)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="targetMember">The target member.</param>
            <param name="targetKind">Kind of the target.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.CompilerAttribute.#ctor(System.Type,System.String,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="targetMember">The target member.</param>
            <param name="numberOfGenericArguments">The generic params count.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.CompilerAttribute.#ctor(System.Type,System.String,Xtensive.Core.Linq.TargetKind,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="targetType">Type of the target.</param>
            <param name="targetMember">The target member.</param>
            <param name="targetKind">Kind of the target.</param>
            <param name="numberOfGenericArguments">The generic params count.</param>
        </member>
        <member name="P:Xtensive.Core.Linq.CompilerAttribute.TargetType">
            <summary>
            Gets or sets the type of the target.
            The type should be either non-generic type or open generic type.
            </summary>
            <value>The type of the target.</value>
        </member>
        <member name="P:Xtensive.Core.Linq.CompilerAttribute.TargetMember">
            <summary>
            Gets or sets the target member.
            </summary>
            <value>The target member.</value>
        </member>
        <member name="P:Xtensive.Core.Linq.CompilerAttribute.TargetKind">
            <summary>
            Gets or sets the kind of the target.
            </summary>
            <value>The kind of the target.</value>
        </member>
        <member name="P:Xtensive.Core.Linq.CompilerAttribute.NumberOfGenericArguments">
            <summary>
            Gets or sets the generic params count.
            This affects only generic methods not generic types.
            </summary>
            <value>The generic params count.</value>
        </member>
        <member name="T:Xtensive.Core.Linq.TypeAttribute">
            <summary>
            Attribute for specifying parameter types of compiled method.
            See <see cref="T:Xtensive.Core.Linq.CompilerAttribute"/> for details.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.TypeAttribute.#ctor(System.Type)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="P:Xtensive.Core.Linq.TypeAttribute.Value">
            <summary>
            Gets or sets the value.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.ConflictHandlingMethod">
            <summary>
            Possible ways of handling conflicts (i.e. multiple compilers for same method)
            for <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/> 
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ConflictHandlingMethod.ReportError">
            <summary>
            <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/> should throw exception if conflict is found.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ConflictHandlingMethod.KeepOld">
            <summary>
            <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/> should keep existing compiler for specified method.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ConflictHandlingMethod.Overwrite">
            <summary>
            <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/> should overwrite existing compiler with newly found compiler.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.ConflictHandlingMethod.Default">
            <summary>
            Default action for <see cref="T:Xtensive.Core.Linq.IMemberCompilerProvider`1"/> if conflict is found.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.QueryableMethodKind">
            <summary>
            Enumerates supported <see cref="T:System.Linq.IQueryable`1"/> methods.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.QueryableVisitor">
            <summary>
            Abstract base visitor that handles methods of <see cref="T:System.Linq.IQueryable"/> and <see cref="T:System.Collections.Generic.IEnumerable`1"/> by calling <see cref="M:Xtensive.Core.Linq.QueryableVisitor.VisitQueryableMethod(System.Linq.Expressions.MethodCallExpression,Xtensive.Core.Linq.QueryableMethodKind)"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.QueryableVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.QueryableVisitor.VisitQueryableMethod(System.Linq.Expressions.MethodCallExpression,Xtensive.Core.Linq.QueryableMethodKind)">
            <summary>
            Visits method of <see cref="T:System.Linq.IQueryable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="mc">The method call expression.</param>
            <param name="methodKind">Kind of the method.</param>
        </member>
        <member name="T:Xtensive.Core.Linq.TargetKind">
            <summary>
            Flags for specifying kind of compilable members.
            You should provide only one flag possibly OR'ed with <see cref="F:Xtensive.Core.Linq.TargetKind.Static"/> flag.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.PropertyGet">
            <summary>
            Compilable member is a property getter.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.PropertySet">
            <summary>
            Compilable member is as property setter.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.Field">
            <summary>
            Compilable member is a field (compiler translates read access).
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.Method">
            <summary>
            Compilable member is a regular method.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.Constructor">
            <summary>
            Compilable member is a constuctor.
            You should NOT specify <see cref="F:Xtensive.Core.Linq.TargetKind.Static"/> flag with this flag.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.Static">
            <summary>
            Compilable member is <see langword="static"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Linq.TargetKind.Operator">
            <summary>
            Compilable member is an overloaded operator.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Linq.ExpressionWriter">
            <summary>
            Writes out an expression tree in a C#-ish syntax.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.Write(System.IO.TextWriter,System.Linq.Expressions.Expression)">
            <summary>
            Writes the expression to the specified writer.
            </summary>
            <param name="writer">The writer to use.</param>
            <param name="expression">The expression to write.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.Write(System.Linq.Expressions.Expression)">
            <summary>
            Writes the expression to string.
            </summary>
            <param name="expression">The expression to write.</param>
            <returns>The string containing written expression.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.WriteLine(Xtensive.Core.Linq.ExpressionWriter.IndentType)">
            <summary>
            Writes the line break.
            </summary>
            <param name="indentType">Type of the indent to use for the further lines.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.Write(System.String)">
            <summary>
            Writes the specified text.
            </summary>
            <param name="text">The text to write.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.WriteArguments(System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression},System.String)">
            <summary>
            Writes the list of arguments.
            </summary>
            <param name="prefix">The prefix.</param>
            <param name="arguments">The arguments.</param>
            <param name="suffix">The suffix.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.ChangeIndent(Xtensive.Core.Linq.ExpressionWriter.IndentType)">
            <summary>
            Changes the indent.
            </summary>
            <param name="indentType">New type of the indent.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.GetOperator(System.Linq.Expressions.ExpressionType)">
            <summary>
            Gets the C# operator for the specified expression type.
            </summary>
            <param name="type">The type of expression to get the operator for.</param>
            <returns>The C# operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.GetTypeName(System.Type)">
            <summary>
            Gets the name of the type.
            </summary>
            <param name="type">The type to get the name for.</param>
            <returns>The name of the type.</returns>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitBindingList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.MemberBinding})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitElementInitializerList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ElementInit})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitExpressionList(System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.Expression})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.VisitUnknown(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.#ctor(System.IO.TextWriter)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:Xtensive.Core.Linq.ExpressionWriter.#ctor(System.IO.TextWriter,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="writer">The writer to write to.</param>
            <param name="indentSize">Size of the indent to use.</param>
        </member>
        <member name="P:Xtensive.Core.Linq.ExpressionWriter.Writer">
            <summary>
            Gets the writer used by the instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Linq.ExpressionWriter.IndentSize">
            <summary>
            Gets the size of the indent.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Helpers.AliasGenerator">
            <summary>
            Universal alias generator.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Helpers.AliasGenerator.DefaultAliasTemplate">
            <summary>
            Default alias template. Value is "{0}{1}". Where {0} - template parameter for prefix and {1} - template parameter for suffix.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.AliasGenerator.Next">
            <summary>
            Generates new alias.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.AliasGenerator.Create">
            <summary>
            Creates generator with default settings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Helpers.AliasGenerator.Create(System.String)">
            <summary>
            Creates generator using specified alias template.
            </summary>
            <param name="aliasTemplate">Alias template. Could use two template parameters: {0} - for prefix and {1} for suffix.</param>
        </member>
        <member name="M:Xtensive.Core.Helpers.AliasGenerator.Create(System.String[])">
            <summary>
            Creates generator using specified prefix sequence.
            </summary>
            <param name="overriddenPrefixes">The overridden prefix sequence.</param>
        </member>
        <member name="M:Xtensive.Core.Helpers.AliasGenerator.Create(System.String[],System.String)">
            <summary>
            Creates generator using specified <paramref name="overriddenPrefixes"/> and <paramref name="aliasTemplate"/>.
            </summary>
            <param name="overriddenPrefixes">The overridden prefix sequence.</param>
            <param name="aliasTemplate">The alias template.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.BindingCollection`2">
            <summary>
            Temporarily binds values of type <typeparamref name="TValue"/> to their keys
            and provides access to currently bound values.
            Any binding is active while its binding result (<see cref="T:System.IDisposable"/> object)
            isn't disposed.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.Add(`0,`1)">
            <summary>
            Binds the specified <paramref name="value"/> to <paramref name="key"/>.
            </summary>
            <param name="key">The key to bind to.</param>
            <param name="value">The value to bind.</param>
            <returns>Disposable object that will 
            destroy the binding on its disposal.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.PermanentAdd(`0,`1)">
            <summary>
            Binds the specified <paramref name="value"/> to <paramref name="key"/>.
            </summary>
            <param name="key">The key to bind to.</param>
            <param name="value">The value to bind.</param>
            <returns><see langword="null" />, so this binding will not be removed.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.ReplaceBound(`0,`1)">
            <summary>
            Replaces previously bound value.
            </summary>
            <param name="key">The binding key of the value to replace.</param>
            <param name="value">The new value.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Key isn't found.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the bound value by its key.
            </summary>
            <param name="key">The key of the value to get.</param>
            <param name="value">When this method returns,
            contains the value bound to the specified key, if the key is found;
            otherwise, default value for the type of the value parameter.</param>
            <returns><see langword="True"/> if the <see cref="T:Xtensive.Core.Collections.BindingCollection`2"/> 
            contains an element with the specified key;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.GetKeys">
            <summary>
            Gets the sequence of bound keys.
            </summary>
            <returns>The sequence of bound keys.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.BindingCollection`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.BindingCollection`2.Count">
            <summary>
            Gets the number of currently bound items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.BindingCollection`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.BindingCollection`2.Item(`0)">
            <summary>
            Gets the bound value by its key.
            </summary>
            <value></value>
        </member>
        <member name="T:Xtensive.Core.Parameters.Parameter`1">
            <summary>
            Parameter - an object identifying its value in active <see cref="T:Xtensive.Core.Parameters.ParameterContext"/>.
            </summary>
            <typeparam name="TValue">The type of parameter value.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Parameters.Parameter">
            <summary>
            Parameter - an object identifying its value in active <see cref="T:Xtensive.Core.Parameters.ParameterContext"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Parameters.Parameter.IsExpectedValueSet">
            <summary>
            Indicates whether the property <see cref="P:Xtensive.Core.Parameters.Parameter.ExpectedValue"/> is set.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.GetValue">
            <summary>
            Gets the value of the parameter.
            </summary>
            <returns>Parameter value.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="T:Xtensive.Core.Parameters.ParameterContext"/> is not activated.</exception>
            <exception cref="T:System.InvalidOperationException">Value for the parameter is not set.</exception>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.SetValue(System.Object)">
            <summary>
            Sets the value of the parameter.
            </summary>
            <param name="value">The new value.</param>
            <exception cref="T:System.InvalidOperationException"><see cref="T:Xtensive.Core.Parameters.ParameterContext"/> is not activated.</exception>    
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.Clear">
            <summary>
            Clears parameter's value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.OnScopeDisposed(System.Object)">
            <summary>
            Called on leaving the scope.
            </summary>
            <param name="parameterScopeValue">The parameter scope value.</param>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.GetCurrentScope">
            <exception cref="T:System.Exception"><see cref="T:Xtensive.Core.Parameters.ParameterContext"/> is required.</exception>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.#ctor(System.String,System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The <see cref="P:Xtensive.Core.Parameters.Parameter.Name"/> property value.</param>
            <param name="expectedValue">The expected value of this parameter.</param>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The <see cref="P:Xtensive.Core.Parameters.Parameter.Name"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Parameters.Parameter.Name">
            <summary>
            Gets or sets the parameter name.
            </summary>    
        </member>
        <member name="P:Xtensive.Core.Parameters.Parameter.Value">
            <summary>
            Gets or sets the value of the parameter.
            </summary>
            <exception cref="T:System.InvalidOperationException"><see cref="T:Xtensive.Core.Parameters.ParameterContext"/> is not activated.</exception>
            <exception cref="T:System.InvalidOperationException">Value for the parameter is not set.</exception>
        </member>
        <member name="P:Xtensive.Core.Parameters.Parameter.ExpectedValue">
            <summary>
            Gets the expected value of the parameter.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Parameters.Parameter.HasValue">
            <summary>
            Gets a value indicating whether this instance has value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="expectedValue">The expected value of this parameter.</param>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor(System.String,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor(System.Action{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="onOutOfScope">Out of scope action. 
            Action argument is parameter's value within disposed scope.</param>
        </member>
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor(System.Action{`0},`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="onOutOfScope">Out of scope action. 
            Action argument is parameter's value within disposed scope.</param>
            <param name="expectedValue">The expected value of this parameter.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Parameters.Parameter`1.#ctor(System.String,System.Action{`0})" -->
        <member name="M:Xtensive.Core.Parameters.Parameter`1.#ctor(System.String,System.Action{`0},`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The <see cref="P:Xtensive.Core.Parameters.Parameter.Name"/> property value.</param>
            <param name="onOutOfScope">Out of scope action. 
            Action argument is parameter's value within disposed scope.</param>
            <param name="expectedValue">The expected value of this parameter.</param>
        </member>
        <member name="P:Xtensive.Core.Parameters.Parameter`1.Value">
            <summary>
            Gets or sets the parameter value.
            </summary>    
            <exception cref="T:System.InvalidOperationException"><see cref="T:Xtensive.Core.Parameters.ParameterContext"/> is not activated.</exception>
            <exception cref="T:System.InvalidOperationException">Value for the parameter is not set.</exception>
        </member>
        <member name="T:Xtensive.Core.Parameters.ParameterContext">
            <summary>
            Provides storing context-specific <see cref="T:Xtensive.Core.Parameters.Parameter`1"/>'s values.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IoC.Context`1">
            <summary>
            Base <see cref="T:Xtensive.Core.IoC.IContext`1"/> implementation.
            To be used with various <see cref="T:Xtensive.Core.IoC.Scope`1"/> descendants.
            </summary>
            <typeparam name="TScope">The type of the associated scope.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IoC.Context`1.Xtensive#Core#IoC#IContext#Activate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IoC.Context`1.Activate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.IoC.Context`1.CreateActiveScope">
            <summary>
            Creates the associated scope.
            </summary>
            <returns>New instance of the <typeparamref name="TScope"/> type.</returns>
        </member>
        <member name="P:Xtensive.Core.IoC.Context`1.IsActive">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterContext.CreateActiveScope">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterContext.EnsureIsRegular">
            <exception cref="T:System.InvalidOperationException">Context is <see cref="P:Xtensive.Core.Parameters.ParameterContext.ExpectedValues"/> context.</exception>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterContext.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Parameters.ParameterContext.Current">
            <summary>
            Gets the current <see cref="T:Xtensive.Core.Parameters.ParameterContext"/>.
            </summary>        
        </member>
        <member name="P:Xtensive.Core.Parameters.ParameterContext.ExpectedValues">
            <summary>
            Gets the special singleton <see cref="T:Xtensive.Core.Parameters.ParameterContext"/> instance 
            returning <see cref="P:Xtensive.Core.Parameters.Parameter.ExpectedValue"/> instead of <see cref="P:Xtensive.Core.Parameters.Parameter.Value"/> 
            if <see cref="P:Xtensive.Core.Parameters.Parameter.ExpectedValue"/> is set.
            </summary>        
        </member>
        <member name="P:Xtensive.Core.Parameters.ParameterContext.IsActive">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Parameters.ParameterScope">
            <summary>
            <see cref="T:Xtensive.Core.Parameters.ParameterContext"/> activation scope.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterScope.GetValue(Xtensive.Core.Parameters.Parameter)">
            <exception cref="T:System.InvalidOperationException"><c>InvalidOperationException</c>.</exception>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterScope.#ctor(Xtensive.Core.Parameters.ParameterContext)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="context">The context of this scope.</param>
        </member>
        <member name="M:Xtensive.Core.Parameters.ParameterScope.System#IDisposable#Dispose">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Parameters.ParameterScope.CurrentContext">
            <summary>
            Gets the current context.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Parameters.ParameterScope.Context">
            <summary>
            Gets the associated parameter context.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.AttributeSearchOptions">
            <summary>
            Search options for <see cref="T:Xtensive.Core.Reflection.AttributeHelper"/> methods.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.AttributeSearchOptions.Default">
            <summary>
            Default options.
            The same as <see cref="F:Xtensive.Core.Reflection.AttributeSearchOptions.InheritNone"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.AttributeSearchOptions.InheritNone">
            <summary>
            Nothing should be inherited.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.AttributeSearchOptions.InheritFromBase">
            <summary>
            If no attributes are found on the specified member,
            attributes from its base should be inherited.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.AttributeSearchOptions.InheritFromAllBase">
            <summary>
            Attributes from all the bases should be inherited.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.AttributeSearchOptions.InheritFromPropertyOrEvent">
            <summary>
            If no attributes are found on the specified method,
            attributes from the property or event it belongs to should be inherited.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.AttributeSearchOptions.InheritAll">
            <summary>
            All inheritance options.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.WellKnown">
            <summary>
            Various well-known constants related to this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.CtorName">
            <summary>
            Returns ".ctor".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.CctorName">
            <summary>
            Returns ".cctor".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.GetterPrefix">
            <summary>
            Returns "get_".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.SetterPrefix">
            <summary>
            Returns "set_".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.IndexerPropertyName">
            <summary>
            Returns "Item"
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.AddEventHandlerPrefix">
            <summary>
            Returns "add_".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.RemoveEventHandlerPrefix">
            <summary>
            Returns "remove_".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.RuntimeMethodInfoName">
            <summary>
            Returns "System.Reflection.RuntimeMethodInfo".
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.WellKnown.Object">
            <summary>
             Various well-known constants related to <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Object.Clone">
            <summary>
            Returns "Clone".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Object.Equals">
            <summary>
            Returns "Equals".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Object.GetHashCode">
            <summary>
            Returns "GetHashCode".
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.WellKnown.Operator">
            <summary>
             Well-known method names related to operator overloading
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Addition">
            <summary>
            Returns "op_Addition".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Subtraction">
            <summary>
            Returns "op_Subtraction".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Multiply">
            <summary>
            Returns "op_Multiply".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Division">
            <summary>
            Returns "op_Division".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Modulus">
            <summary>
            Returns "op_Modulus".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Increment">
            <summary>
            Returns "op_Increment".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Decrement">
            <summary>
            Returns "op_Decrement".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.UnaryNegation">
            <summary>
            Returns "op_UnaryNegation".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.UnaryPlus">
            <summary>
            Returns "op_UnaryPlus".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.BitwiseOr">
            <summary>
            Returns "op_BitwiseOr".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.BitwiseAnd">
            <summary>
            Returns "op_BitwiseAnd".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.ExclusiveOr">
            <summary>
            Returns "op_ExclusiveOr".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.OnesComplement">
            <summary>
            Returns "op_OnesComplement".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.LeftShift">
            <summary>
            Returns "op_LeftShift"
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.RightShift">
            <summary>
            Returns "op_RightShift
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.LogicalNot">
            <summary>
            Returns "op_LogicalNot".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.True">
            <summary>
            Returns "op_True".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.False">
            <summary>
            Returns "op_False".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Explicit">
            <summary>
            Returns "op_Explicit"
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Implicit">
            <summary>
            Returns "op_Implicit".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Equality">
            <summary>
            Returns "op_Equality".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.Inequality">
            <summary>
            Returns "op_Inequality".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.GreaterThan">
            <summary>
            Returns "op_GreaterThan".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.GreaterThanOrEqual">
            <summary>
            Returns "op_GreaterThanOrEqual".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.LessThan">
            <summary>
            Returns "op_LessThan".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Operator.LessThanOrEqual">
            <summary>
            Returns "op_LessThanOrEqual".
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.WellKnown.Queryable">
            <summary>
             Various well-known constants related to <see cref="T:System.Linq.IQueryable`1"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Aggregate">
            <summary>
            Returns "Aggregate".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.All">
            <summary>
            Returns "All".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Any">
            <summary>
            Returns "Any".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.AsEnumerable">
            <summary>
            Returns "AsEnumerable".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.AsQueryable">
            <summary>
            Returns "AsQueryable".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Average">
            <summary>
            Returns "Average".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Cast">
            <summary>
            Returns "Cast".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Concat">
            <summary>
            Returns "Concat".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Contains">
            <summary>
            Returns "All".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Count">
            <summary>
            Returns "Count".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.DefaultIfEmpty">
            <summary>
            Returns "DefaultIfEmpty".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Distinct">
            <summary>
            Returns "Distinct".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.ElementAt">
            <summary>
            Returns "ElementAt".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.ElementAtOrDefault">
            <summary>
            Returns "ElementAtOrDefault".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Except">
            <summary>
            Returns "Except".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.First">
            <summary>
            Returns "First".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.FirstOrDefault">
            <summary>
            Returns "FirstOrDefault".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.GroupBy">
            <summary>
            Returns "GroupBy".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.GroupJoin">
            <summary>
            Returns "GroupJoin".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Intersect">
            <summary>
            Returns "Intersect".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Join">
            <summary>
            Returns "Join".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Last">
            <summary>
            Returns "Last".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.LastOrDefault">
            <summary>
            Returns "LastOrDefault".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.LongCount">
            <summary>
            Returns "LongCount".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Max">
            <summary>
            Returns "Max".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Min">
            <summary>
            Returns "Min".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.OfType">
            <summary>
            Returns "OfType".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.OrderBy">
            <summary>
            Returns "OrderBy".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.OrderByDescending">
            <summary>
            Returns "OrderByDescending".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Reverse">
            <summary>
            Returns "Reverse".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Select">
            <summary>
            Returns "Select".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.SelectMany">
            <summary>
            Returns "SelectMany".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.SequenceEqual">
            <summary>
            Returns "SequenceEqual".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Single">
            <summary>
            Returns "Single".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.SingleOrDefault">
            <summary>
            Returns "SingleOrDefault".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Skip">
            <summary>
            Returns "Skip".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.SkipWhile">
            <summary>
            Returns "SkipWhile".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Sum">
            <summary>
            Returns "Sum".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Take">
            <summary>
            Returns "Take".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.TakeWhile">
            <summary>
            Returns "TakeWhile".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.ThenBy">
            <summary>
            Returns "ThenBy".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.ThenByDescending">
            <summary>
            Returns "ThenByDescending".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.ToArray">
            <summary>
            Returns "ToArray".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.ToList">
            <summary>
            Returns "ToList".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Union">
            <summary>
            Returns "Union".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Queryable.Where">
            <summary>
            Returns "Where".
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.WellKnown.Tuple">
            <summary>
             Various well-known constants related to <see cref="T:Xtensive.Core.Reflection.WellKnown.Tuple"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetValueOrDefault">
            <summary>
            Returns "GetValueOrDefault".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetValue">
            <summary>
            Returns "GetValue".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.SetValue">
            <summary>
            Returns "SetValue".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.HasValue">
            <summary>
            Returns "HasValue".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetFieldState">
            <summary>
            Returns "GetFieldState".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.SetFieldState">
            <summary>
            Returns "SetFieldState".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.DescriptorFieldName">
            <summary>
            Returns "descriptor".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetValueX">
            <summary>
            Returns "GetValue{0}".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetNullableValueX">
            <summary>
            Returns "GetNullableValueOrDefault{0}".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.SetValueX">
            <summary>
            Returns "SetValue{0}".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.SetNullableValueX">
            <summary>
            Returns "SetNullableValue{0}".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetValueDelegatesFieldName">
            <summary>
            Returns "getValueDelegates".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetNullableValueDelegatesFieldName">
            <summary>
            Returns "getNullableValueDelegates".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.SetValueDelegatesFieldName">
            <summary>
            Returns "setValueDelegates".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.SetNullableValueDelegatesFieldName">
            <summary>
            Returns "setNullableValueDelegates".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetGetValueDelegate">
            <summary>
            Returns "GetGetValueDelegate".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetGetNullableValueDelegate">
            <summary>
            Returns "GetGetNullableValueDelegate".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetSetValueDelegate">
            <summary>
            Returns "GetSetValueDelegate".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.GetSetNullableValueDelegate">
            <summary>
            Returns "GetSetValueDelegate".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.Descriptor">
            <summary>
            Returns "Descriptor".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.Count">
            <summary>
            Returns "Count".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.Create">
            <summary>
            Returns "Create".
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.WellKnown.Tuple.CreateNew">
            <summary>
            Returns "CreateNew".
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinaryObjectSerializerProvider">
            <summary>
            An implementation of <see cref="T:Xtensive.Core.Serialization.IObjectSerializerProvider"/> for binary serialization.
            </summary>
            <remarks>
            <see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Serialization.ObjectSerializerProviderBase">
            <summary>
            Base class for any <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/> provider. 
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.IObjectSerializerProvider">
            <summary>
            <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/> and <see cref="T:Xtensive.Core.Serialization.IObjectSerializer"/> provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializerProvider.GetSerializer``1">
            <summary>
            Gets the serializer for specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to provide the serializer for.</typeparam>
            <returns>Serializer for the specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializerProvider.GetSerializer(System.Type)">
            <summary>
            Gets the serializer for specified <paramref name="type"/>.
            </summary>
            <param name="type">The type to provide the serializer for.</param>
            <returns>Serializer for the specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializerProvider.GetSerializerByInstance(System.Object)">
            <summary>
            Gets the serializer for type of <paramref name="instance"/>.
            </summary>
            <param name="instance">The object which type is used to provide the serializer for.</param>
            <returns>Serializer for the specified type.</returns>
        </member>
        <member name="P:Xtensive.Core.Serialization.IObjectSerializerProvider.ValueSerializerProvider">
            <summary>
            Gets the value serializer provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerProviderBase.GetSerializer``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerProviderBase.GetSerializer(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerProviderBase.GetSerializerByInstance(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerProviderBase.ConvertAssociate``3(``1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerProviderBase.#ctor(Xtensive.Core.Serialization.IValueSerializerProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="valueSerializerProvider">The <see cref="P:Xtensive.Core.Serialization.ObjectSerializerProviderBase.ValueSerializerProvider"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinaryObjectSerializerProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinaryObjectSerializerProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinarySerializationContext">
            <summary>
            A context specific to binary serialization.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.SerializationContext">
            <summary>
            The context of a single serialization / deserialization operation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationContext.CreateActiveScope">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationContext.EnsureProcessTypeIs(Xtensive.Core.Serialization.SerializerProcessType)">
            <exception cref="T:System.InvalidOperationException">Current formatter process type 
            differs from the <paramref name="expectedProcessType"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationContext.Initialize">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationContext.#ctor(Xtensive.Core.Serialization.WorkingSerializerBase,System.IO.Stream,Xtensive.Core.Serialization.SerializerProcessType)">
            <summary>
            Initializes the context for specified process type.
            </summary>
            <param name="serializer">The <see cref="P:Xtensive.Core.Serialization.SerializationContext.Serializer"/> property value.</param>
            <param name="processType">Type of the process to prepare for.</param>
            <param name="stream">The stream to use.</param>
            <exception cref="T:System.NotSupportedException">Context is already initialized.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="processType"/> is
            <see cref="F:Xtensive.Core.Serialization.SerializerProcessType.None"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationContext.Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Current">
            <summary>
            Gets the current <see cref="T:Xtensive.Core.Serialization.SerializationContext"/>.
            </summary>        
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Serializer">
            <summary>
            Gets current <see cref="P:Xtensive.Core.Serialization.SerializationContext.Serializer"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.ProcessType">
            <summary>
            Gets the current <see cref="P:Xtensive.Core.Serialization.SerializationContext.Serializer"/> process type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Stream">
            <summary>
            Gets the stream used in current process.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.PreferNesting">
            <summary>
            Gets the current <see cref="P:Xtensive.Core.Serialization.SerializerConfiguration.PreferNesting"/> value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes">
            <summary>
            Gets the current <see cref="P:Xtensive.Core.Serialization.SerializerConfiguration.PreferAttributes"/> value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Reader">
            <summary>
            Gets the current <see cref="T:Xtensive.Core.Serialization.SerializationData"/> reader.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Writer">
            <summary>
            Gets the current <see cref="T:Xtensive.Core.Serialization.SerializationData"/> writer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Path">
            <summary>
            Gets the stack of <see cref="T:Xtensive.Core.Serialization.SerializationData"/> objects 
            that are currently serialized or deserialized.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.TokenManager">
            <summary>
            Gets the <see cref="P:Xtensive.Core.Serialization.SerializationContext.TokenManager"/> managing <see cref="T:Xtensive.Core.Serialization.Implementation.Token"/>s 
            in this context.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.ReferenceManager">
            <summary>
            Gets the <see cref="P:Xtensive.Core.Serialization.SerializationContext.ReferenceManager"/> managing <see cref="T:Xtensive.Core.Serialization.IReference"/>s 
            in this context.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.DeserializationMap">
            <summary>
            Gets the deserialization map.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.SerializationQueue">
            <summary>
            Gets the serialization queue.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.FixupManager">
            <summary>
            Gets a <see cref="P:Xtensive.Core.Serialization.SerializationContext.FixupManager"/> of field recovery
            actions for objects which fields haven't already deserialized.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Configuration">
            <summary>
            Gets or sets the configuration.
            </summary>
            <value>The configuration.</value>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.ObjectSerializerProvider">
            <summary>
            Gets or sets the object serializer provider.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.ValueSerializerProvider">
            <summary>
            Gets or sets the value serializer provider.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.BooleanSerializer">
            <summary>
            Gets the <see cref="T:System.Boolean"/> value serializer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.ByteSerializer">
            <summary>
            Gets the <see cref="T:System.Byte"/> value serializer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Int16Serializer">
            <summary>
            Gets the <see cref="T:System.Int16"/> value serializer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Int32Serializer">
            <summary>
            Gets the <see cref="T:System.Int32"/> value serializer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.Int64Serializer">
            <summary>
            Gets the <see cref="T:System.Int64"/> value serializer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.StringSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.String"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.TypeSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Type"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.StringTokenSerializer">
            <summary>
            Gets the value serializer for <see cref="T:Xtensive.Core.Serialization.Implementation.Token`1"/> of <see cref="T:System.String"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.TypeTokenSerializer">
            <summary>
            Gets the value serializer for <see cref="T:Xtensive.Core.Serialization.Implementation.Token`1"/> of <see cref="T:System.Type"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationContext.IsActive">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationContext.#ctor(Xtensive.Core.Serialization.WorkingSerializerBase,System.IO.Stream,Xtensive.Core.Serialization.SerializerProcessType)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationContext.Current">
            <summary>
            Gets the current <see cref="T:Xtensive.Core.Serialization.Binary.BinarySerializationContext"/>.
            </summary>        
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationContext.Serializer">
            <summary>
            Gets current <see cref="P:Xtensive.Core.Serialization.Binary.BinarySerializationContext.Serializer"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinarySerializationDataReader">
            <summary>
            Binary <see cref="T:Xtensive.Core.Serialization.SerializationData"/> reader.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.SerializationDataReader">
            <summary>
            Abstract base class any <see cref="T:Xtensive.Core.Serialization.SerializationData"/> reader.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataReader.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataReader.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationDataReader.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinarySerializationDataWriter">
            <summary>
            Binary <see cref="T:Xtensive.Core.Serialization.SerializationData"/> writer.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.SerializationDataWriter">
            <summary>
            Abstract base class for any record writer.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataWriter.Initialize">
            <summary>
            Initializes this instance.
            Called before starting the serialization.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataWriter.Create(Xtensive.Core.Serialization.IReference,System.Object,System.Object)">
            <summary>
            Creates a new <see cref="T:Xtensive.Core.Serialization.SerializationData"/> instance.
            </summary>
            <param name="reference">The <see cref="P:Xtensive.Core.Serialization.SerializationData.Reference"/> property value.</param>
            <param name="source">The <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> property value.</param>
            <param name="origin">The <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> property value.</param>
            <returns>New <see cref="T:Xtensive.Core.Serialization.SerializationData"/> instance.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataWriter.Append(Xtensive.Core.Serialization.SerializationData)">
            <summary>
            Appends (writes) the specified <paramref name="data"/> to the end of the stream.
            </summary>
            <param name="data">Record to append.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataWriter.Complete">
            <summary>
            Called on successful completion of serialization.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializationDataWriter.Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationDataWriter.Create(Xtensive.Core.Serialization.IReference,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationDataWriter.Append(Xtensive.Core.Serialization.SerializationData)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationDataWriter.Complete">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinarySerializer">
            <summary>
            Binary serializer implementation.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Serialization.WorkingSerializerBase">
            <summary>
            Serializes and deserializes an object, or an entire graph of connected objects.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.SerializerBase">
            <summary>
            Abstract base class for any serializer.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Configuration.ConfigurableBase`1">
            <summary>
            Base class for <see cref="T:Xtensive.Core.IConfigurable`1"/> implementors.
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate"/></para>
            </remarks>
            <typeparam name="TConfiguration">Type of <see cref="P:Xtensive.Core.Configuration.ConfigurableBase`1.Configuration"/>.</typeparam>
        </member>
        <member name="T:Xtensive.Core.IConfigurable`1">
            <summary>
            Configurable object contract.
            </summary>
            <remarks>
            <para id="Ctor"><see cref="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate"/></para>
            </remarks>
            <typeparam name="TConfiguration">Type of <see cref="P:Xtensive.Core.IConfigurable`1.Configuration"/>.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IConfigurable`1.Configure(`0)">
            <summary>
            Configures the instance by the specified <paramref name="configuration"/>.
            Invoked by <see cref="P:Xtensive.Core.IConfigurable`1.Configuration"/> property setter.
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="P:Xtensive.Core.IConfigurable`1.IsConfigured">
            <summary>
            Indicates whether instance is already configured -
            i.e. its <see cref="P:Xtensive.Core.IConfigurable`1.Configuration"/> is already set
            or <see cref="M:Xtensive.Core.IConfigurable`1.Configure(`0)"/> method is called.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IConfigurable`1.Configuration">
            <summary>
            Gets or sets the configuration of this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurableBase`1.EnsureConfigured">
            <summary>
            Ensures instance is already configured - i.e. its
            <see cref="P:Xtensive.Core.Configuration.ConfigurableBase`1.Configuration"/> property is successfully set, or
            <see cref="M:Xtensive.Core.Configuration.ConfigurableBase`1.Configure(`0)"/> method is successfully called.
            </summary>
            <exception cref="T:System.InvalidOperationException"><see cref="P:Xtensive.Core.Configuration.ConfigurableBase`1.Configuration"/> property is not initialized.</exception>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurableBase`1.Configure(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException"><see cref="P:Xtensive.Core.Configuration.ConfigurableBase`1.Configuration"/> property is already initialized.</exception>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurableBase`1.ValidateConfiguration">
            <summary>
            Called by <see cref="M:Xtensive.Core.Configuration.ConfigurableBase`1.Configure(`0)"/> to validate the
            provided configuration.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurableBase`1.OnConfigured">
            <summary>
            Called by <see cref="M:Xtensive.Core.Configuration.ConfigurableBase`1.Configure(`0)"/> on completion of 
            (accepting the) configuration.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurableBase`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Configuration.ConfigurableBase`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="configuration">Configuration to <see cref="M:Xtensive.Core.Configuration.ConfigurableBase`1.Configure(`0)"/> with.</param>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurableBase`1.IsConfigured">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Configuration.ConfigurableBase`1.Configuration">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Serialization.ISerializer">
            <summary>
            Serializer contract.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ISerializer.Serialize(System.IO.Stream,System.Object,System.Object)">
            <summary>
            Serializes the differences between <paramref name="source"/> object and the 
            <paramref name="origin"/> to the specified <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="source">The object graph to serialize.</param>
            <param name="origin">The original graph.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ISerializer.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes the <paramref name="source"/> object 
            to the specified <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream to serialize to.</param>
            <param name="source">The object graph to serialize.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ISerializer.Deserialize(System.IO.Stream,System.Object)">
            <summary>
            Deserializes the changes stored by <see cref="M:Xtensive.Core.Serialization.ISerializer.Serialize(System.IO.Stream,System.Object,System.Object)"/>
            from the specified <paramref name="stream"/>
            by applying them to <paramref name="origin"/>.
            </summary>
            <param name="stream">The stream to populate the data from.</param>
            <param name="origin">The origin - the graph to update.</param>
            <returns>The deserialized (updated) graph.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ISerializer.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes the object from the specified <paramref name="stream"/>.
            </summary>
            <param name="stream">The stream to populate the data from.</param>
            <returns>The deserialized graph.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ISerializer.Clone(System.Object)">
            <summary>
            Clones the specified <paramref name="source"/> object using this serializer.
            </summary>
            <param name="source">The graph to clone.</param>
            <returns>Cloned graph.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.Serialize(System.IO.Stream,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.Deserialize(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.Clone(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.Serialize(System.IO.Stream,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.Deserialize(System.IO.Stream,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerBase.#ctor(Xtensive.Core.Serialization.SerializerConfiguration)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.CreateContext(System.IO.Stream,Xtensive.Core.Serialization.SerializerProcessType)">
            <summary>
            Creates a new <see cref="T:Xtensive.Core.Serialization.SerializationContext"/> for serialization or deserialization.
            </summary>
            <param name="processType">Type of the process to prepare for.</param>
            <param name="stream">The stream to use.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Serialization.SerializationContext"/> instance.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.Serialize(System.IO.Stream,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.Deserialize(System.IO.Stream,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.HasValueSerializer``1">
            <summary>
            Indicates if type <typeparamref name="T"/> has associated <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>;
            otherwise is must have associated <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/>.
            </summary>
            <typeparam name="T">The type to check.</typeparam>
            <returns><see langword="True"/> if <typeparamref name="T"/> has associated 
            <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>;
            otherwise is must have associated <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.EnsureHasValueSerializer``1">
            <summary>
            Ensures the <typeparamref name="T"/> type is associated 
            with <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>.
            </summary>
            <typeparam name="T">The type to check.</typeparam>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="T"/> is associated 
            with <see cref="T:Xtensive.Core.Serialization.IObjectSerializer"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.EnsureHasObjectSerializer``1">
            <summary>
            Ensures the <typeparamref name="T"/> type is associated 
            with <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/>.
            </summary>
            <typeparam name="T">The type to check.</typeparam>
            <exception cref="T:System.InvalidOperationException"><typeparamref name="T"/> is associated 
            with <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.EnsureObjectSerializerIsFound(System.Object,System.Type)">
            <summary>
            Ensures the object serializer is found.
            </summary>
            <param name="serializer">The serializer to check.</param>
            <param name="type">The type it was acquired for.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="serializer"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.EnsureValueSerializerIsFound(System.Object,System.Type)">
            <summary>
            Ensures the value serializer is found.
            </summary>
            <param name="serializer">The serializer to check.</param>
            <param name="type">The type it was acquired for.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="serializer"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.EnsureValueSerializerIsFound``1(System.Object)">
            <summary>
            Ensures the value serializer is found.
            </summary>
            <typeparam name="T">The type it was acquired for.</typeparam>
            <param name="serializer">The serializer to check.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="serializer"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.GetObjectData(System.Object,System.Object,System.Boolean)">
            <exception cref="T:System.InvalidOperationException">Wrong behavior of some component used in serialization.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.WorkingSerializerBase.#ctor(Xtensive.Core.Serialization.SerializerConfiguration)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.WorkingSerializerBase.ObjectSerializerProvider">
            <summary>
            Gets or sets the object serializer provider.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.WorkingSerializerBase.ValueSerializerProvider">
            <summary>
            Gets the value serializer provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializer.CreateContext(System.IO.Stream,Xtensive.Core.Serialization.SerializerProcessType)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializer.OnConfigured">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializer.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializer.#ctor(Xtensive.Core.Serialization.SerializerConfiguration)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializer.Instance">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinarySerializationData">
            <summary>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> specific to binary serialization.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.SerializationData">
            <summary>
            Provides high-level access to the serializing or deserializing data.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <summary>
            Adds the <paramref name="value"/> to this instance.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="valueSerializer">The value serializer.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0)">
            <summary>
            Adds the <paramref name="value"/> to this instance.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,System.Boolean,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <summary>
            Adds the <paramref name="value"/> to this instance.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="preferAttributes">Temporary changes
            <see cref="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes"/> value
            for the duration of this call.</param>
            <param name="valueSerializer">The value serializer.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,System.Boolean)">
            <summary>
            Adds the <paramref name="value"/> to this instance.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="preferAttributes">Temporary changes 
            <see cref="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes"/> value 
            for the duration of this call.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,``0,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <summary>
            Adds the <paramref name="value"/> to this instance,
            if <paramref name="value"/> isn't equal to <paramref name="originValue"/>.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="originValue">The value of the origin.</param>
            <param name="valueSerializer">The value serializer.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,``0)">
            <summary>
            Adds the <paramref name="value"/> to this instance,
            if <paramref name="value"/> isn't equal to <paramref name="originValue"/>.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="originValue">The value of the origin.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,``0,System.Boolean,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <summary>
            Adds the <paramref name="value"/> to this instance,
            if <paramref name="value"/> isn't equal to <paramref name="originValue"/>.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="originValue">The value of the origin.</param>
            <param name="preferAttributes">Temporary changes
            <see cref="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes"/> value
            for the duration of this call.</param>
            <param name="valueSerializer">The value serializer.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``1(System.String,``0,``0,System.Boolean)">
            <summary>
            Adds the <paramref name="value"/> to this instance,
            if <paramref name="value"/> isn't equal to <paramref name="originValue"/>.
            </summary>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="value">The value to add.</param>
            <param name="originValue">The value of the origin.</param>
            <param name="preferAttributes">Temporary changes 
            <see cref="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes"/> value 
            for the duration of this call.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``2(System.String,System.Func{``0,``1},Xtensive.Core.Serialization.ValueSerializer{``1})">
            <summary>
            Adds the value read by <paramref name="getter"/>
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            if it isn't equal to the same read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/>.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The value getter.</param>
            <param name="valueSerializer">The value serializer.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``2(System.String,System.Func{``0,``1})">
            <summary>
            Adds the value read by <paramref name="getter"/> 
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            if it isn't equal to the same read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/>.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The value getter.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``2(System.String,System.Func{``0,``1},System.Boolean,Xtensive.Core.Serialization.ValueSerializer{``1})">
            <summary>
            Adds the value read by <paramref name="getter"/>
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            if it isn't equal to the same read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/>.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The value getter.</param>
            <param name="preferAttributes">Temporary changes
            <see cref="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes"/> value
            for the duration of this call.</param>
            <param name="valueSerializer">The value serializer.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddValue``2(System.String,System.Func{``0,``1},System.Boolean)">
            <summary>
            Adds the value read by <paramref name="getter"/> 
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            if it isn't equal to the same read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/>.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <typeparam name="T">The type of the value to add.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The value getter.</param>
            <param name="preferAttributes">Temporary changes 
            <see cref="P:Xtensive.Core.Serialization.SerializationContext.PreferAttributes"/> value 
            for the duration of this call.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObject(System.String,System.Object)">
            <summary>
            Adds the object to this instance.
            </summary>
            <param name="name">The name to associate with the object.</param>
            <param name="value">The object to add.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObject(System.String,System.Object,System.Boolean)">
            <summary>
            Adds the object to this instance.
            </summary>
            <param name="name">The name to associate with the object.</param>
            <param name="value">The object to add.</param>
            <param name="preferNesting"><see langword="true"/> if its preferable to nest it;
            otherwise, <see langword="false"/>.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObject(System.String,System.Object,System.Object)">
            <summary>
            Adds the object to this instance.
            </summary>
            <param name="name">The name to associate with the object.</param>
            <param name="value">The object to add.</param>
            <param name="originValue">The origin object value.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObject(System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            Adds the object to this instance.
            </summary>
            <param name="name">The name to associate with the object.</param>
            <param name="value">The object to add.</param>
            <param name="originValue">The origin object value.</param>
            <param name="preferNesting"><see langword="true"/> if its preferable to nest it;
            otherwise, <see langword="false"/>.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObject``1(System.String,System.Func{``0,System.Object})">
            <summary>
            Adds the object read by <paramref name="getter"/>
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            providing its origin read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> by the same way.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The value getter.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObject``1(System.String,System.Func{``0,System.Object},System.Boolean)">
            <summary>
            Adds the object read by <paramref name="getter"/>
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            providing its origin read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> by the same way.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The value getter.</param>
            <param name="preferNesting"><see langword="true"/> if its preferable to nest it;
            otherwise, <see langword="false"/>.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObjects(System.String,System.Collections.IEnumerable)">
            <summary>
            Adds the objects to this instance.
            </summary>
            <param name="name">The name to associate with the objects.</param>
            <param name="values">The objects to add.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added objects
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObjects(System.String,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Adds the objects to this instance.
            </summary>
            <param name="name">The name to associate with the objects.</param>
            <param name="values">The objects to add.</param>
            <param name="preferNesting"><see langword="true"/> if its preferable to nest them;
            otherwise, <see langword="false"/>.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added objects
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObjects(System.String,System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            Adds the objects to this instance.
            </summary>
            <param name="name">The name to associate with the objects.</param>
            <param name="values">The objects to add.</param>
            <param name="originValues">The origin object values.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added objects
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObjects(System.String,System.Collections.IEnumerable,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Adds the objects to this instance.
            </summary>
            <param name="name">The name to associate with the objects.</param>
            <param name="values">The objects to add.</param>
            <param name="originValues">The origin object values.</param>
            <param name="preferNesting"><see langword="true"/> if its preferable to nest them;
            otherwise, <see langword="false"/>.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added objects
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObjects``1(System.String,System.Func{``0,System.Collections.IEnumerable})">
            <summary>
            Adds the objects read by <paramref name="getter"/>
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            providing its origin read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> by the same way.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The values getter.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added objects
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddObjects``1(System.String,System.Func{``0,System.Collections.IEnumerable},System.Boolean)">
            <summary>
            Adds the objects read by <paramref name="getter"/>
            from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> to this instance,
            providing its origin read from the <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> by the same way.
            </summary>
            <typeparam name="TOwner">The type of the value owner.</typeparam>
            <param name="name">The name to associate with the value.</param>
            <param name="getter">The values getter.</param>
            <param name="preferNesting"><see langword="true"/> if its preferable to nest them;
            otherwise, <see langword="false"/>.</param>
            <returns>
            A <see cref="T:Xtensive.Core.Serialization.SerializationData"/> describing added object
            or a reference to it.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetValue``1(System.String)">
            <summary>
            Gets a value from this instance.
            </summary>
            <typeparam name="T">The type of the value to get.</typeparam>
            <param name="name">The name associated with the value.</param>
            <returns>
            The value associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetValue``1(System.String,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <summary>
            Gets a value from this instance.
            </summary>
            <typeparam name="T">The type of the value to get.</typeparam>
            <param name="name">The name associated with the value.</param>
            <param name="valueSerializer">The value serializer.</param>
            <returns>
            The value associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetObject``1(System.String)">
            <summary>
            Gets an object from this instance.
            </summary>
            <param name="name">The name associated with the object.</param>
            <returns>
            The object associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetObject``1(System.String,System.Object)">
            <summary>
            Gets an object from this instance.
            </summary>
            <param name="name">The name associated with the object.</param>
            <param name="originValue">The origin object value.</param>
            <returns>
            The object associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetObjects``1(System.String)">
            <summary>
            Gets objects from this instance.
            </summary>
            <param name="name">The name associated with the objects.</param>
            <returns>
            The objects associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetObjects``1(System.String,System.Collections.IEnumerable)">
            <summary>
            Gets objects from this instance.
            </summary>
            <param name="name">The name associated with the objects.</param>
            <param name="originValues">The origin object values.</param>
            <returns>
            The objects associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetReference(System.String)">
            <summary>
            Gets reference to an object from this instance.
            </summary>
            <param name="name">The name associated with the object.</param>
            <returns>
            The reference to the object associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetReference(System.String,System.Object)">
            <summary>
            Gets reference to an object from this instance.
            </summary>
            <param name="name">The name associated with the object.</param>
            <param name="originValue">The origin object value.</param>
            <returns>
            The reference to the object associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetReferences(System.String)">
            <summary>
            Gets references to objects from this instance.
            </summary>
            <param name="name">The name associated with the objects.</param>
            <returns>
            The references to objects associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetReferences(System.String,System.Collections.IEnumerable)">
            <summary>
            Gets references to objects from this instance.
            </summary>
            <param name="name">The name associated with the objects.</param>
            <param name="originValues">The origin object values.</param>
            <returns>
            The references to objects associated with the <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.HasValue(System.String)">
            <summary>
            Determines whether the value with specified name exists.
            </summary>
            <param name="name">The name associated with the value.</param>
            <returns>
            <see langword="true"/> if the value with specified name exists; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.SkipValue(System.String)">
            <summary>
            "Officially" skips the value by marking it as read.
            </summary>
            <param name="name">The name associated with the value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.RemoveValue(System.String)">
            <summary>
            Removes the value with the specified name.
            </summary>
            <param name="name">The name associated with the value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddFixup``1(System.String,``0,System.Action{``0,Xtensive.Core.Serialization.IReference})">
            <summary>
            Adds a fixup action to an object 
            associated with the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name associated with the object.</param>
            <param name="target">Object to execute the <paramref name="action"/> on.</param>
            <param name="action">The action to be executed when the referred object will be deserialized.</param>
            <typeparam name="T">Type of the <paramref name="target"/>.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddFixup``1(System.String,System.Action{``0,Xtensive.Core.Serialization.IReference})">
            <summary>
            Adds a fixup action to an object 
            associated with the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name associated with the object.</param>
            <param name="action">The action to be executed when the referred object will be deserialized.</param>
            <typeparam name="T">Type of the target object.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddFixups``1(System.String,``0,System.Action{``0,Xtensive.Core.Serialization.IReference})">
            <summary>
            Adds fixup actions to objects 
            associated with the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name associated with the objects.</param>
            <param name="target">Object to execute the <paramref name="action"/> on.</param>
            <param name="action">The action to be executed when the referred object will be deserialized.</param>
            <typeparam name="T">Type of the <paramref name="target"/>.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.AddFixups``1(System.String,System.Action{``0,Xtensive.Core.Serialization.IReference})">
            <summary>
            Adds fixup actions to objects 
            associated with the specified <paramref name="name"/>.
            </summary>
            <param name="name">The name associated with the objects.</param>
            <param name="action">The action to be executed when the referred object will be deserialized.</param>
            <typeparam name="T">Type of the target object.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.UpdateSource(System.Object)">
            <summary>
            Updates the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> property value.
            Note that if <see cref="P:Xtensive.Core.Serialization.SerializationData.Reference"/> is set, it
            can be updated just once. Successive update with
            different <paramref name="source"/> value will fail,
            since <see cref="P:Xtensive.Core.Serialization.SerializationData.Reference"/> can be 
            <see cref="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.Define(Xtensive.Core.Serialization.IReference,System.Object)"/>d just once.
            </summary>
            <param name="source">The new source.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.EnsureNoSkips">
            <summary>
            Ensures there are no skipped slots during reading the data 
            (<see cref="P:Xtensive.Core.Serialization.SerializationData.SkipCount"/> is <see langword="0"/>).
            </summary>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Some slots were skipped.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.#ctor(Xtensive.Core.Serialization.IReference,System.Object,System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>.
            </summary>
            <param name="reference">The <see cref="P:Xtensive.Core.Serialization.SerializationData.Reference"/> property value.</param>
            <param name="source">The <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> property value.</param>
            <param name="origin">The <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationData.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Context">
            <summary>
            Gets the context this instance is bound to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Serializer">
            <summary>
            Gets the serializer this instance is bound to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Type">
            <summary>
            Gets the type associated with this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Reference">
            <summary>
            Gets the reference associated with this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Source">
            <summary>
            Gets the source object associated with this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Origin">
            <summary>
            Gets the origin object associated with this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.Count">
            <summary>
            Gets the count of slots in this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.ReadCount">
            <summary>
            Gets the count of slots fetched by <see cref="M:Xtensive.Core.Serialization.SerializationData.GetValue``1(System.String)"/>-like methods.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.SkipCount">
            <summary>
            Gets the count of skipped slots (the slots that aren't 
            fetched by <see cref="M:Xtensive.Core.Serialization.SerializationData.GetValue``1(System.String)"/>-like methods).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.SerializedType">
            <summary>
            Gets or sets the serialized type of the object (<see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/>) described by this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializationData.SerializedReference">
            <summary>
            Gets or sets the serialized <see cref="P:Xtensive.Core.Serialization.SerializationData.Reference"/> value to the object (<see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/>) described by this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.AddValue``1(System.String,``0,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <inheritdoc/>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Value with specified <paramref name="name"/> already exists.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.GetValue``1(System.String,Xtensive.Core.Serialization.ValueSerializer{``0})">
            <inheritdoc/>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Value with specified <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.SkipValue(System.String)">
            <inheritdoc/>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Value with specified <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.HasValue(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.RemoveValue(System.String)">
            <inheritdoc/>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Value with specified <paramref name="name"/> is not found.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.EnsureIsCompletelyRead">
            <summary>
            Ensures the data is fully read (recalculates <see cref="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.Count"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.ReadNextSlot">
            <summary>
            Reads the next serialized slot.
            </summary>
            <returns>The name of the serialized value.
            <see langword="null" />, if there are no more slots.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.#ctor(System.IO.Stream)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="stream">The <see cref="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.Stream"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinarySerializationData.#ctor(Xtensive.Core.Serialization.IReference,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.Context">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Serialization.SerializationContext"/> this instance belongs to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.ValueSerializerProvider">
            <summary>
            Gets the <see cref="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.ValueSerializerProvider"/> used by this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.Stream">
            <summary>
            Gets the underlying stream for this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.ReadCount">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinarySerializationData.SerializedType">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.BinaryValueSerializerProvider">
            <summary>
            An implementation of <see cref="T:Xtensive.Core.Serialization.IValueSerializerProvider"/> for binary serialization.
            </summary>
            <remarks>
            <see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Serialization.ValueSerializerProvider">
            <summary>
            Default <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/> provider. 
            Provides default primitive serializer for the specified type.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Serialization.IValueSerializerProvider">
            <summary>
            <see cref="T:Xtensive.Core.Serialization.ValueSerializer`1"/> and <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/> provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializerProvider.GetSerializer``1">
            <summary>
            Gets the serializer for specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type to provide the serializer for.</typeparam>
            <returns>Serializer for the specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializerProvider.GetSerializer(System.Type)">
            <summary>
            Gets the serializer for specified <paramref name="type"/>.
            </summary>
            <param name="type">The type to provide the serializer for.</param>
            <returns>Serializer for the specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializerProvider.GetSerializerByInstance(System.Object)">
            <summary>
            Gets the serializer for type of <paramref name="instance"/>.
            </summary>
            <param name="instance">The object which type is used to provide the serializer for.</param>
            <returns>Serializer for the specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerProvider.FastGetSerializer``1">
            <summary>
            The same as <see cref="M:Xtensive.Core.Serialization.ValueSerializerProvider.GetSerializer``1"/>, but non-virtual.
            </summary>
            <typeparam name="T">The type of serializer to get.</typeparam>
            <returns>Found serializer or <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerProvider.GetSerializer``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerProvider.GetSerializer(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerProvider.GetSerializerByInstance(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerProvider.ConvertAssociate``3(``1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ValueSerializerProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.BinaryValueSerializerProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.BinaryValueSerializerProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.WrappingValueSerializer`3">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>s.
            </summary>
            <typeparam name="T">The type to serialize.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Serialization.ValueSerializerBase`1">
            <summary>
            Base class for any <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>.
            </summary>
            <typeparam name="T">Type of value to serialize or deserialize.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Serialization.IValueSerializer`1">
            <summary>
            Serializes (deserializes) the objects 
            of the specified type <typeparamref name="T"/>
            to (from) the stream.
            </summary>
            <typeparam name="T">Type of object to serialize or deserialize.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Serialization.IValueSerializer">
            <summary>
            Serializes (deserializes) the objects to (from) the stream.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializer.Serialize(System.IO.Stream,System.Object)">
            <summary>
            Serializes an object to the provided stream at the current stream position.
            </summary>
            <param name="stream">The stream to serialize the data to.</param>
            <param name="value">The object to serialize.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializer.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes the data at the current position of the provided stream.
            </summary>
            <param name="stream">The stream to deserialize the data from.</param>
            <returns>Deserialization result.</returns>
        </member>
        <member name="P:Xtensive.Core.Serialization.IValueSerializer.Provider">
            <summary>
            Gets the provider this serializer is associated with.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializer`1.Serialize(System.IO.Stream,`0)">
            <summary>
            Serializes an object to the provided stream at the current stream position.
            </summary>
            <param name="stream">The stream to serialize the data to.</param>
            <param name="value">The object to serialize.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.IValueSerializer`1.Deserialize(System.IO.Stream)">
            <summary>
            Deserializes the data at the current position of the provided stream.
            </summary>
            <param name="stream">The stream to deserialize the data from.</param>
            <returns>Deserialization result.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerBase`1.Deserialize(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerBase`1.Serialize(System.IO.Stream,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerBase`1.GetValueSerializer``1">
            <exception cref="T:System.InvalidOperationException">Requested value serializer is not found.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerBase`1.#ctor(Xtensive.Core.Serialization.IValueSerializerProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Serializer provider this serializer is bound to.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerBase`1.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Serialization.ValueSerializerBase`1.Provider">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.ValueSerializerBase`1.OutputLength">
            <summary>
            Gets the length of the output produced by this serializer.
            <see langword="-1" /> means it may vary.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.WrappingValueSerializer`3.BaseSerializer1">
            <summary>
            Serializer for first base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.WrappingValueSerializer`3.BaseSerializer2">
            <summary>
            Serializer for second base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.WrappingValueSerializer`3.#ctor(Xtensive.Core.Serialization.IValueSerializerProvider)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Value serializer for 
            <typeparamref name="TBase1"/> or <typeparamref name="TBase2"/> is not found.</exception>
        </member>
        <member name="T:Xtensive.Core.Serialization.WrappingValueSerializer`4">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>s.
            </summary>
            <typeparam name="T">The type to serialize.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
            <typeparam name="TBase3">Third base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Serialization.WrappingValueSerializer`4.BaseSerializer3">
            <summary>
            Serializer for third base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.WrappingValueSerializer`4.#ctor(Xtensive.Core.Serialization.IValueSerializerProvider)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Value serializer for 
            <typeparamref name="TBase1"/> or <typeparamref name="TBase2"/> or <typeparamref name="TBase3"/> is not found.</exception>
        </member>
        <member name="T:Xtensive.Core.Serialization.WrappingValueSerializer`2">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/>s.
            </summary>
            <typeparam name="T">The type to serialize.</typeparam>
            <typeparam name="TBase">Base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Serialization.WrappingValueSerializer`2.BaseSerializer">
            <summary>
            Serializer for base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.WrappingValueSerializer`2.#ctor(Xtensive.Core.Serialization.IValueSerializerProvider)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Value serializer for <typeparamref name="TBase"/> is not found.</exception>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.LegacyBinarySerializer">
            <summary>
            Legacy binary serializer.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer">
            <summary>
            Exposes .Net <see cref="T:System.Runtime.Serialization.IFormatter"/> as <see cref="T:Xtensive.Core.Serialization.ISerializer"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.Serialize(System.IO.Stream,System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.Deserialize(System.IO.Stream,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.OnConfigured">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.#ctor(System.Runtime.Serialization.IFormatter)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="formatter">The <see cref="P:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.Formatter"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.#ctor(System.Runtime.Serialization.IFormatter,Xtensive.Core.Serialization.SerializerConfiguration)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="formatter">The <see cref="P:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.Formatter"/> property value.</param>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.FormatterAsSerializer.Formatter">
            <summary>
            Gets the wrapped formatter.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.LegacyBinarySerializer.OnConfigured">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.LegacyBinarySerializer.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Binary.LegacyBinarySerializer.#ctor(Xtensive.Core.Serialization.SerializerConfiguration)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="configuration">The configuration.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.Binary.LegacyBinarySerializer.Instance">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Binary.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.Binary.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter">
            <summary>
            Exposes <see cref="T:Xtensive.Core.Serialization.ISerializer"/> as .Net <see cref="T:System.Runtime.Serialization.IFormatter"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.Deserialize(System.IO.Stream)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.Serialize(System.IO.Stream,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.#ctor(Xtensive.Core.Serialization.ISerializer)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="serializer">The <see cref="P:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.Serializer"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.Serializer">
            <summary>
            Gets the wrapped serializer.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.Binder">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown on attempt to set this property.</exception>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.Context">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown on attempt to set this property.</exception>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.SerializerAsFormatter.SurrogateSelector">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown on attempt to set this property.</exception>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.Token">
            <summary>
            Uniquely identifies the <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Value"/> in current
            <see cref="T:Xtensive.Core.Serialization.SerializationContext"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Token.Get``1(Xtensive.Core.Serialization.SerializationContext,``0)">
            <summary>
            Gets the token with specified <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Value"/>
            using current <see cref="T:Xtensive.Core.Serialization.SerializationContext"/>.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="context">The serialization context.</param>
            <param name="value">The value to get the token for.</param>
            <returns>
            Found token;
            <see langword="null"/>, if there is no token with specified value.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Token.Get``1(Xtensive.Core.Serialization.SerializationContext,System.Int32)">
            <summary>
            Gets the token with specified <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Identifier"/>
            using current <see cref="T:Xtensive.Core.Serialization.SerializationContext"/>.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="context">The serialization context.</param>
            <param name="identifier">The identifier to get the token for.</param>
            <returns>
            Found token;
            <see langword="null"/>, if there is no token with specified identifier.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Token.GetOrCreate``1(Xtensive.Core.Serialization.SerializationContext,``0)">
            <summary>
            Gets or creates the token with specified value
            using current <see cref="T:Xtensive.Core.Serialization.SerializationContext"/>.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
            <param name="context">The serialization context.</param>
            <param name="value">The value to get or create the token for.</param>
            <returns>
            Found or newly created token with the specified value.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Token.#ctor(System.Object,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">The <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Value"/> property value.</param>
            <param name="identifier">The <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Identifier"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Token.Identifier">
            <summary>
            Gets or sets the identifier of the token.
            Note: normally identifier changes (becomes actual) 
            on the first token serialization.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Token.Value">
            <summary>
            Gets or sets the value of the token.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.TokenManager">
            <summary>
            Manages <see cref="T:Xtensive.Core.Serialization.Implementation.Token"/>s in the <see cref="T:Xtensive.Core.Serialization.SerializationContext"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.TokenManager.Add(Xtensive.Core.Serialization.Implementation.Token)">
            <summary>
            Adds (registers) the specified token.
            </summary>
            <param name="token">The token to add.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.TokenManager.Get(System.Object)">
            <summary>
            Gets the added token by its <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Value"/>.
            </summary>
            <param name="value">The value of the <see cref="T:Xtensive.Core.Serialization.Implementation.Token"/> to get.</param>
            <returns>Found token;
            <see langword="null"/>, if there is no token with specified value.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.TokenManager.Get(System.Int32)">
            <summary>
            Gets the added token by its <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Identifier"/>.
            </summary>
            <param name="identifier">The identifier of the <see cref="T:Xtensive.Core.Serialization.Implementation.Token"/> to get.</param>
            <returns>Found token;
            <see langword="null"/>, if there is no token with specified identifier.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.TokenManager.Update(Xtensive.Core.Serialization.Implementation.Token,System.Int32)">
            <summary>
            Updates the internal structures on change of token <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Identifier"/>.
            </summary>
            <param name="token">The token which identifier is changed.</param>
            <param name="oldIdentifier">The old identifier value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.TokenManager.GetNextIdentifier">
            <summary>
            Gets the next <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Identifier"/> property value.
            All the generated identifiers must be positive.
            </summary>
            <returns>Next <see cref="P:Xtensive.Core.Serialization.Implementation.Token.Identifier"/> property value.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.TokenManager.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.Token`1">
            <summary>
            Typed version of <see cref="T:Xtensive.Core.Serialization.Implementation.Token"/>.
            </summary>
            <typeparam name="T">Type of the value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Token`1.#ctor(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Token`1.Value">
            <summary>
            Gets or sets the value of the token.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.IFixup">
            <summary>
            An action which should be executed after complete deserialization of the graph.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.IFixup.Execute">
            <summary>
            Executes fixup action.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.IFixup.Source">
            <summary>
            Gets the object to execute the action on.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.IFixup.Reference">
            <summary>
            Gets the reference this fixup action is defined for.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.DefaultSerializationBinder">
            <summary>
            Default <see cref="T:System.Runtime.Serialization.SerializationBinder"/> implementation.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.DefaultSerializationBinder.BindToType(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.DefaultSerializationBinder.Instance">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.Fixup`1">
            <summary>
            Default <see cref="T:Xtensive.Core.Serialization.Implementation.IFixup"/> implementation.
            </summary>
            <typeparam name="T">The type of the object to execute the action on.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Fixup`1.Execute">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Fixup`1.#ctor(`0,Xtensive.Core.Serialization.IReference,System.Action{`0,Xtensive.Core.Serialization.IReference})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The <see cref="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Source"/> property value.</param>
            <param name="reference">The <see cref="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Reference"/> property value.</param>
            <param name="action">The <see cref="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Action"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Source">
            <summary>
            Gets the object to execute the action on.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Xtensive#Core#Serialization#Implementation#IFixup#Source">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Reference">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Fixup`1.Action">
            <summary>
            Gets the action to execute.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.FixupManager">
            <summary>
            <see cref="T:Xtensive.Core.Serialization.Implementation.IFixup"/> manager - a queue of <see cref="T:Xtensive.Core.Serialization.Implementation.IFixup"/>s.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FixupManager.Add``1(``0,Xtensive.Core.Serialization.IReference,System.Action{``0,Xtensive.Core.Serialization.IReference})">
            <summary>
            Adds new fixup to the queue.
            </summary>
            <param name="target">Object to execute the <paramref name="action"/> on.</param>
            <param name="reference">Reference the object is waiting for.</param>
            <param name="action">Action after that object deserialization.</param>
            <typeparam name="T">Type of the <paramref name="target"/>.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FixupManager.Execute">
            <summary>
            Executes all the fixups and removes them from itself.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FixupManager.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FixupManager.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FixupManager.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.FixupManager.#ctor(System.Collections.Generic.Queue{Xtensive.Core.Serialization.Implementation.IFixup})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="queue">The queue to use internally.</param>
        </member>
        <member name="T:Xtensive.Core.Serialization.ObjectSerializerBase`1">
            <summary>
            Base class for any <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/>.
            </summary>
            <typeparam name="T">Type of object to serialize / deserialize.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Serialization.IObjectSerializer`1">
            <summary>
            Typed object serializer and deserializer.
            </summary>
            <typeparam name="T">Type of the object to serialize and deserialize.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Serialization.IObjectSerializer">
            <summary>
            Untyped object serializer / deserializer.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializer.CreateObject(System.Type)">
            <summary>
            Creates the object with "initial" state.
            </summary>
            <param name="type">The type of the object to create.</param>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializer.GetObjectData(Xtensive.Core.Serialization.SerializationData)">
            <summary>
            Populates the provided <paramref name="data"/> with the differences
            between <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> and <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/>.
            </summary>
            <param name="data">The <see cref="T:Xtensive.Core.Serialization.SerializationData"/> to populate.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializer.SetObjectData(Xtensive.Core.Serialization.SerializationData)">
            <summary>
            Populates the <see cref="P:Xtensive.Core.Serialization.SerializationData.Source"/> object 
            from <see cref="P:Xtensive.Core.Serialization.SerializationData.Origin"/> by applying the
            changes stored in <paramref name="data"/> to it.
            </summary>
            <param name="data">The <see cref="T:Xtensive.Core.Serialization.SerializationData"/> to use.</param>
            <returns>Updated object.</returns>
        </member>
        <member name="P:Xtensive.Core.Serialization.IObjectSerializer.Provider">
            <summary>
            Gets the provider this serializer is associated with.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.IObjectSerializer.IsReferable">
            <summary>
            Gets the value specified that serializable type can be referred 
            by a set of other objects in serialized graph.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializer`1.CreateObject(System.Type)">
            <summary>
            Creates the object with "initial" state.
            </summary>
            <param name="type">The type of the object to create.</param>
            <returns>Newly created object.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializer`1.GetObjectData(`0,`0,Xtensive.Core.Serialization.SerializationData)">
            <summary>
            Populates the provided <see cref="T:Xtensive.Core.Serialization.SerializationData"/> with the differences
            between <paramref name="source"/> and <paramref name="origin"/>.
            </summary>
            <param name="source">The object to serialize.</param>
            <param name="origin">The origin - the "initial" object state (see <see cref="M:Xtensive.Core.Serialization.IObjectSerializer`1.CreateObject(System.Type)"/>) 
            which shouldn't be serialized.</param>
            <param name="data">The <see cref="T:Xtensive.Core.Serialization.SerializationData"/> to populate.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.IObjectSerializer`1.SetObjectData(`0,Xtensive.Core.Serialization.SerializationData)">
            <summary>
            Updates the object using the information in the <see cref="T:Xtensive.Core.Serialization.SerializationData"/>.
            </summary>
            <param name="source">The object to update.</param>
            <param name="data">The data to update the object from.</param>
            <returns>Updated object.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.CreateObject(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.GetObjectData(`0,`0,Xtensive.Core.Serialization.SerializationData)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.GetObjectHeader(`0,Xtensive.Core.Serialization.SerializationData)">
            <summary>
            Adds <paramref name="source"/> type and reference to the <paramref name="data"/>.
            </summary>
            <param name="source">The object to add the header for.</param>
            <param name="data">The <see cref="T:Xtensive.Core.Serialization.SerializationData"/> to update.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.GetObjectType(`0)">
            <summary>
            Gets the type of the object (used in <see cref="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.GetObjectData(`0,`0,Xtensive.Core.Serialization.SerializationData)"/>).
            </summary>
            <param name="source">The object to get the type of.</param>
            <returns>The type of the object.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.SetObjectData(`0,Xtensive.Core.Serialization.SerializationData)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.Xtensive#Core#Serialization#IObjectSerializer#CreateObject(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.Xtensive#Core#Serialization#IObjectSerializer#GetObjectData(Xtensive.Core.Serialization.SerializationData)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.Xtensive#Core#Serialization#IObjectSerializer#SetObjectData(Xtensive.Core.Serialization.SerializationData)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.GetValueSerializer``1">
            <exception cref="T:System.InvalidOperationException">Requested value serializer is not found.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerBase`1.#ctor(Xtensive.Core.Serialization.IObjectSerializerProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">The provider.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.Provider">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.BooleanSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Boolean"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.ByteSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Byte"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.CharSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Char"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.DecimalSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Decimal"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.DoubleSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Double"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.GuidSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Guid"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.Int16Serializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Int16"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.UInt16Serializer">
            <summary>
            Gets the value serializer for <see cref="T:System.UInt16"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.Int32Serializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Int32"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.UInt32Serializer">
            <summary>
            Gets the value serializer for <see cref="T:System.UInt32"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.Int64Serializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Int64"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.UInt64Serializer">
            <summary>
            Gets the value serializer for <see cref="T:System.UInt64"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.SingleSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Single"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.StringSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.String"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.TypeSerializer">
            <summary>
            Gets the value serializer for <see cref="T:System.Type"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.StringTokenSerializer">
            <summary>
            Gets the value serializer for <see cref="T:Xtensive.Core.Serialization.Implementation.Token`1"/> of <see cref="T:System.String"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.TypeTokenSerializer">
            <summary>
            Gets the value serializer for <see cref="T:Xtensive.Core.Serialization.Implementation.Token`1"/> of <see cref="T:System.Type"/> type.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializerBase`1.IsReferable">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Internals.ArraySerializer`1.#ctor(Xtensive.Core.Serialization.IObjectSerializerProvider)">
            <exception cref="T:System.InvalidOperationException">Similar value serializer exists,
            so it should be preferred.</exception>
        </member>
        <member name="T:Xtensive.Core.Serialization.SerializerConfiguration">
            <summary>
            Configuration for <see cref="!:SerializerBase&lt;TStream&gt;"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializerConfiguration.Validate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializerConfiguration.Clone(Xtensive.Core.Configuration.ConfigurationBase)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializerConfiguration.CreateClone">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializerConfiguration.Binder">
            <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder"/> that performs type lookups during deserialization.
            </summary>
            <value>The binder.</value>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializerConfiguration.AssemblyStyle">
            <summary>
            Gets the behavior of the formatter describing how to find and load assemblies.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializerConfiguration.TypeFormat">
            <summary>
            Gets the format in which type descriptions are stored in the serialized stream.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializerConfiguration.PreferNesting">
            <summary>
            Specifies when it's preferable to serialize the objects using 
            "depth traversal" rather then "wide traversal".
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.SerializerConfiguration.PreferAttributes">
            <summary>
            Specifies when it's preferable to serialize the values into 
            the attributes rather then elements 
            (works only if supported by the underlying <see cref="T:Xtensive.Core.Serialization.ISerializer"/>).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.SerializerProcessType">
            <summary>
            Enumerates possible <see cref="!:Serializer"/> process types.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.SerializerProcessType.None">
            <summary>
            Serializer neither serializes nor deserializes the graph now.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.SerializerProcessType.Serialization">
            <summary>
            <see cref="!:Serializer"/> is serializing the graph.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.SerializerProcessType.Deserialization">
            <summary>
            <see cref="!:Serializer"/> is deserializing the graph.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.ObjectSerializer`1">
            <summary>
            Provides delegates allowing to call serialization methods faster.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializer`1.CreateObject">
            <summary>
            Gets <see cref="M:Xtensive.Core.Serialization.IObjectSerializer`1.CreateObject(System.Type)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializer`1.GetObjectData">
            <summary>
            Gets <see cref="M:Xtensive.Core.Serialization.IObjectSerializer`1.GetObjectData(`0,`0,Xtensive.Core.Serialization.SerializationData)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializer`1.SetObjectData">
            <summary>
            Gets <see cref="M:Xtensive.Core.Serialization.IObjectSerializer`1.SetObjectData(`0,Xtensive.Core.Serialization.SerializationData)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializer`1.#ctor(Xtensive.Core.Serialization.IObjectSerializer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation">Serializer to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializer`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializer`1.Provider">
            <summary>
            Gets the provider this serializer is bound to.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ObjectSerializer`1.IsReferable">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Serialization.ObjectSerializerStruct`1">
            <summary>
            A struct providing faster access for key <see cref="T:Xtensive.Core.Serialization.ObjectSerializer`1"/> delegates.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Serialization.IObjectSerializer`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializerStruct`1.Serializer">
            <summary>
            Gets the underlying serializer for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializerStruct`1.GetObjectData">
            <summary>
            Populates the provided <see cref="T:Xtensive.Core.Serialization.SerializationData"/> with the data needed to serialize the object.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializerStruct`1.SetObjectData">
            <summary>
            Populates the object using the information in the <see cref="T:Xtensive.Core.Serialization.SerializationData"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ObjectSerializerStruct`1.CreateObject">
            <summary>
            Creates the object.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerStruct`1.op_Implicit(Xtensive.Core.Serialization.ObjectSerializer{`0})~Xtensive.Core.Serialization.ObjectSerializerStruct{`0}">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.Serialization.ObjectSerializer`1"/> to <see cref="T:Xtensive.Core.Serialization.ObjectSerializerStruct`1"/>.
            </summary>
            <param name="serializer">Serializer to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerStruct`1.#ctor(Xtensive.Core.Serialization.ObjectSerializer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="serializer"><see cref="T:Xtensive.Core.Serialization.ObjectSerializer`1"/> to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerStruct`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ObjectSerializerStruct`1.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.Reference">
            <summary>
            Reference to the object.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.IReference">
            <summary>
            Interface for representing reference to object.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.IReference.TryResolve(System.Object@)">
            <summary>
            Tries to resolve the reference.
            </summary>
            <param name="target">The object reference is pointing to.</param>
            <returns><see langword="True" /> if reference was resolved successfully;
            otherwise, <see langword="false" />.</returns>
        </member>
        <member name="P:Xtensive.Core.Serialization.IReference.Value">
            <summary>
            Gets the identifying string of this reference.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.IReference.IsCacheable">
            <summary>
            Indicates whether reference is the only possible reference to its target,
            so it must be cached.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.IReference.IsQueueable">
            <summary>
            Specify if it is necessary to put referencing object to <see cref="P:Xtensive.Core.Serialization.SerializationContext.SerializationQueue"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.Implementation.Reference.Null">
            <summary>
            Reference to <see langword="null" />.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Reference.TryResolve(System.Object@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Reference.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Reference.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">The <see cref="P:Xtensive.Core.Serialization.Implementation.Reference.Value"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Reference.#ctor(System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="target">The object this reference is pointing to.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.Reference.#ctor(System.String,System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">The <see cref="P:Xtensive.Core.Serialization.Implementation.Reference.Value"/> property value.</param>
            <param name="target">The object this reference is pointing to.</param>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Reference.Value">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Reference.IsCacheable">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Serialization.Implementation.Reference.IsQueueable">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Serialization.ValueSerializer`1">
            <summary>
            Provides delegates allowing to call serialization methods faster.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/> generic argument.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.Serialization.ValueSerializer`1.Serialize">
            <summary>
            Gets <see cref="!:IValueSerializer&lt;T&gt;.Serialize(T)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ValueSerializer`1.Deserialize">
            <summary>
            Gets <see cref="M:Xtensive.Core.Serialization.IValueSerializer`1.Deserialize(System.IO.Stream)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializer`1.#ctor(Xtensive.Core.Serialization.IValueSerializer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation">Serializer to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializer`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Serialization.ValueSerializer`1.Default">
            <summary>
            Gets default serializer for type <typeparamref name="T"/>
            (uses <see cref="!:ObjectSerializerProviderBase.Default"/>).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Serialization.ValueSerializer`1.Provider">
            <summary>
            Gets the provider this serializer is bound to.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.ValueSerializerStruct`1">
            <summary>
            A struct providing faster access for key <see cref="!:ValueSerializer&lt;T&gt;"/> delegates.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Serialization.IValueSerializer`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Serialization.ValueSerializerStruct`1.Default">
            <summary>
            Gets <see cref="T:Xtensive.Core.Serialization.ValueSerializerStruct`1"/> for <see cref="!:ValueSerializer&lt;T&gt;.Default"/> hasher.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ValueSerializerStruct`1.ValueSerializer">
            <summary>
            Gets the underlying serializer for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ValueSerializerStruct`1.Deserialize">
            <summary>
            Deserializes the data on the provided stream.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.ValueSerializerStruct`1.Serialize">
            <summary>
            Serializes an object to the provided stream.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerStruct`1.op_Implicit(Xtensive.Core.Serialization.ValueSerializer{`0})~Xtensive.Core.Serialization.ValueSerializerStruct{`0}">
            <summary>
            Implicit conversion of <see cref="!:ValueSerializer&lt;T&gt;"/> to <see cref="T:Xtensive.Core.Serialization.ValueSerializerStruct`1"/>.
            </summary>
            <param name="valueSerializer">Serializer to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerStruct`1.#ctor(Xtensive.Core.Serialization.ValueSerializer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="valueSerializer"><see cref="!:ValueSerializer&lt;T&gt;"/> to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerStruct`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Serialization.ValueSerializerStruct`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Serialization.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Serialization.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.ReferenceExtensions">
            <summary>
            <see cref="T:Xtensive.Core.Serialization.IReference"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.ReferenceExtensions.IsNull(Xtensive.Core.Serialization.IReference)">
            <summary>
            Determines whether the specified reference is pointing to <see langword="null" />.
            </summary>
            <param name="reference">The reference to check.</param>
            <returns>
            <see langword="True"/> if the specified reference is pointing to <see langword="null" />; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ReferenceExtensions.EnsureNotNull(Xtensive.Core.Serialization.IReference)">
            <summary>
            Ensures the reference is not <see cref="M:Xtensive.Core.Serialization.ReferenceExtensions.IsNull(Xtensive.Core.Serialization.IReference)"/>.
            </summary>
            <param name="reference">The reference to check.</param>
            <exception cref="T:System.InvalidOperationException"><see cref="M:Xtensive.Core.Serialization.ReferenceExtensions.IsNull(Xtensive.Core.Serialization.IReference)"/> returns <see langword="true"/> 
            for the specified reference.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.ReferenceExtensions.IsResolved(Xtensive.Core.Serialization.IReference)">
            <summary>
            Determines whether the specified reference is already resolved.
            </summary>
            <param name="reference">The reference to check.</param>
            <returns>
            <see langword="True"/> if the specified reference is already resolved; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.ReferenceExtensions.Resolve(Xtensive.Core.Serialization.IReference)">
            <summary>
            Resolves the specified reference.
            </summary>
            <param name="reference">The reference to resolve.</param>
            <returns>The result of resolution (reference target).</returns>
            <exception cref="T:System.InvalidOperationException">The reference can't be resolved yet.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.ReferenceExtensions.Resolve``1(Xtensive.Core.Serialization.IReference)">
            <summary>
            The typed version of <see cref="M:Xtensive.Core.Serialization.ReferenceExtensions.Resolve(Xtensive.Core.Serialization.IReference)"/>.
            </summary>
            <typeparam name="T">Type of the object to resolve the reference to.</typeparam>
            <param name="reference">The reference to resolve.</param>
            <returns>The <see cref="M:Xtensive.Core.Serialization.ReferenceExtensions.Resolve(Xtensive.Core.Serialization.IReference)"/> result.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Internals.ReferenceSerializer.CreateObject(System.Type)">
            <exception cref="T:System.ArgumentOutOfRangeException">Specified <paramref name="type"/> 
            is not supported by this serializer.</exception>
        </member>
        <member name="T:Xtensive.Core.Serialization.Implementation.ReferenceManager">
            <summary>
            Manages <see cref="T:Xtensive.Core.Serialization.IReference"/> objects during 
            serialization and deserialization.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.Define(Xtensive.Core.Serialization.IReference,System.Object)">
            <summary>
            Sets the object corresponding to the reference.
            </summary>
            <param name="reference">Reference to the object.</param>
            <param name="target">Object.</param>
            <exception cref="T:System.InvalidOperationException">Reference points to <see langword="null"/>, 
            or is already defined.</exception>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.TryResolve(Xtensive.Core.Serialization.IReference,System.Object@)">
            <summary>
            Tries to resolve the reference.
            </summary>
            <param name="reference">The reference to resolve.</param>
            <param name="target">The object reference is pointing to.</param>
            <returns>
            <see langword="True"/> if reference was resolved successfully;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.GetReference(System.Object)">
            <summary>
            Gets an existing reference to the specified object,
            or creates a new one.
            </summary>
            <param name="target">Object to get the reference to.</param>
            <returns>An existing or a new reference to the specified object.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.GetReference(System.Object,System.Boolean@)">
            <summary>
            Gets an existing reference to the specified object,
            or creates a new one.
            </summary>
            <param name="target">Object to get the reference to.</param>
            <param name="isNew">Indicates whether returned reference is a new one.</param>
            <returns>An existing or a new reference to the specified object.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.CreateReference(System.Object)">
            <summary>
            Creates the reference to the specified <paramref name="target"/>.
            </summary>
            <param name="target">The reference target.</param>
            <returns>Newly created reference to the <paramref name="target"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.GetNextReferenceValue">
            <summary>
            Gets the next reference <see cref="P:Xtensive.Core.Serialization.IReference.Value"/> property value.
            </summary>
            <returns>Next reference <see cref="P:Xtensive.Core.Serialization.IReference.Value"/> property value.</returns>
        </member>
        <member name="M:Xtensive.Core.Serialization.Implementation.ReferenceManager.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Serialization.SerializationScope">
            <summary>
            Serialization scope.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationScope.#ctor(Xtensive.Core.Serialization.SerializationContext)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="context">The context of this scope.</param>
        </member>
        <member name="M:Xtensive.Core.Serialization.SerializationScope.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.#ctor" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Threading.TaskExecutionException">
            <summary>
            Wrapping exception that contains a real exception thrown 
            during an execution of a task in <see cref="T:Xtensive.Core.Threading.AsyncProcessor"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.TaskExecutionException.#ctor(System.Exception)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="innerException">The exception thrown during a task's execution.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.TaskExecutionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Threading.TaskResult`1">
            <summary>
            Result of a task executed by <see cref="T:Xtensive.Core.Threading.AsyncProcessor"/>.
            </summary>
            <typeparam name="T">The type of a result.</typeparam>
        </member>
        <member name="P:Xtensive.Core.Threading.TaskResult`1.Result">
            <summary>
            Gets the result of a task.
            </summary>
            <exception cref="T:System.Exception">An <see cref="T:System.Exception"/>, if it was caught during the
            asynchronous task execution.</exception>
        </member>
        <member name="T:Xtensive.Core.Threading.AsyncProcessor">
            <summary>
            Executes provided delegates at separate thread.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.Execute``1(System.Func{``0},System.Boolean)">
            <summary>
            Enqueue the specified delegate for the execution at another thread 
            or executes it at the calling thread.
            </summary>
            <typeparam name="T">The result type.</typeparam>
            <param name="function">The delegate to be executed.</param>
            <param name="synchronously">if set to <see langword="true"/> 
            then the delegate is executed at the calling thread; otherwise it is queued 
            to be executed in <see cref="T:Xtensive.Core.Threading.AsyncProcessor"/>'s thread.</param>
            <returns>The <see cref="T:Xtensive.Core.Threading.TaskResult`1"/> that should be used to obtain 
            a result of delegate's execution.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.Execute(System.Action,System.Boolean)">
            <summary>
            Enqueue the specified delegate for the execution at another thread 
            or executes it at the calling thread.
            </summary>
            <param name="action">The delegate to be executed.</param>
            <param name="synchronously">if set to <see langword="true"/> 
            then the delegate is executed at the calling thread; otherwise it is queued 
            to be executed in <see cref="T:Xtensive.Core.Threading.AsyncProcessor"/>'s thread.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.ResetError">
            <summary>
            Resets an error.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.WaitForCompletion">
            <summary>
            Waits for the completion of all queued tasks.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.AsyncProcessor.Finalize">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Threading.AsyncProcessor.Error">
            <summary>
            Gets the exception intercepted during a task's execution.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Threading.AsyncProcessor.HasError">
            <summary>
            Gets a value indicating whether this instance has an intercepted exception.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Threading.AsyncProcessor.IsSynchronous">
            <summary>
            Gets or sets a value indicating whether this instance executes 
            a task at the thread that queued it (i.e. synchronously).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Threading.ThreadSafeCached`1">
            <summary>
            A structure caching a single value of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of the value to cache.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.GetValue(System.Func{`0})">
            <summary>
            Gets the cached value or generates it using specified <paramref name="generator"/> and caches.
            </summary>
            <param name="generator">The value generator.</param>
            <returns>Cached value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.GetValue``1(System.Func{``0,`0},``0)">
            <summary>
            Gets the cached value or generates it using specified <paramref name="generator"/> and caches.
            </summary>
            <typeparam name="T1">The type of the <paramref name="argument"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="generator">The value generator.</param>
            <param name="argument">The argument to pass to the <paramref name="generator"/>.</param>
            <returns>Cached value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.GetValue``2(System.Func{``0,``1,`0},``0,``1)">
            <summary>
            Gets the cached value or generates it using specified <paramref name="generator"/> and caches.
            </summary>
            <typeparam name="T1">The type of the <paramref name="argument1"/> to pass to the <paramref name="generator"/>.</typeparam>
            <typeparam name="T2">The type of the <paramref name="argument2"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="generator">The value generator.</param>
            <param name="argument1">The first argument to pass to the <paramref name="generator"/>.</param>
            <param name="argument2">The second argument to pass to the <paramref name="generator"/>.</param>
            <returns>Cached value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.Equals(Xtensive.Core.Threading.ThreadSafeCached{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.CompareTo(Xtensive.Core.Threading.ThreadSafeCached{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.Initialize(System.Object)">
            <summary>
            Initializes the cache. 
            This method should be invoked just once - before
            the first operation on this structure.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeCached`1.SyncRoot"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeCached`1.Create(System.Object)">
            <summary>
            Creates and initializes a new <see cref="T:Xtensive.Core.Threading.ThreadSafeCached`1"/>.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeCached`1.SyncRoot"/> property value.</param>
            <returns>New initialized <see cref="T:Xtensive.Core.Threading.ThreadSafeCached`1"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeCached`1.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeCached`1.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Conversion.AdvancedConverter`2">
            <summary>
            Provides delegates allowing to call conversion methods faster.
            </summary>
            <typeparam name="TFrom">Type of the first <see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/> generic argument.</typeparam>
            <typeparam name="TTo">Type of the second <see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/> generic argument.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverter`2.Provider">
            <summary>
            Gets the provider underlying converter is associated with.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverter`2.Convert">
            <summary>
            Gets <see cref="M:Xtensive.Core.Conversion.IAdvancedConverter`2.Convert(`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverter`2.IsRough">
            <summary>
            Gets <see cref="P:Xtensive.Core.Conversion.IAdvancedConverter`2.IsRough"/> value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverter`2.#ctor(Xtensive.Core.Conversion.IAdvancedConverter{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation">Advanced converter to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverter`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="P:Xtensive.Core.Conversion.AdvancedConverter`2.Default">
            <summary>
            Gets default advanced converter for types <typeparamref name="TFrom"/> and <typeparamref name="TTo"/>.
            (uses <see cref="P:Xtensive.Core.Conversion.AdvancedConverterProvider.Default"/> <see cref="T:Xtensive.Core.Conversion.AdvancedConverter`2"/>).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Conversion.AdvancedConverterStruct`2">
            <summary>
            A struct providing faster access for key <see cref="T:Xtensive.Core.Conversion.AdvancedConverter`2"/> delegates.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverterStruct`2.Default">
            <summary>
            Gets <see cref="T:Xtensive.Core.Conversion.AdvancedConverterStruct`2"/> for <see cref="P:Xtensive.Core.Conversion.AdvancedConverter`2.Default"/> hasher.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverterStruct`2.AdvancedConverter">
            <summary>
            Gets the underlying converter for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverterStruct`2.Convert">
            <summary>
            Gets <see cref="M:Xtensive.Core.Conversion.IAdvancedConverter`2.Convert(`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverterStruct`2.IsRough">
            <summary>
            Gets <see cref="P:Xtensive.Core.Conversion.IAdvancedConverter`2.IsRough"/> value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterStruct`2.op_Implicit(Xtensive.Core.Conversion.AdvancedConverter{`0,`1})~Xtensive.Core.Conversion.AdvancedConverterStruct{`0,`1}">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.Conversion.AdvancedConverter`2"/> to <see cref="T:Xtensive.Core.Conversion.AdvancedConverterStruct`2"/>.
            </summary>
            <param name="advancedConverter">Converter to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterStruct`2.#ctor(Xtensive.Core.Conversion.AdvancedConverter{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="advancedConverter">Converter to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterStruct`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterStruct`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Conversion.WrappingAdvancedConverter`4">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/>s.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.WrappingAdvancedConverter`4.BaseConverter">
            <summary>
            Converter delegates for <typeparamref name="TFromBase"/>-<typeparamref name="TToBase"/> types.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.WrappingAdvancedConverter`4.Convert(`0)">
            <summary>
             Converts specified value of <typeparamref name="TFrom"/> type
             to <typeparamref name="TTo"/> type.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>Converted value.</returns>
        </member>
        <member name="M:Xtensive.Core.Conversion.WrappingAdvancedConverter`4.#ctor(Xtensive.Core.Conversion.IAdvancedConverterProvider)">
            <summary>
            Creates new instance of <see cref="T:Xtensive.Core.Conversion.WrappingAdvancedConverter`4"/>.
            </summary>
            <param name="provider">Converter provider this converter is bound to.</param>
        </member>
        <member name="P:Xtensive.Core.Conversion.WrappingAdvancedConverter`4.IsRough">
            <summary>
            Gets <see langword="true"/> if converter is rough, otherwise gets <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.NullableForwardAdvancedConverter`2.Convert(System.Nullable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.NullableNullableAdvancedConverter`2.Convert(System.Nullable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.NullableReverseAdvancedConverter`2.Convert(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Hashing.WrappingHasher`2">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Hashing.IHasher`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate <see cref="T:System.Int64"/> hashes for.</typeparam>
            <typeparam name="TBase">Base (wrapped) type.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Hashing.HasherBase`1">
            <summary>
            Base class for any <see cref="T:Xtensive.Core.Hashing.IHasher`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate <see cref="T:System.Int64"/> hashes for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Hashing.IHasher`1">
            <summary>
            Calculates <see cref="T:System.Int64"/> hashes.
            </summary>
            <typeparam name="T">Type of object to calculate hash for.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Hashing.IHasherBase">
            <summary>
            Tagging interface for any hasher supported by
            <see cref="T:Xtensive.Core.Hashing.HasherProvider"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.IHasherBase.GetInstanceHash(System.Object)">
            <summary>
            Calculates hash.
            </summary>
            <param name="value">Object to calculate hash to.</param>
            <returns>Hash.</returns>
        </member>
        <member name="P:Xtensive.Core.Hashing.IHasherBase.Provider">
            <summary>
            Gets the provider this hasher is associated with.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.IHasher`1.GetHash(`0)">
            <summary>
            Calculates hash.
            </summary>
            <param name="value">Object to calculate hash to.</param>
            <returns>Hash.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.IHasher`1.GetHashes(`0,System.Int32)">
            <summary>
            Calculates <paramref name="count"/> of different hashes at once.
            </summary>
            <param name="value">Object to calculate hashes for.</param>
            <param name="count">Count of hashes to calculate.</param>
            <returns>Array of <paramref name="count"/> hashes.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherBase`1.GetInstanceHash(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherBase`1.GetHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherBase`1.GetHashes(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherBase`1.#ctor(Xtensive.Core.Hashing.IHasherProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Hasher provider this hasher is bound to.</param>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherBase`1.OnDeserialization(System.Object)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Hashing.HasherBase`1.Provider">
            <inheritdoc/>
        </member>
        <member name="F:Xtensive.Core.Hashing.WrappingHasher`2.BaseHasher">
            <summary>
            Hasher for base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.WrappingHasher`2.#ctor(Xtensive.Core.Hashing.IHasherProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Hashing provider this hasher is bound to.</param>
        </member>
        <member name="M:Xtensive.Core.Hashing.EnumHasher`2.GetHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.EnumHasher`2.GetHashes(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.ExceptionAggregator">
            <summary>
            Provides exception aggregation support.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute(System.Action)">
            <summary>
            Executes the specified action catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <param name="action">The action to execute.</param>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``1(System.Action{``0},``0)">
            <summary>
            Executes the specified action catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="T">The type of action argument.</typeparam>
            <param name="action">The action to execute.</param>
            <param name="argument">The action argument value.</param>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Executes the specified action catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="T1">The type of the 1st action argument.</typeparam>
            <typeparam name="T2">The type of the 2nd action argument.</typeparam>
            <param name="action">The action to execute.</param>
            <param name="argument1">The 1st action argument value.</param>
            <param name="argument2">The 2nd action argument value.</param>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Executes the specified action catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="T1">The type of the 1st action argument.</typeparam>
            <typeparam name="T2">The type of the 2nd action argument.</typeparam>
            <typeparam name="T3">The type of the 3rd action argument.</typeparam>
            <param name="action">The action to execute.</param>
            <param name="argument1">The 1st action argument value.</param>
            <param name="argument2">The 2nd action argument value.</param>
            <param name="argument3">The 3rd action argument value.</param>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``1(System.Func{``0})">
            <summary>
            Executes the specified function catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="TResult">The type of function result.</typeparam>
            <param name="function">The function to execute.</param>
            <returns>Function execution result, if no exception was caught;
            otherwise, <see langword="default(TResult)"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``2(System.Func{``0,``1},``0)">
            <summary>
            Executes the specified function catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="T">The type of the function argument.</typeparam>
            <typeparam name="TResult">The type of function result.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument">The function argument value.</param>
            <returns>Function execution result, if no exception was caught;
            otherwise, <see langword="default(TResult)"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``3(System.Func{``0,``1,``2},``0,``1)">
            <summary>
            Executes the specified function catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="T1">The type of the 1st function argument.</typeparam>
            <typeparam name="T2">The type of the 2nd function argument.</typeparam>
            <typeparam name="TResult">The type of function result.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument1">The 1st function argument value.</param>
            <param name="argument2">The 2nd function argument value.</param>
            <returns>Function execution result, if no exception was caught;
            otherwise, <see langword="default(TResult)"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Execute``4(System.Func{``0,``1,``2,``3},``0,``1,``2)">
            <summary>
            Executes the specified function catching all the exceptions from it,
            adding it to internal list of caught exceptions and
            and passing it to <see cref="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler"/> handler.
            </summary>
            <typeparam name="T1">The type of the 1st function argument.</typeparam>
            <typeparam name="T2">The type of the 2nd function argument.</typeparam>
            <typeparam name="T3">The type of the 3rd function argument.</typeparam>
            <typeparam name="TResult">The type of function result.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument1">The 1st function argument value.</param>
            <param name="argument2">The 2nd function argument value.</param>
            <param name="argument3">The 3rd function argument value.</param>
            <returns>Function execution result, if no exception was caught;
            otherwise, <see langword="default(TResult)"/>.</returns>
            <exception cref="T:System.ObjectDisposedException">Aggregator is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.HandleException(System.Exception)">
            <summary>
            Invoked on any exception caught by <see cref="M:Xtensive.Core.ExceptionAggregator.Execute(System.Action)"/> methods.
            </summary>
            <param name="exception">The caught exception.</param>
            <remarks>
            If this method throws an exception, it won't be caught.
            I.e. it will throw "through" any of <see cref="M:Xtensive.Core.ExceptionAggregator.Execute(System.Action)"/> methods.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="exceptionMessage">The message of <see cref="T:Xtensive.Core.AggregateException"/>.</param>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.#ctor(System.Action{System.Exception},System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="exceptionHandler">The exception handler.</param>
            <param name="exceptionMessage">The message of <see cref="T:Xtensive.Core.AggregateException"/>.</param>
        </member>
        <member name="M:Xtensive.Core.ExceptionAggregator.Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            <exception cref="T:Xtensive.Core.AggregateException">Thrown if at least one exception was caught 
            by <see cref="M:Xtensive.Core.ExceptionAggregator.Execute(System.Action)"/> methods.</exception>
        </member>
        <member name="P:Xtensive.Core.ExceptionAggregator.ExceptionHandler">
            <summary>
            Gets or sets the exception handler.
            </summary>
        </member>
        <member name="P:Xtensive.Core.ExceptionAggregator.Count">
            <summary>
            Gets the number of caught exceptions.
            </summary>
        </member>
        <member name="T:Xtensive.Core.LockableExtensions">
            <summary>
            <see cref="T:Xtensive.Core.ILockable"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.LockableExtensions.LockSafely(Xtensive.Core.ILockable)">
            <summary>
            Locks the instance (non-recursively).
            </summary>
            <param name="lockable">Lockable object to lock. Can be <see langword="null"/>.</param>
        </member>
        <member name="M:Xtensive.Core.LockableExtensions.LockSafely(Xtensive.Core.ILockable,System.Boolean)">
            <summary>
            Locks the instance and (possible) all dependent objects.
            </summary>
            <param name="lockable">Lockable object to lock. Can be <see langword="null"/>.</param>
            <param name="recursive"><see langword="True"/> if all dependent objects should be locked as well.</param>
        </member>
        <member name="M:Xtensive.Core.LockableExtensions.EnsureNotLocked(Xtensive.Core.ILockable)">
            <summary>
            Ensures <paramref name="lockable"/> is not locked (see <see cref="M:Xtensive.Core.ILockable.Lock"/>) yet.
            </summary>
            <param name="lockable">Lockable object to check.</param>
            <exception cref="T:Xtensive.Core.InstanceIsLockedException">Specified instance is locked.</exception>
        </member>
        <member name="M:Xtensive.Core.LockableExtensions.CloneIfNotLocked(Xtensive.Core.ILockable)">
            <summary>
            Clones <paramref name="lockable"/> if it is not locked
            otherwise returns <paramref name="lockable"/> itself.
            </summary>
            <param name="lockable"><see cref="T:Xtensive.Core.ILockable"/> to clone.</param>
            <returns><paramref name="lockable"/> if it is locked;
            clone of <paramref name="lockable"/> if it is not locked and
            is <see cref="T:System.ICloneable"/>;
            <see langword="null"/> otherwise.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Helpers.SafeLeasedAccessor`1">
            <summary>
            <inheritdoc />
            Has finalizer (i.e. this type is safer then its base).
            </summary>
            <typeparam name="T"><inheritdoc/></typeparam>
        </member>
        <member name="T:Xtensive.Core.Helpers.LeasedAccessor`1">
            <summary>
            Provides access to some <see cref="P:Xtensive.Core.Helpers.LeasedAccessor`1.Leased"/> object of type <typeparamref name="T"/>
            Much like <see cref="T:Xtensive.Core.Disposing.Disposable`1"/>, but provides 
            access to its parameter via <see cref="P:Xtensive.Core.Helpers.LeasedAccessor`1.Leased"/> property.
            </summary>
            <typeparam name="T">The type of <see cref="P:Xtensive.Core.Helpers.LeasedAccessor`1.Leased"/> object.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Helpers.LeasedAccessor`1.#ctor(`0,System.Action{System.Boolean,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="leased">Initial <see cref="P:Xtensive.Core.Helpers.LeasedAccessor`1.Leased"/> property value.</param>
            <param name="onDispose">Action to execute on disposal.</param>
        </member>
        <member name="M:Xtensive.Core.Helpers.LeasedAccessor`1.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.LeasedAccessor`1.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Helpers.LeasedAccessor`1.Leased">
            <summary>
            Provides access to actually leased object.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeLeasedAccessor`1.#ctor(`0,System.Action{System.Boolean,`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeLeasedAccessor`1.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Helpers.SafeDisposable`2">
            <summary>
            <inheritdoc />
            Has finalizer (i.e. this type is safer then its base).
            </summary>
            <typeparam name="T1"><inheritdoc/></typeparam>
            <typeparam name="T2"><inheritdoc/></typeparam>
        </member>
        <member name="T:Xtensive.Core.Disposing.Disposable`2">
            <summary>
            A disposable type allowing to execute custom
            <see cref="T:System.Action"/> on its disposal.
            Allows to store and pass two parameters to this action.
            </summary>
            <typeparam name="T1">First parameter type.</typeparam>
            <typeparam name="T2">Second parameter type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`2.op_BitwiseAnd(Xtensive.Core.Disposing.Disposable{`0,`1},System.IDisposable)">
            <summary>
            Joins the <see cref="T:Xtensive.Core.Disposing.Disposable`2"/> and <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="first">The first disposable to join.</param>
            <param name="second">The second disposable to join.</param>
            <returns>New <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal</returns>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`2.#ctor(`0,`1,System.Action{System.Boolean,`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="parameter1">First parameter to pass to the <paramref name="onDispose"/> action.</param>
            <param name="parameter2">Second parameter to pass to the <paramref name="onDispose"/> action.</param>
            <param name="onDispose">Action to execute on disposal.</param>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`2.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`2.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeDisposable`2.#ctor(`0,`1,System.Action{System.Boolean,`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeDisposable`2.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Helpers.SafeDisposable`1">
            <summary>
            <inheritdoc />
            Has finalizer (i.e. this type is safer then its base).
            </summary>
            <typeparam name="T"><inheritdoc/></typeparam>
        </member>
        <member name="T:Xtensive.Core.Disposing.Disposable`1">
            <summary>
            A disposable type allowing to execute custom
            <see cref="T:System.Action"/> on its disposal.
            Allows to store and pass one parameter to this action.
            </summary>
            <typeparam name="T">Parameter type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`1.op_BitwiseAnd(Xtensive.Core.Disposing.Disposable{`0},System.IDisposable)">
            <summary>
            Joins the <see cref="T:Xtensive.Core.Disposing.Disposable`1"/> and <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="first">The first disposable to join.</param>
            <param name="second">The second disposable to join.</param>
            <returns>New <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal</returns>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`1.#ctor(`0,System.Action{System.Boolean,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="parameter">Parameter to pass to the <paramref name="onDispose"/> action.</param>
            <param name="onDispose">Action to execute on disposal.</param>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`1.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable`1.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeDisposable`1.#ctor(`0,System.Action{System.Boolean,`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeDisposable`1.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Helpers.SafeDisposable">
            <summary>
            <inheritdoc />
            Has finalizer (i.e. this type is safer then its base).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Disposing.Disposable">
            <summary>
            A disposable type allowing to execute custom
            <see cref="T:System.Action"/> on its disposal.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable.op_BitwiseAnd(Xtensive.Core.Disposing.Disposable,System.IDisposable)">
            <summary>
            Joins the <see cref="T:Xtensive.Core.Disposing.Disposable"/> and <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="first">The first disposable to join.</param>
            <param name="second">The second disposable to join.</param>
            <returns>New <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal</returns>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable.#ctor(System.Action{System.Boolean})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="onDispose">Action to execute on disposal.</param>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable.Dispose(System.Boolean)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Disposing.Disposable.Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeDisposable.#ctor(System.Action{System.Boolean})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Helpers.SafeDisposable.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Helpers.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Helpers.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.DisposableExtensions">
            <summary>
            <see cref="T:System.IDisposable"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.DisposableExtensions.Join(System.IDisposable,System.IDisposable)">
            <summary>
            Joins the specified disposable objects by returning
            a single <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal.
            </summary>
            <param name="disposable">The first disposable.</param>
            <param name="joinWith">The second disposable.</param>
            <returns>New <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal</returns>
        </member>
        <member name="M:Xtensive.Core.DisposableExtensions.DisposeSafely(System.IDisposable)">
            <summary>
            Safely disposes an <see cref="T:System.IDisposable"/> object.
            </summary>
            <param name="disposable">Object to dispose (can be <see langword="null"/>).</param>
        </member>
        <member name="M:Xtensive.Core.DisposableExtensions.DisposeSafely(System.IDisposable,Xtensive.Core.Diagnostics.ILog,System.String)">
            <summary>
            Safely disposes an <see cref="T:System.IDisposable"/> object.
            </summary>
            <param name="disposable">Object to dispose (can be <see langword="null"/>).</param>
            <param name="log">Log to write errors to.</param>
            <param name="disposerName">Name (or type name) of the object that invoked this method.</param>
        </member>
        <member name="M:Xtensive.Core.DisposableExtensions.DisposeSafely(System.Collections.Generic.IEnumerable{System.IDisposable},Xtensive.Core.Diagnostics.ILog,System.String)">
            <summary>
            Safely disposes a set of <see cref="T:System.IDisposable"/> items.
            </summary>
            <param name="items">Items to dispose (can be <see langword="null"/>).</param>
            <param name="log">Log to write errors to.</param>
            <param name="disposerName">Name (or type name) of the object that invoked this method.</param>
        </member>
        <member name="M:Xtensive.Core.DisposableExtensions.CheckItemDisposing(Xtensive.Core.Disposing.IDisposableContainer)">
            <summary>
            Checks ability of the item to be disposed.
            </summary>
            <param name="container">The disposable container that contains the item.</param>
            <returns>
            <see langword="true"/> when <paramref name="container"/> has <see cref="P:Xtensive.Core.Disposing.IDisposableContainer.DisposingState"/> is <see cref="F:Xtensive.Core.Disposing.DisposingState.Disposing"/>;
            <see langword="false"/> when <paramref name="container"/> has <see cref="P:Xtensive.Core.Disposing.IDisposableContainer.DisposingState"/> is <see cref="F:Xtensive.Core.Disposing.DisposingState.Disposed"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">The <paramref name="container"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Unable to dispose the item when <paramref name="container"/>'s <see cref="P:Xtensive.Core.Disposing.IDisposableContainer.DisposingState"/> is <see cref="F:Xtensive.Core.Disposing.DisposingState.None"/>.</exception>
        </member>
        <member name="T:Xtensive.Core.HasServicesExtensions">
            <summary>
            <see cref="T:Xtensive.Core.IHasServices"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.HasServicesExtensions.GetService``1(Xtensive.Core.IHasServices,System.Boolean)">
            <summary>
            Gets the service of specified type <typeparamref name="T"/>;
            throws <see cref="T:System.InvalidOperationException"/>, if there is no such service.
            </summary>
            <typeparam name="T">The type of service to get.</typeparam>
            <param name="serviceProvider">The service provider to query for the service.</param>
            <param name="failIfNone">If set to <see langword="true"/>, an exception will be thrown 
            if there is no requested service.</param>
            <returns>Requested service;
            <see langword="null"/>, if <paramref name="failIfNone"/>==<see langword="false"/> 
            and there is no requested service.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="failIfNone"/>==<see langword="true"/> 
            and there is no requested service.</exception>
        </member>
        <member name="M:Xtensive.Core.HasServicesExtensions.GetService(Xtensive.Core.IHasServices,System.Type,System.Boolean)">
            <summary>
            Gets the service of the specified <paramref name="serviceType"/>;
            throws <see cref="T:System.InvalidOperationException"/>, if there is no such service.
            </summary>
            <param name="serviceProvider">The service provider to query for the service.</param>
            <param name="serviceType">Type of the service to get.</param>
            <param name="failIfNone">If set to <see langword="true"/>, an exception will be thrown 
            if there is no requested service.</param>
            <returns>Requested service;
            <see langword="null"/>, if <paramref name="failIfNone"/>==<see langword="false"/> 
            and there is no requested service.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="failIfNone"/>==<see langword="true"/> 
            and there is no requested service.</exception>
        </member>
        <member name="M:Xtensive.Core.HasServicesExtensions.GetService(Xtensive.Core.IHasServices,System.Type)">
            <summary>
            Gets the service of the specified <paramref name="serviceType"/>.
            </summary>
            <param name="serviceProvider">The service provider to query for the service.</param>
            <param name="serviceType">Type of the service to get.</param>
            <returns>The service of specified type.</returns>
        </member>
        <member name="T:Xtensive.Core.StringExtensions">
            <summary>
            <see cref="T:System.String"/> related extension methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.StringExtensions.FormatWith(System.String,System.IFormatProvider,System.Object[])" -->
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.StringExtensions.FormatWith(System.String,System.Object[])" -->
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.StringExtensions.FormatWith(System.String,System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.StringExtensions.FormatWith(System.String,System.Object,System.Object)" -->
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.StringExtensions.FormatWith(System.String,System.Object,System.Object,System.Object)" -->
        <member name="M:Xtensive.Core.StringExtensions.TryCutSuffix(System.String,System.String)">
            <summary>
            Cuts the specified <paramref name="suffix"/> from <paramref name="value"/>.
            </summary>
            <param name="value">The original string value.</param>
            <param name="suffix">The suffix to cut.</param>
            <returns>String without <paramref name="suffix"/> if it was found; 
            otherwise, original <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.TryCutSuffix(System.String,System.String,System.Boolean@)">
            <summary>
            Cuts the specified <paramref name="suffix"/> from <paramref name="value"/>.
            </summary>
            <param name="value">The original string value.</param>
            <param name="suffix">The suffix to cut.</param>
            <param name="isCut">Upon return contains <see langword="true"/>
            if suffix was cut, otherwise <see langword="false"/></param>
            <returns>String without <paramref name="suffix"/> if it was found; 
            otherwise, original <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.TryCutPrefix(System.String,System.String)">
            <summary>
            Cuts the specified <paramref name="prefix"/> from <paramref name="value"/>.
            </summary>
            <param name="value">The original string value.</param>
            <param name="prefix">The prefix to cut.</param>
            <returns>String without <paramref name="prefix"/> if it was found; 
            otherwise, original <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.TryCutPrefix(System.String,System.String,System.Boolean@)">
            <summary>
            Cuts the specified <paramref name="prefix"/> from <paramref name="value"/>.
            </summary>
            <param name="value">The original string value.</param>
            <param name="prefix">The prefix to cut.</param>
            <param name="isCut">Upon return contains <see langword="true"/>
            if prefix was cut, otherwise <see langword="false"/></param>
            <returns>String without <paramref name="prefix"/> if it was found; 
            otherwise, original <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.Indent(System.String,System.Int32)">
            <summary>
            Indents the specified string value.
            </summary>
            <param name="value">The value to indent.</param>
            <param name="indentSize">Size of the indent (in space characters).</param>
            <returns>Indented <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.Indent(System.String,System.Int32,System.Boolean)">
            <summary>
            Indents the specified string value.
            </summary>
            <param name="value">The value to indent.</param>
            <param name="indentSize">Size of the indent (in space characters).</param>
            <param name="indentFirstLine">If set to <see langword="true"/>, first line must be indented;
            otherwise, <see langword="false"/>.</param>
            <returns>Indented <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.LessThan(System.String,System.String)">
            <summary>
            Determines whether <paramref name="x"/> <see cref="T:System.String"/> is less than <paramref name="y"/> <see cref="T:System.String"/>.
            </summary>
            <param name="x">The first argument.</param>
            <param name="y">The second argument.</param>
            <returns>
            <see langword="true"/> if <paramref name="x"/> is less than <paramref name="y"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.LessThanOrEqual(System.String,System.String)">
            <summary>
            Determines whether <paramref name="x"/> <see cref="T:System.String"/> is less than or equals to <paramref name="y"/> <see cref="T:System.String"/>.
            </summary>
            <param name="x">The first argument.</param>
            <param name="y">The second argument.</param>
            <returns>
            <see langword="true"/> if <paramref name="x"/> is less than or equals to <paramref name="y"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.GreaterThan(System.String,System.String)">
            <summary>
            Determines whether <paramref name="x"/> <see cref="T:System.String"/> is greater than <paramref name="y"/> <see cref="T:System.String"/>.
            </summary>
            <param name="x">The first argument.</param>
            <param name="y">The second argument.</param>
            <returns>
            <see langword="true"/> if <paramref name="x"/> is greater than <paramref name="y"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.GreaterThanOrEqual(System.String,System.String)">
            <summary>
            Determines whether <paramref name="x"/> <see cref="T:System.String"/> is less than <paramref name="y"/> <see cref="T:System.String"/>.
            </summary>
            <param name="x">The first argument.</param>
            <param name="y">The second argument.</param>
            <returns>
            <see langword="true"/> if <paramref name="x"/> is less than <paramref name="y"/>; otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.RevertibleJoin(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)">
            <summary>
            Converts the <paramref name="source"/> to a separated string
            using "escape separator" syntax to encode inner separators in
            <paramref name="source"/> parts.
            </summary>
            <param name="source">The sequence of strings to join.</param>
            <param name="escape">The escape character.</param>
            <param name="delimiter">The delimiter character.</param>
            <returns>
            Comma-separated string of all the items
            from <paramref name="source"/>.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="escape"/>==<paramref name="delimiter"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.RevertibleSplit(System.String,System.Char,System.Char)">
            <summary>
            Reverts the result of <see cref="M:Xtensive.Core.StringExtensions.RevertibleJoin(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)"/>.
            </summary>
            <param name="source">The source string to split.</param>
            <param name="escape">The escape character.</param>
            <param name="delimiter">The delimiter character.</param>
            <returns>
            The array of values that were previously joined
            by <see cref="M:Xtensive.Core.StringExtensions.RevertibleJoin(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)"/>.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="escape"/>==<paramref name="delimiter"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.RevertibleSplitFirstAndTail(System.String,System.Char,System.Char)">
            <summary>
            Reverts the result of <see cref="M:Xtensive.Core.StringExtensions.RevertibleJoin(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)"/>.
            </summary>
            <param name="source">The source string to split.</param>
            <param name="escape">The escape character.</param>
            <param name="delimiter">The delimiter character.</param>
            <returns>
            The array of values that were previously joined
            by <see cref="M:Xtensive.Core.StringExtensions.RevertibleJoin(System.Collections.Generic.IEnumerable{System.String},System.Char,System.Char)"/>.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="escape"/>==<paramref name="delimiter"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.Escape(System.String,System.Char,System.Char[])">
            <summary>
            Escapes the specified source string.
            </summary>
            <param name="source">The source.</param>
            <param name="escape">The escape char.</param>
            <param name="escapedChars">Chars to escape.</param>
        </member>
        <member name="M:Xtensive.Core.StringExtensions.Unescape(System.String,System.Char)">
            <summary>
            Unescapes the specified source string.
            </summary>
            <param name="source">The source.</param>
            <param name="escape">The escape char.</param>
        </member>
        <member name="T:Xtensive.Core.IoC.IFinalAssociate">
            <summary>
            Tagging interface marking final associates in the inheritance hierarchy.
            See <see cref="T:Xtensive.Core.IoC.AssociateProvider"/> for further information.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IHasExtensions">
            <summary>
            Describes an object having <see cref="P:Xtensive.Core.IHasExtensions.Extensions"/> property.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHasExtensions.Extensions">
            <summary>
            Gets the collection of extensions bound to the current instance.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate">
            <summary>
            Class documentation template.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)">
            <summary>
            Implements the equality operator.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of the comparison for equality.</returns>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)">
            <summary>
            Implements the inequality operator.
            </summary>
            <param name="left">The left operand.</param>
            <param name="right">The right operand.</param>
            <returns>The result of the comparison for inequality.</returns>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Configure">
            <summary>
            Configures a new instance of the <see cref="T:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate"/> class.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Initialize">
            <summary>
            Initializes a new instance of the <see cref="T:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate"/> class.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate"/> class.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate"/> is reclaimed by garbage collection.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose">
            <summary>
            Performs the tasks associated with freeing, releasing, or resetting unmanaged resources
            or associated <see cref="T:System.IDisposable"/> objects.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.TypeInitializer">
            <summary>
            Initializes the <see cref="T:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate"/> type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate">
            <summary>
            Disposable class documentation template.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor">
            <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate"/> is reclaimed by garbage collection.
            </summary>
            <remarks>
            <para id="About">
            This method always forwards it job to <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)"/> method;
            its "disposing" parameter gets <see langword="false"/> value.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose">
            <summary>
            Performs the tasks associated with freeing, releasing, or resetting unmanaged resources
            or associated <see cref="T:System.IDisposable"/> objects.
            </summary>
            <remarks>
            <para id="About">
            This method always forwards it job to <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)"/> method;
            its "disposing" parameter gets <see langword="true"/> value.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)">
            <summary>
            Performs the tasks associated with freeing, releasing, or resetting unmanaged resources
            or associated <see cref="T:System.IDisposable"/> objects.
            </summary>
            <param name="disposing">Indicates whether this method was invoked by <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose"/>,
            or by the finalizer.</param>
        </member>
        <member name="T:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate">
            <summary>
            A class with required parameterless constructor documentation template.
            </summary>
            <remarks>
            <para id="Ctor">Any descendant of this type must have 
            a parameterless constructor.</para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.ParameterlessCtorClassDocTemplate.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.#ctor"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.IO.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.IO.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IO.StreamProvider">
            <summary>
            Provides read or write of streams for a single file.
            <see langword="Thread-safe." />
            </summary>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.GetStreamAccessor(Xtensive.Core.LockType)">
            <summary>
            Gets the stream from pool or creates a new one, but wrapped into <see cref="T:Xtensive.Core.Helpers.LeasedAccessor`1"/>.
            So this method acts as <see cref="M:Xtensive.Core.IO.StreamProvider.GetStream(Xtensive.Core.LockType)"/>, but its result can be used within <see langword="using"/> language construction.
            </summary>
            <param name="lockType">Type of lock.</param>
            <returns>A <see cref="T:Xtensive.Core.Helpers.LeasedAccessor`1"/> providing <see cref="T:System.IO.Stream"/> allowing to access the file.</returns>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.GetStream">
            <summary>
            Gets the stream from pool or creates a new one using <see cref="F:Xtensive.Core.LockType.Shared"/> lock type.
            </summary>
            <returns>Stream allowing to access the file.</returns>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.GetStream(Xtensive.Core.LockType)">
            <summary>
            Gets the stream from pool or creates a new one.
            </summary>
            <param name="lockType">Type of lock.</param>
            <returns>Stream allowing to access the file.</returns>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.ReleaseStream(System.IO.Stream)">
            <summary>
            Releases the stream previously acquired by <see cref="M:Xtensive.Core.IO.StreamProvider.GetStream"/> back to the pool.
            </summary>
            <param name="stream">Stream to release.</param>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.EnsureNotDisposed">
            <summary>
            Ensures instance is not disposed.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Thrown when object is already disposed.</exception>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.CreateStream">
            <summary>
            Creates a new stream.
            </summary>
            <returns>Newly created stream.</returns>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.ResetStream(System.IO.Stream)">
            <summary>
            Resets the stream state before returning it to pool.
            </summary>
            <param name="stream">Stream to reset.</param>
            <returns>An exception, if it was thrown during reset procedure; 
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="fileName">Name of the file to provide streams for.</param>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.#ctor(System.String,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="fileName">Name of the file to provide streams for.</param>
            <param name="bufferSize">Size of the buffer of the underlying streams.</param>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="fileName">Name of the file to provide streams for.</param>
            <param name="poolCapacity">Stream pool capacity.</param>
            <param name="bufferSize">Size of the buffer of the underlying streams.</param>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.Finalize">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IO.StreamProvider.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.IO.StreamProvider.FileName">
            <summary>
            Gets the name of the file to provide streams for.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IO.StreamProvider.BufferSize">
            <summary>
            Gets the size of the buffer used by the underlying streams.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IO.StreamProvider.FileExists">
            <summary>
            Indicates whether file with <see cref="P:Xtensive.Core.IO.StreamProvider.FileName"/> exists or not.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.AttributeHelper">
            <summary>
            <see cref="T:System.Attribute"/> related helper \ extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.AttributeHelper.GetAttributes``1(System.Reflection.MemberInfo,Xtensive.Core.Reflection.AttributeSearchOptions)">
            <summary>
            A shortcut to <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)"/> method.
            </summary>
            <typeparam name="TAttribute">The type of attributes to get.</typeparam>
            <param name="member">Member to get attributes of.</param>
            <param name="options">Attribute search options.</param>
            <returns>An array of attributes of specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.AttributeHelper.GetAttribute``1(System.Reflection.MemberInfo,Xtensive.Core.Reflection.AttributeSearchOptions)">
            <summary>
            A version of <see cref="M:Xtensive.Core.Reflection.AttributeHelper.GetAttributes``1(System.Reflection.MemberInfo,Xtensive.Core.Reflection.AttributeSearchOptions)"/> 
            returning just one attribute.
            </summary>
            <typeparam name="TAttribute">The type of attribute to get.</typeparam>
            <param name="member">Member to get attribute of.</param>
            <param name="options">Attribute search options.</param>
            <returns>An attribute of specified type;
            <see langword="null"/>, if there is no such attribute;
            throws <see cref="T:System.InvalidOperationException"/>, if there is more then one attribute of specified type found.
            </returns>
            <exception cref="T:System.InvalidOperationException">Thrown if there is more then one attribute of specified type found.</exception>
        </member>
        <member name="T:Xtensive.Core.Reflection.MemberHelper">
            <summary>
            <see cref="T:System.Reflection.MemberInfo"/> related helper \ extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetBindingFlags(System.Reflection.MemberInfo)">
            <summary>
            Gets the binding flags for the specified member.
            </summary>
            <param name="member">The member to get binding flags for.</param>
            <returns>Binding flags for the specified member.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetBaseMember(System.Reflection.MemberInfo)">
            <summary>
            Gets the base member for the specified <paramref name="member"/>.
            </summary>
            <param name="member">The member to get base member for.</param>
            <returns>Base member;
            <see langword="null" />, if it does not exist.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.IsExplicitImplementation(System.Reflection.MemberInfo)">
            <summary>
            Determines whether the specified <paramref name="member"/>
            is explicit implementation of some interface member.
            </summary>
            <param name="member">The member to check.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.IsImplementation(System.Reflection.MemberInfo)">
            <summary>
            Determines whether the specified <paramref name="member"/>
            is explicit or implicit implementation of some interface member.
            </summary>
            <param name="member">The member to check.</param>
            <returns>Check result.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetImplementation(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Gets the interface member implementation in its implementor.
            </summary>
            <param name="member">The member to get the implementation member for.</param>
            <returns>Implementation member;
            <see langword="null" />, if no implementation member maps to the specified one.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetInterfaceMember(System.Reflection.MemberInfo)">
            <summary>
            Gets the interface member for its explicit or implicit implementor.
            </summary>
            <param name="member">The member to get the interface member for.</param>
            <returns>Interface member;
            <see langword="null" />, if no interface member maps to the specified one,
            or the member itself is declared in interface.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetFullName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Builds correct full generic type and member name.
            </summary>
            <param name="member">A <see cref="T:System.Reflection.MemberInfo"/> object which name is built.</param>
            <param name="includeTypeName">Indicates whether type name must be included or not.</param>
            <returns>Full member name.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetShortName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>
            Builds correct short generic type and member name.
            </summary>
            <param name="member">A <see cref="T:System.Reflection.MemberInfo"/> object which name is built.</param>
            <param name="includeTypeName">Indicates whether type name must be included or not.</param>
            <returns>Short member name.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MemberHelper.GetMemberType(System.Reflection.MemberInfo)">
            <summary>
            Gets the type of the member.
            </summary>
            <param name="mi">The <see cref="T:System.Reflection.MemberInfo"/>.</param>
        </member>
        <member name="T:Xtensive.Core.Reflection.TypeHelper">
            <summary>
            <see cref="T:System.Type"/> related helper \ extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateAssociate``1(System.Type,System.Type@,System.String[],System.Object[])">
            <summary>
            Searches for associated class for <paramref name="forType"/>, creates its instance, if found.
            Otherwise returns <see langword="null"/>.
            </summary>
            <typeparam name="T">Type of result. Can be ether class or interface.</typeparam>
            <param name="forType">Type to search the associate for.</param>
            <param name="foundForType">Type the associate was found for.</param>
            <param name="associateTypeSuffixes">Associate type name suffix.</param>
            <param name="constructorParams">Parameters to pass to associate constructor.</param>
            <returns>Newly created associate for <paramref name="forType"/>, if found;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateAssociate``1(System.Type,System.Type@,System.String[],System.Object[],System.Collections.Generic.IEnumerable{Xtensive.Core.Pair{System.Reflection.Assembly,System.String}})">
            <summary>
            Searches for associated class for <paramref name="forType"/>, creates its instance, if found.
            Otherwise returns <see langword="null"/>.
            </summary>
            <typeparam name="T">Type of result. Can be ether class or interface.</typeparam>
            <param name="forType">Type to search the associate for.</param>
            <param name="foundForType">Type the associate was found for.</param>
            <param name="associateTypeSuffixes">Associate type name suffix.</param>
            <param name="highPriorityLocations">High-priority search locations (assembly + namespace pairs).</param>
            <param name="constructorParams">Parameters to pass to associate constructor.</param>
            <returns>Newly created associate for <paramref name="forType"/>, if found;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateAssociate``1(System.Type,System.Type@,System.String[],System.Object[],System.Collections.Generic.IEnumerable{Xtensive.Core.Pair{System.Reflection.Assembly,System.String}},System.Boolean)">
            <summary>
            Searches for associated class for <paramref name="forType"/>, creates its instance, if found.
            Otherwise returns <see langword="null"/>.
            </summary>
            <typeparam name="T">Type of result. Can be ether class or interface.</typeparam>
            <param name="forType">Type to search the associate for.</param>
            <param name="foundForType">Type the associate was found for.</param>
            <param name="associateTypeSuffixes">Associate type name suffix.</param>
            <param name="highPriorityLocations">High-priority search locations (assembly + namespace pairs).</param>
            <param name="constructorParams">Parameters to pass to associate constructor.</param>
            <returns>Newly created associate for <paramref name="forType"/>, if found;
            otherwise, <see langword="null"/>.</returns>
            <param name="exactTypeMatch">If <see langword="false"/> tries to create associates for base class, interfaces, arrays and <see cref="T:System.Nullable`1"/>(if struct) too.</param>
            <exception cref="T:System.InvalidOperationException"><paramref name="forType"/> is generic type definition.</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateDummyType(System.String,System.Type)">
            <summary>
            Creates new dummy type. Such types can be used
            as generic arguments (to instantiate unique generic
            instances).
            </summary>
            <param name="namePrefix">Prefix to include into type name.</param>
            <param name="inheritFrom">The type to inherit the dummy type from.</param>
            <returns><see cref="T:System.Type"/> object of newly created type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateDummyType(System.String,System.Type,System.Boolean)">
            <summary>
            Creates new dummy type. Such types can be used
            as generic arguments (to instantiate unique generic
            instances).
            </summary>
            <param name="namePrefix">Prefix to include into type name.</param>
            <param name="inheritFrom">The type to inherit the dummy type from.</param>
            <param name="implementProtectedConstructorAccessor">If <see langword="true"/>, static method with name <see cref="F:Xtensive.Core.Reflection.DelegateHelper.AspectedFactoryMethodName"/> will be created for each constructor.</param>
            <returns><see cref="T:System.Type"/> object of newly created type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateInheritedDummyType(System.String,System.Type)">
            <summary>
            Creates new dummy type inherited from another type.
            </summary>
            <param name="typeName">Type name.</param>
            <param name="inheritFrom">The type to inherit the dummy type from.</param>
            <returns>New type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.CreateInheritedDummyType(System.String,System.Type,System.Boolean)">
            <summary>
            Creates new dummy type inherited from another type.
            </summary>
            <param name="typeName">Type name.</param>
            <param name="inheritFrom">The type to inherit the dummy type from.</param>
            <param name="implementProtectedConstructorAccessor">If <see langword="true"/>, static method with name <see cref="F:Xtensive.Core.Reflection.DelegateHelper.AspectedFactoryMethodName"/> will be created for each constructor.</param>
            <returns>New type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.AddSuffix(System.String,System.String)">
            <summary>
            Adds suffix to specified generic type name.
            </summary>
            <param name="typeName">Type name to add suffix for.</param>
            <param name="suffix">Suffix to add.</param>
            <returns>Specified generic type name with its suffix.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.Activate(System.Reflection.Assembly,System.String,System.Type[],System.Object[])">
            <summary>
            Instantiates specified generic type; returns <see langword="null"/>, if either no such a type,
            or an error has occurred.
            </summary>
            <param name="assembly">Assembly where the type is located.</param>
            <param name="typeName">Name of the type to instantiate.</param>
            <param name="genericArguments">Generic arguments for the type to instantiate 
            (<see langword="null"/> means type isn't a generic type definition).</param>
            <param name="arguments">Arguments to pass to the type constructor.</param>
            <returns>An instance of specified type; <see langword="null"/>, if either no such a type,
            or an error has occurred.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.Activate(System.Type,System.Type[],System.Object[])">
            <summary>
            Instantiates specified generic type; returns <see langword="null"/>, if either no such a type,
            or an error has occurred.
            </summary>
            <param name="type">Generic type definition to instantiate.</param>
            <param name="genericArguments">Generic arguments for the type to instantiate 
            (<see langword="null"/> means <paramref name="type"/> isn't a generic type definition).</param>
            <param name="arguments">Arguments to pass to the type constructor.</param>
            <returns>An instance of specified type; <see langword="null"/>, if either no such a type,
            or an error has occurred.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetConstructor(System.Type,System.Object[])">
            <summary>
            Gets the public constructor of type <paramref name="type"/> 
            accepting specified <paramref name="arguments"/>.
            </summary>
            <param name="type">The type to get the constructor for.</param>
            <param name="arguments">The arguments.</param>
            <returns>
            Appropriate constructor, if a single match is found;
            otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.OrderByInheritance(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Orders the specified <paramref name="types"/> by their inheritance
            (very base go first).
            </summary>
            <param name="types">The types to sort.</param>
            <returns>The list of <paramref name="types"/> ordered by their inheritance.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetInterfaces(System.Type,System.Boolean)">
            <summary>
            Gets the interfaces of the specified type.
            </summary>
            <param name="type">The type to get the interfaces of.</param>
            <param name="orderByInheritance">Indicates interfaces must be ordered from the very base ones 
            to very ancestors.</param>
            <returns>The interfaces of the specified type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetFullName(System.Type)">
            <summary>
            Builds correct full generic type name.
            </summary>
            <param name="type">A <see cref="T:System.Type"/> which name is built.</param>
            <returns>Full type name.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetShortName(System.Type)">
            <summary>
            Builds correct short generic type name (without namespaces).
            </summary>
            <param name="type">A <see cref="T:System.Type"/> which name is built.</param>
            <returns>Short type name.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetCodeTypeReference(System.Type)">
            <summary>
            Gets the <see cref="T:System.CodeDom.CodeTypeReference"/> to the specified <paramref name="type"/>.
            </summary>
            <param name="type">A referenced <see cref="T:System.Type"/>.</param>
            <returns><see cref="T:System.CodeDom.CodeTypeReference"/> to given type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsNullable(System.Type)">
            <summary>
            Indicates whether <paramref name="type"/> is a <see cref="T:System.Nullable`1"/> type.
            </summary>
            <param name="type">Type to check.</param>
            <returns><see langword="True"/> if type is nullable type;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsNullable``1">
            <summary>
            Indicates whether <typeparamref name="T"/> type is a <see cref="T:System.Nullable`1"/> type.
            </summary>
            <typeparam name="T">Type to check.</typeparam>
            <returns><see langword="True"/> if type is nullable type;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsFinal(System.Type)">
            <summary>
            Indicates whether <paramref name="type"/> is a final type.
            </summary>
            <param name="type">Type to check.</param>
            <returns><see langword="True"/> if type is final type;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsFinal``1">
            <summary>
            Indicates whether <typeparamref name="T"/> type is a final type.
            </summary>
            <typeparam name="T">Type to check.</typeparam>
            <returns><see langword="True"/> if type is final type;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetInvokeMethod(System.Type)">
            <summary>
            Gets the delegate "Invoke" method (describing the delegate) for 
            the specified <paramref name="delegateType"/>.
            </summary>
            <param name="delegateType">Type of the delegate to get the "Invoke" method of.</param>
            <returns><see cref="T:System.Reflection.MethodInfo"/> object describing the delegate "Invoke" method.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsOfGenericType(System.Type,System.Type)">
            <summary>
            Determines whether the specified <paramref name="type"/> inherits the generic <paramref name="baseType"/>.
            </summary>
            <param name="type">The type to check.</param>
            <param name="baseType">Type of the generic.</param>
            <returns>
            <see langword="true"/> if the specified <paramref name="type"/> inherits the generic <paramref name="baseType"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.GetGenericType(System.Type,System.Type)">
            <summary>
            Determines whether the specified <paramref name="type"/> inherits 
            the generic <paramref name="baseType"/> and returns direct inheritor of generic <paramref name="baseType"/> if any.
            </summary>
            <param name="type">The type to check.</param>
            <param name="baseType">Type of the generic.</param>
            <returns>
            Generic <see cref="T:System.Type"/> that directly inherits <paramref name="baseType"/> if the specified <paramref name="type"/> inherits the generic <paramref name="baseType"/>;
            otherwise, <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsOfGenericInterface(System.Type,System.Type)">
            <summary>
            Determines whether <paramref name="type"/> implements the <paramref name="_interface"/>.
            </summary>
            <param name="type">The type.</param>
            <param name="_interface">The <see langword="interface"/>.</param>
            <returns>
             <see langword="true"/> if the specified <paramref name="type"/> implements the <paramref name="_interface"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.ToNullable(System.Type)">
            <summary>
            Converts <paramref name="type"/> to type that can assign both values of <paramref name="type"/> and <see landword="null"/>.
            This method is a reverse for <see cref="M:Xtensive.Core.Reflection.TypeHelper.StripNullable(System.Type)"/> method.
            </summary>
            <param name="type">A type to convert.</param>
            <returns>
            If <paramref name="type"/> is a reference type or a <see cref="T:System.Nullable`1"/> instance returns <paramref name="type"/>.
            Otherwise returns <see cref="T:System.Nullable`1"/> of <paramref name="type"/>. 
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.StripNullable(System.Type)">
            <summary>
            Converts <paramref name="type"/> to <see cref="T:System.Nullable`1"/> if <paramref name="type"/> is a value type.
            Otherwise returns just <paramref name="type"/>.
            This method is a reverse for <see cref="M:Xtensive.Core.Reflection.TypeHelper.ToNullable(System.Type)"/> method.
            </summary>
            <param name="type">The type to process.</param>
            <returns>
            <see cref="T:System.Nullable`1"/> of <paramref name="type"/> is specified type is a value type.
            Otherwise return just <paramref name="type"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsAnonymous(System.Type)">
            <summary>
            Determines whether the specified <paramref name="type"/> is anonymous type.
            </summary>
            <param name="type">The type.</param>
            <returns>
              <see langword="true" /> if the specified type is anonymous; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsClosure(System.Type)">
            <summary>
            Determines whether the specified <paramref name="type"/> is closure type.
            </summary>
            <param name="type">The type.</param>
            <returns>
              <see langword="true" /> if the specified type is anonymous; otherwise, <see langword="false" />.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.TypeHelper.IsPublicNonAbstractInheritorOf(System.Type,System.Type)">
            <summary>
            Determines whether <paramref name="type"/> is a public non-abstract inheritor of <paramref name="baseType"/>.
            </summary>
            <param name="type">The type to check.</param>
            <param name="baseType">The base type.</param>
            <returns>
            <see langword="true"/> if type is a public non-abstract inheritor of specified base type;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Segment`1">
            <summary>
            A definition of segment with boundaries of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of segment boundaries.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Segment`1.Offset">
            <summary>
            Segment offset.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Segment`1.Length">
            <summary>
            Segment length.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Segment`1.Equals(Xtensive.Core.Pair{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Segment`1.CompareTo(Xtensive.Core.Pair{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Segment`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Segment`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Segment`1.op_Addition(Xtensive.Core.Segment{`0},`0)">
            <summary>
            Implements the operator +.
            </summary>
            <param name="segment">The segment.</param>
            <param name="offsetShift">The offset shift.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Segment`1.op_Subtraction(Xtensive.Core.Segment{`0},`0)">
            <summary>
            Implements the operator -.
            </summary>
            <param name="segment">The segment.</param>
            <param name="offsetShift">The offset shift.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Segment`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Segment`1.#ctor(`0,`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="offset">Segment offset.</param>
            <param name="length">Segment length.</param>
        </member>
        <member name="P:Xtensive.Core.Segment`1.EndOffset">
            <summary>
            Gets <see cref="F:Xtensive.Core.Segment`1.Offset"/>+<see cref="F:Xtensive.Core.Segment`1.Length"/> value.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`2">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate sizes for.</typeparam>
            <typeparam name="TBase">Base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`2.BaseSizeCalculator">
            <summary>
            Size calculator for base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`2.#ctor(Xtensive.Core.SizeCalculators.ISizeCalculatorProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Size calculator provider this wrapper bound to.</param>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`4">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate sizes for.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
            <typeparam name="TBase3">Third base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`4.BaseSizeCalculator1">
            <summary>
            Size calculator for the first base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`4.BaseSizeCalculator2">
            <summary>
            Size calculator for the second base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`4.BaseSizeCalculator3">
            <summary>
            Size calculator for the third base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`4.#ctor(Xtensive.Core.SizeCalculators.ISizeCalculatorProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Size calculator provider this wrapper bound to.</param>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`3">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate sizes for.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`3.BaseSizeCalculator1">
            <summary>
            Size calculator for the first base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`3.BaseSizeCalculator2">
            <summary>
            Size calculator for the second base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.WrappingSizeCalculator`3.#ctor(Xtensive.Core.SizeCalculators.ISizeCalculatorProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Size calculator provider this wrapper bound to.</param>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.TupleSizeCalculator.GetValueSize(Xtensive.Core.Tuples.Tuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.TupleSizeCalculator.#ctor(Xtensive.Core.SizeCalculators.ISizeCalculatorProvider)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1">
            <summary>
            A struct providing faster access for key <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculator`1"/> delegates.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.Default">
            <summary>
            Gets <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1"/> for <see cref="P:Xtensive.Core.SizeCalculators.SizeCalculator`1.Default"/> hasher.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.SizeCalculator">
            <summary>
            Gets the underlying size calculator for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.GetSize">
            <summary>
            Gets <see cref="M:Xtensive.Core.SizeCalculators.ISizeCalculatorBase.GetDefaultSize"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.GetValueSize">
            <summary>
            Gets <see cref="M:Xtensive.Core.SizeCalculators.ISizeCalculator`1.GetValueSize(`0)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.op_Implicit(Xtensive.Core.SizeCalculators.SizeCalculator{`0})~Xtensive.Core.SizeCalculators.SizeCalculatorStruct{`0}">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculator`1"/> to <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1"/>.
            </summary>
            <param name="sizeCalculator">Size calculator to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.#ctor(Xtensive.Core.SizeCalculators.SizeCalculator{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="sizeCalculator">Size calculator to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorStruct`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.SizeCalculator`1">
            <summary>
            Provides delegates allowing to call size calculator methods faster.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/> generic argument.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculator`1.Provider">
            <summary>
            Gets the provider underlying size calculator is associated with.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculator`1.GetDefaultSize">
            <summary>
            Gets <see cref="M:Xtensive.Core.SizeCalculators.ISizeCalculatorBase.GetDefaultSize"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculator`1.GetValueSize">
            <summary>
            Gets <see cref="M:Xtensive.Core.SizeCalculators.ISizeCalculator`1.GetValueSize(`0)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculator`1.#ctor(Xtensive.Core.SizeCalculators.ISizeCalculator{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation">Size calculator to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculator`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="P:Xtensive.Core.SizeCalculators.SizeCalculator`1.Default">
            <summary>
            Gets default size calculator for type <typeparamref name="T"/>
            (uses <see cref="P:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.Default"/> <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculatorProvider"/>).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Threading.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Threading.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Threading.ThreadSafeIntDictionary`1">
            <summary>
            Thread-safe version of <see cref="T:Xtensive.Core.Collections.IntDictionary`1"/>. Any operation on it is atomic.
            Note: it recreates its internal dictionary on any data modifying
            operation on it.
            </summary>
            <typeparam name="TValue">Value type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.GetValue(System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the dictionary.
            </summary>
            <param name="key">The key to get the value for.</param>
            <param name="generator">The value generator.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.GetValue``1(System.Int32,System.Func{System.Int32,``0,`0},``0)">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the dictionary.
            </summary>
            <typeparam name="T">The type of the <paramref name="argument"/> to pass to 
            the <paramref name="generator"/>.</typeparam>
            <param name="key">The key to get the value for.</param>
            <param name="generator">The value generator.</param>
            <param name="argument">The argument to pass to the <paramref name="generator"/>.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.TryGetValue(System.Int32,`0@)">
            <summary>
            Gets the value by its key.
            </summary>
            <param name="key">The key to get the value for.</param>
            <param name="value">Found value, or default value, if value is not found.</param>
            <returns>Whether or not value was found.</returns>    
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.SetValue(System.Int32,`0)">
            <summary>
            Sets the value associated with specified key.
            </summary>
            <param name="key">The key to set value for.</param>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.Initialize(System.Object,System.Int32)">
            <summary>
            Initializes the dictionary.
            This method should be invoked just once - before
            the first operation on this dictionary.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.SyncRoot"/> property value.</param>
            <param name="capacity">The initial capacity.</param>
            <exception cref="T:System.NotSupportedException">The dictionary is already initialized.</exception>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.Initialize(System.Object)">
            <summary>
            Initializes the dictionary.
            This method should be invoked just once - before
            the first operation on this dictionary.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.SyncRoot"/> property value.</param>
            <exception cref="T:System.NotSupportedException">The dictionary is already initialized.</exception>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.Create(System.Object,System.Int32)">
            <summary>
            Creates and initializes a new <see cref="T:Xtensive.Core.Threading.ThreadSafeIntDictionary`1"/>.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.SyncRoot"/> property value.</param>
            <param name="capacity">The initial capacity.</param>
            <returns>New initialized <see cref="T:Xtensive.Core.Threading.ThreadSafeIntDictionary`1"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.Create(System.Object)">
            <summary>
            Creates and initializes a new <see cref="T:Xtensive.Core.Threading.ThreadSafeIntDictionary`1"/>.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.SyncRoot"/> property value.</param>
            <returns>New initialized <see cref="T:Xtensive.Core.Threading.ThreadSafeIntDictionary`1"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeIntDictionary`1.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Triplet`1">
            <summary>
            Container of three values.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of the triplet values.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Triplet`1.First">
            <summary>
            First value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Triplet`1.Second">
            <summary>
            Second value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Triplet`1.Third">
            <summary>
            Third value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.Equals(Xtensive.Core.Triplet{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.CompareTo(Xtensive.Core.Triplet{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.op_Equality(Xtensive.Core.Triplet{`0},Xtensive.Core.Triplet{`0})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.op_Inequality(Xtensive.Core.Triplet{`0},Xtensive.Core.Triplet{`0})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`1.#ctor(`0,`0,`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="first">A first value in triplet.</param>
            <param name="second">A second value in triplet.</param>
            <param name="third">A third value in triplet.</param>
        </member>
        <member name="T:Xtensive.Core.Hashing.Hasher`1">
            <summary>
            Provides delegates allowing to call hashing methods faster.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Hashing.IHasher`1"/> generic argument.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.Hashing.Hasher`1.Provider">
            <summary>
            Gets the provider underlying hasher is associated with.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.Hasher`1.GetHash">
            <summary>
            Gets <see cref="M:Xtensive.Core.Hashing.IHasher`1.GetHash(`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.Hasher`1.GetHashes">
            <summary>
            Gets <see cref="M:Xtensive.Core.Hashing.IHasher`1.GetHashes(`0,System.Int32)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.Hasher`1.#ctor(Xtensive.Core.Hashing.IHasher{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation">Hasher to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Hashing.Hasher`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Hashing.Hasher`1.Default">
            <summary>
            Gets default hasher for type <typeparamref name="T"/>
            (uses <see cref="P:Xtensive.Core.Hashing.HasherProvider.Default"/> <see cref="T:Xtensive.Core.Hashing.HasherProvider"/>).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Hashing.HasherStruct`1">
            <summary>
            A struct providing faster access for key <see cref="!:Hasher&lt;T&gt;"/> delegates.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Hashing.IHasher`1"/> generic argument.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Hashing.HasherStruct`1.Default">
            <summary>
            Gets <see cref="T:Xtensive.Core.Hashing.HasherStruct`1"/> for <see cref="!:Hasher&lt;T&gt;.Default"/> hasher.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.HasherStruct`1.Hasher">
            <summary>
            Gets the underlying hasher for this cache.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.HasherStruct`1.GetHash">
            <summary>
            Gets <see cref="M:Xtensive.Core.Hashing.IHasher`1.GetHash(`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.HasherStruct`1.GetHashes">
            <summary>
            Gets <see cref="M:Xtensive.Core.Hashing.IHasher`1.GetHashes(`0,System.Int32)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherStruct`1.op_Implicit(Xtensive.Core.Hashing.Hasher{`0})~Xtensive.Core.Hashing.HasherStruct{`0}">
            <summary>
            Implicit conversion of <see cref="!:Hasher&lt;T&gt;"/> to <see cref="T:Xtensive.Core.Hashing.HasherStruct`1"/>.
            </summary>
            <param name="hasher">Hasher to provide the struct for.</param>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherStruct`1.#ctor(Xtensive.Core.Hashing.Hasher{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="hasher">Hasher to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherStruct`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherStruct`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate">
            <summary>
            Serializable type documentation template.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes the instance of <see cref="T:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate"/> class.
            </summary>
            <param name="info">Serialization info to store serialization data in.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of <see cref="T:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate"/> class.
            </summary>
            <param name="info">Serialization info to get the deserialized data from.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.OnDeserialization(System.Object)">
            <summary>
            Handles post-deserialization initialization of the deserialized
            <see cref="T:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate"/> instance.
            </summary>
            <param name="sender">The object invoking this method.</param>
        </member>
        <member name="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate">
            <summary>
            Singleton documentation template.
            </summary>
            <remarks>
            <para id="About">
            This class is a singleton - use its <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance"/>
            property to get the only instance of it.
            </para>
            </remarks>
        </member>
        <member name="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance">
            <summary>
            Gets the only instance of <see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate">
            <summary>
            Class with static <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default"/> documentation template.
            </summary>
            <remarks>
            <para id="About">
            This class has default instance - use its <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default"/>
            property to get it.
            </para>
            </remarks>
        </member>
        <member name="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default">
            <summary>
            Gets the default instance of <see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Box`1">
            <summary>
            Packs a single <see cref="F:Xtensive.Core.Box`1.Value"/> into the <see cref="T:System.ValueType"/>.
            </summary>
            <typeparam name="T">Type of the <see cref="F:Xtensive.Core.Box`1.Value"/>.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Box`1.Value">
            <summary>
            Boxed value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Box`1.Equals(Xtensive.Core.Box{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Box`1.CompareTo(Xtensive.Core.Box{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Box`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Box`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Box`1.op_Equality(Xtensive.Core.Box{`0},Xtensive.Core.Box{`0})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Box`1.op_Inequality(Xtensive.Core.Box{`0},Xtensive.Core.Box{`0})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Box`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Box`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">Boxed value.</param>
        </member>
        <member name="T:Xtensive.Core.Threading.ThreadSafeList`1">
            <summary>
            Thread-safe list. Any operation on it is atomic.
            Note: it recreates its internal array (makes it twice larger) when it should grow up.
            </summary>
            <typeparam name="TItem">Value type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.GetValue(System.Int32,System.Func{System.Int32,`0})">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the list.
            </summary>
            <param name="index">The index of the value to get.</param>
            <param name="generator">The value generator.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.GetValue``1(System.Int32,System.Func{System.Int32,``0,`0},``0)">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the list.
            </summary>
            <typeparam name="T">The type of the <paramref name="argument"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="index">The index of the value to get.</param>
            <param name="generator">The value generator.</param>
            <param name="argument">The argument to pass to the <paramref name="generator"/>.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.GetValue``2(System.Int32,System.Func{System.Int32,``0,``1,`0},``0,``1)">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the list.
            </summary>
            <typeparam name="T1">The type of the <paramref name="argument1"/> to pass to the <paramref name="generator"/>.</typeparam>
            <typeparam name="T2">The type of the <paramref name="argument2"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="index">The index of the value to get.</param>
            <param name="generator">The value generator.</param>
            <param name="argument1">The first argument to pass to the <paramref name="generator"/>.</param>
            <param name="argument2">The second argument to pass to the <paramref name="generator"/>.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.GetValue(System.Int32)">
            <summary>
            Gets the value by its index.
            </summary>
            <param name="index">The index to get value for.</param>
            <returns>Found value, or <see langword="default(TItem)"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.SetValue(System.Int32,`0)">
            <summary>
            Sets the value associated with specified index.
            </summary>
            <param name="index">The index to set value for.</param>
            <param name="item">The value to set.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.Clear">
            <summary>
            Clears the list.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.Initialize(System.Object)">
            <summary>
            Initializes the list. 
            This method should be invoked just once - before
            the first operation on this list.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeList`1.SyncRoot"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeList`1.Create(System.Object)">
            <summary>
            Creates and initializes a new <see cref="T:Xtensive.Core.Threading.ThreadSafeList`1"/>.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeList`1.SyncRoot"/> property value.</param>
            <returns>New initialized <see cref="T:Xtensive.Core.Threading.ThreadSafeList`1"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeList`1.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeList`1.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.EnumerableEnumerable`2">
            <summary>
            Enumerable of enumerables flattener.
            </summary>
            <typeparam name="TSource">The type of enumerable items.</typeparam>
            <typeparam name="TItem">The type of item in the enumerable of enumerables.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.EnumerableEnumerable`2.System#Collections#Generic#IEnumerable{TItem}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.EnumerableEnumerable`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.EnumerableEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The source to flatten.</param>
        </member>
        <member name="T:Xtensive.Core.SetExtensions">
            <summary>
            <see cref="T:Xtensive.Core.Collections.ISet`1"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsDisjointWith``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="set"/> and the 
            specified set of <paramref name="items"/> are disjoint.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> and the specified 
            set of <paramref name="items"/> are disjoint; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsEqualTo``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="set"/> and the 
            specified set of <paramref name="items"/> are equal.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> and the specified 
            set of <paramref name="items"/> are equal; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsProperSubsetOf``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="set"/> is a proper subset of the 
            specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set to check if it's proper subset of <paramref name="items"/>.</param>
            <param name="items">The set of items.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> is a proper subset of the specified 
            set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsProperSupersetOf``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified set of <paramref name="items"/> is a proper subset of the 
            specified <paramref name="set"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items to check if it's proper subset of <paramref name="set"/>.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> is a proper subset of the specified 
            set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsSubsetOf``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="set"/> is a subset of the 
            specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set to check if it's subset of <paramref name="items"/>.</param>
            <param name="items">The set of items.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> is subset of the specified 
            set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsSupersetOf``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified set of <paramref name="items"/> is a subset of the 
            specified <paramref name="set"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items to check if it's a subset of <paramref name="set"/>.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> is subset of the specified 
            set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IsOverlappingWith``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="set"/> overlaps the 
            specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="set">The set to check if it overlaps the <paramref name="items"/>.</param>
            <param name="items">The set of items.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="set"/> overlaps the specified 
            set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.Union``2(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Unions the specified <paramref name="set"/> and the 
            specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <typeparam name="TSet">The type of set to return.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from union of the specified <paramref name="set"/> 
            and the specified set of <paramref name="items"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.UnionWith``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Unions the specified <paramref name="target"/> and the 
            specified set of <paramref name="items"/> in the result set <paramref name="target"/>.
            </summary>
            <param name="target">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from union of the specified <paramref name="target"/> 
            and the specified set of <paramref name="items"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.Intersect``2(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersects the specified <paramref name="set"/> and the 
            specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <typeparam name="TSet">The type of set to return.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from intersection of the specified <paramref name="set"/> 
            and the specified set of <paramref name="items"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.AddIntersectionOf``1(Xtensive.Core.Collections.ISet{``0},Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersects the specified <paramref name="set"/> and the 
            specified set of <paramref name="items"/> in the result set <paramref name="target"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="target">The result set.</param>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from intersection of the specified <paramref name="set"/> 
            and the specified set of <paramref name="items"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.IntersectWith``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Intersects the specified <paramref name="target"/> and the 
            specified set of <paramref name="items"/> in the result set <paramref name="target"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="target">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from intersection of the specified <paramref name="target"/> 
            and the specified set of <paramref name="items"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.Except``2(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excepts the specified set of <paramref name="items"/> from the 
            specified <paramref name="set"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <typeparam name="TSet">The type of set to return.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from excepting of the specified set of <paramref name="items"/>
            from the specified <paramref name="set"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.AddExceptionOf``1(Xtensive.Core.Collections.ISet{``0},Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excepts the specified set of <paramref name="items"/> from the 
            specified <paramref name="set"/> in the result set <paramref name="target"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="target">The result set.</param>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from excepting of the specified set of <paramref name="items"/>
            from the specified <paramref name="set"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.ExceptWith``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excepts the specified set of <paramref name="items"/> from the 
            specified <paramref name="target"/> in the result set <paramref name="target"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="target">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived from excepting of the specified set of <paramref name="items"/>
            from the specified <paramref name="target"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.SymmetricExcept``2(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excepts the elements of the specified set of <paramref name="items"/> contained in
            the  specified <paramref name="set"/> from <paramref name="set"/> and adds 
            the elements of the specified set of <paramref name="items"/> not contained in
            the  specified <paramref name="set"/> to <paramref name="set"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <typeparam name="TSet">The type of set to return.</typeparam>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived by excepting the elements of the specified set of <paramref name="items"/> contained in
            the  specified <paramref name="set"/> from <paramref name="set"/> and adding 
            the elements of the specified set of <paramref name="items"/> not contained in
            the  specified <paramref name="set"/> to <paramref name="set"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.AddSymmetricExceptionOf``1(Xtensive.Core.Collections.ISet{``0},Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excepts the elements of the specified set of <paramref name="items"/> contained in
            the  specified <paramref name="set"/> from <paramref name="set"/> and adds 
            the elements of the specified set of <paramref name="items"/> not contained in
            the  specified <paramref name="set"/> to <paramref name="set"/> in the result set <paramref name="target"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="target">The result set.</param>
            <param name="set">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived by excepting the elements of the specified set of <paramref name="items"/> contained in
            the  specified <paramref name="set"/> from <paramref name="set"/> and adding 
            the elements of the specified set of <paramref name="items"/> not contained in
            the  specified <paramref name="set"/> to <paramref name="set"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.SetExtensions.SymmetricExceptWith``1(Xtensive.Core.Collections.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excepts the elements of the specified set of <paramref name="items"/> contained in
            the  specified <paramref name="target"/> from <paramref name="target"/> and adds 
            the elements of the specified set of <paramref name="items"/> not contained in
            the  specified <paramref name="target"/> to <paramref name="target"/> in the result set <paramref name="target"/>.
            </summary>
            <typeparam name="TItem">The type of set items.</typeparam>
            <param name="target">The set.</param>
            <param name="items">The set of items.</param>
            <returns>A set derived by excepting the elements of the specified set of <paramref name="items"/> contained in
            the  specified <paramref name="target"/> from <paramref name="target"/> and adding 
            the elements of the specified set of <paramref name="items"/> not contained in
            the  specified <paramref name="target"/> to <paramref name="target"/>.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Disposing.DisposableSet">
            <summary>
            Ensures all the <see cref="T:System.IDisposable"/> objects added to it are disposed
            on disposal of <see cref="T:Xtensive.Core.Disposing.DisposableSet"/> instance.
            </summary>
            <remarks>
            <note>
            <see cref="M:System.IDisposable.Dispose"/> methods are invoked in backward order.
            </note>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Disposing.DisposableSet.Add(System.IDisposable)">
            <summary>
            Adds an <see cref="T:System.IDisposable"/> object to the set.
            </summary>
            <param name="disposable">The object to add.</param>
            <returns><see langword="True"/>, if object is successfully added;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Disposing.DisposableSet.op_BitwiseAnd(Xtensive.Core.Disposing.DisposableSet,System.IDisposable)">
            <summary>
            Joins the <see cref="T:Xtensive.Core.Disposing.DisposableSet"/> and <see cref="T:System.IDisposable"/>.
            </summary>
            <param name="first">The first disposable to join.</param>
            <param name="second">The second disposable to join.</param>
            <returns>New <see cref="T:Xtensive.Core.Disposing.JoiningDisposable"/> that will
            dispose both of them on its disposal</returns>
        </member>
        <member name="M:Xtensive.Core.Disposing.DisposableSet.#ctor(System.Collections.IEnumerable)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="initialContent">The initial content.</param>
        </member>
        <member name="M:Xtensive.Core.Disposing.DisposableSet.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Disposing.DisposableSet.System#IDisposable#Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose"/>
        </member>
        <member name="M:Xtensive.Core.Disposing.DisposableSet.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dtor"/>
        </member>
        <member name="T:Xtensive.Core.Collections.SetBase`1">
            <summary>
            Base type for sets.
            </summary>
            <typeparam name="TItem">Type of values to store to set.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.RemoveWhere(System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.System#Collections#Generic#ICollection{TItem}#Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.SetBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="comparer">The equality comparer to use.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.Items">
            <summary>
            Gets the underlying dictionary containing all the set items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.ContainsNull">
            <summary>
            Gets or sets a value indicating whether a set contains <see langword="null"/> item.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.Item(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.Comparer">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.SetBase`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Threading.ThreadSafeDictionary`2">
            <summary>
            Thread-safe dictionary. Any operation on it is atomic.
            Note: it recreates its internal dictionary on any data modifying
            operation on it.
            </summary>
            <typeparam name="TKey">Key type.</typeparam>
            <typeparam name="TItem">Value type.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.GetValue(`0,System.Func{`0,`1})">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the dictionary.
            </summary>
            <param name="key">The key to get the value for.</param>
            <param name="generator">The value generator.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.GetValue``1(`0,System.Func{`0,``0,`1},``0)">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the dictionary.
            </summary>
            <typeparam name="T">The type of the <paramref name="argument"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="key">The key to get the value for.</param>
            <param name="generator">The value generator.</param>
            <param name="argument">The argument to pass to the <paramref name="generator"/>.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.GetValue``2(`0,System.Func{`0,``0,``1,`1},``0,``1)">
            <summary>
            Gets the value or generates it using specified <paramref name="generator"/> and 
            adds it to the dictionary.
            </summary>
            <typeparam name="T1">The type of the <paramref name="argument1"/> to pass to the <paramref name="generator"/>.</typeparam>
            <typeparam name="T2">The type of the <paramref name="argument2"/> to pass to the <paramref name="generator"/>.</typeparam>
            <param name="key">The key to get the value for.</param>
            <param name="generator">The value generator.</param>
            <param name="argument1">The first argument to pass to the <paramref name="generator"/>.</param>
            <param name="argument2">The second argument to pass to the <paramref name="generator"/>.</param>
            <returns>Found or generated value.</returns>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value by its key.
            </summary>
            <param name="key">The key to get the value for.</param>
            <param name="value">Found value, or default value, if value is not found.</param>
            <returns>Whether or not value was found.</returns>    
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.SetValue(`0,`1)">
            <summary>
            Sets the value associated with specified key.
            </summary>
            <param name="key">The key to set value for.</param>
            <param name="item">The value to set.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.Clear">
            <summary>
            Clears the dictionary.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.Initialize(System.Object)">
            <summary>
            Initializes the dictionary. 
            This method should be invoked just once - before
            the first operation on this dictionary.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeDictionary`2.SyncRoot"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.ThreadSafeDictionary`2.Create(System.Object)">
            <summary>
            Creates and initializes a new <see cref="T:Xtensive.Core.Threading.ThreadSafeDictionary`2"/>.
            </summary>
            <param name="syncRoot"><see cref="P:Xtensive.Core.Threading.ThreadSafeDictionary`2.SyncRoot"/> property value.</param>
            <returns>New initialized <see cref="T:Xtensive.Core.Threading.ThreadSafeDictionary`2"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeDictionary`2.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Threading.ThreadSafeDictionary`2.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Comparison.AdvancedComparer`1">
            <summary>
            Provides delegates allowing to call comparison methods faster.
            </summary>
            <typeparam name="T">The type of <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> generic argument.</typeparam>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.ComparerImplementation">
            <summary>
            Gets the underlying comparer implementation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.EqualityComparerImplementation">
            <summary>
            Gets the underlying equality comparer implementation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.Provider">
            <summary>
            Gets the provider underlying comparer is associated with.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.ComparisonRules">
            <summary>
            Gets comparison rules used by the underlying comparer.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.Compare">
            <summary>
            Gets <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.Equals">
            <summary>
            Gets <see cref="M:System.Collections.Generic.IEqualityComparer`1.Equals(`0,`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.GetHashCode">
            <summary>
            Gets <see cref="M:System.Collections.Generic.IEqualityComparer`1.GetHashCode(`0)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.GetNearestValue">
            <summary>
            Gets <see cref="M:Xtensive.Core.Comparison.INearestValueProvider`1.GetNearestValue(`0,Xtensive.Core.Direction)"/> method delegate.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.ValueRangeInfo">
            <summary>
            Gets <see cref="P:Xtensive.Core.Comparison.IHasRangeInfo`1.ValueRangeInfo"/> value used by the underlying comparer.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.AdvancedComparer`1.ApplyRules">
            <summary>
            Gets <see cref="M:Xtensive.Core.Comparison.IAdvancedComparer`1.ApplyRules(Xtensive.Core.Comparison.ComparisonRules)"/> method delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.GetAsymmetric``1">
            <summary>
            A shortcut to <see cref="M:Xtensive.Core.Comparison.IAdvancedComparer`1.GetAsymmetric``1"/> method
            of <see cref="F:Xtensive.Core.Helpers.MethodCacheBase`1.Implementation"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.Cast``1">
            <summary>
            Wraps this instance with the <see cref="T:Xtensive.Core.Comparison.CastingComparer`2"/>.
            </summary>
            <typeparam name="TTarget">The type to provide the comparer for (by wrapping this comparer).</typeparam>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.#ctor(Xtensive.Core.Comparison.IAdvancedComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="implementation">Implementation to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="comparer">Comparer to provide the delegates for.</param>
            <param name="equalityComparer">Equality comparer to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="comparer">Comparer to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="equalityComparer">Equality comparer to provide the delegates for.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the instance of this class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.AdvancedComparer`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Comparison.AdvancedComparer`1.Default">
            <summary>
            Gets default advanced comparer for type <typeparamref name="T"/>
            (uses <see cref="P:Xtensive.Core.Comparison.ComparerProvider.Default"/> <see cref="T:Xtensive.Core.Comparison.ComparerProvider"/>).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.AdvancedComparer`1.System">
            <summary>
            Gets system comparers exposed as <see cref="T:Xtensive.Core.Comparison.AdvancedComparer`1"/> for type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Comparison.ComparisonRule">
            <summary>
            Describes how to compare values of comparable objects.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRule.None">
            <summary>
            Predefined rule with <see cref="F:Xtensive.Core.Comparison.ComparisonRule.Direction"/> = <see cref="F:Xtensive.Core.Direction.None"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRule.Positive">
            <summary>
            Predefined rule with <see cref="F:Xtensive.Core.Comparison.ComparisonRule.Direction"/> = <see cref="F:Xtensive.Core.Direction.Positive"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRule.Negative">
            <summary>
            Predefined rule with <see cref="F:Xtensive.Core.Comparison.ComparisonRule.Direction"/> = <see cref="F:Xtensive.Core.Direction.Negative"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRule.Direction">
            <summary>
            Gets <see cref="T:Xtensive.Core.Direction"/> for the comparison.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRule.Culture">
            <summary>
            Gets <see cref="T:System.Globalization.CultureInfo"/> for the comparison.
            <see langword="Null"/> means no culture is specified.
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/> should normally be used
            for the comparison in this case.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.Invert">
            <summary>
            Inverts the direction of the rule.
            </summary>
            <returns>The same rule, but with inverted direction.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.Combine(Xtensive.Core.Comparison.ComparisonRule)">
            <summary>
            Combines new comparison rule with the rule described by this instance.
            </summary>
            <param name="rule">Rule to combine.</param>
            <returns>Result of the combination.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.Equals(Xtensive.Core.Comparison.ComparisonRule)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.op_Equality(Xtensive.Core.Comparison.ComparisonRule,Xtensive.Core.Comparison.ComparisonRule)">
            <summary>
            Implements the equality operator.
            </summary>
            <param name="x">The first argument.</param>
            <param name="y">The second argument.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.op_Inequality(Xtensive.Core.Comparison.ComparisonRule,Xtensive.Core.Comparison.ComparisonRule)">
            <summary>
            Implements the inequality operator.
            </summary>
            <param name="x">The first argument.</param>
            <param name="y">The second argument.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.op_Implicit(Xtensive.Core.Comparison.ComparisonRule)~Xtensive.Core.Comparison.ComparisonRules">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.Comparison.ComparisonRule"/> to <see cref="T:Xtensive.Core.Comparison.ComparisonRules"/>.
            </summary>
            <param name="comparisonRule">The rule to convert.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.op_Implicit(Xtensive.Core.Direction)~Xtensive.Core.Comparison.ComparisonRule">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.Direction"/> to <see cref="T:Xtensive.Core.Comparison.ComparisonRule"/>.
            </summary>
            <param name="direction">Direction to convert.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.#ctor(Xtensive.Core.Direction)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="direction">Initial <see cref="T:Xtensive.Core.Direction"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRule.#ctor(Xtensive.Core.Direction,System.Globalization.CultureInfo)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="direction">Initial <see cref="T:Xtensive.Core.Direction"/> property value.</param>
            <param name="culture">Initial <see cref="F:Xtensive.Core.Comparison.ComparisonRule.Culture"/> property value.</param>
        </member>
        <member name="T:Xtensive.Core.Comparison.ComparisonRules">
            <summary>
            Ordering rule for <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/> comparer.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRules.None">
            <summary>
            Predefined rules with <see cref="T:Xtensive.Core.Direction"/> = <see cref="F:Xtensive.Core.Direction.None"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRules.Positive">
            <summary>
            Predefined rules with <see cref="T:Xtensive.Core.Direction"/> = <see cref="F:Xtensive.Core.Direction.Positive"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.ComparisonRules.Negative">
            <summary>
            Predefined rules with <see cref="T:Xtensive.Core.Direction"/> = <see cref="F:Xtensive.Core.Direction.Negative"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.GetCompositeValue(System.Int32)">
            <summary>
            Gets the <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> of <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> rule 
            for the specified index of composite rule.
            </summary>
            <param name="index">Index of composite rule to get the <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> of.</param>
            <returns><see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> of <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> rule, 
            if rule for specified <paramref name="index"/> is found; 
            otherwise, <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Tail"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.GetDefaultRuleDirection(System.Int32)">
            <summary>
            Gets the <see cref="T:Xtensive.Core.Direction"/> of the <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> of <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> rule 
            for the specified index of composite rule.
            </summary>
            <param name="index">Index of composite rule to get the <see cref="T:Xtensive.Core.Direction"/> of.</param>
            <returns><see cref="T:Xtensive.Core.Direction"/> of the <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> of <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> rule, 
            if rule for specified <paramref name="index"/> is found; 
            otherwise, <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Tail"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.Combine(Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            Combines new comparison rules with the rules described by this instance.
            </summary>
            <param name="rules">Rules to combine.</param>
            <returns>Result of the combination.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.Equals(Xtensive.Core.Comparison.ComparisonRules)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.op_Implicit(Xtensive.Core.Direction)~Xtensive.Core.Comparison.ComparisonRules">
            <summary>
            Implicit conversion of <see cref="T:Xtensive.Core.Direction"/> to <see cref="T:Xtensive.Core.Comparison.ComparisonRules"/>.
            </summary>
            <param name="direction">The direction to convert.</param>
            <returns>Conversion result.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.#ctor(Xtensive.Core.Comparison.ComparisonRule)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">Initial <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.#ctor(Xtensive.Core.Comparison.ComparisonRule,Xtensive.Core.Comparison.ComparisonRules[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">Initial <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> property value.</param>
            <param name="composite">Initial <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> property value.
            Last composite rule is considered as <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Tail"/> rule.</param>
        </member>
        <member name="M:Xtensive.Core.Comparison.ComparisonRules.#ctor(Xtensive.Core.Comparison.ComparisonRule,Xtensive.Core.Comparison.ComparisonRules[],Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">Initial <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Value"/> property value.</param>
            <param name="composite">Initial <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> property value.</param>
            <param name="tail">Tail comparison rule (repeated infinitely after composite rules).</param>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.Value">
            <summary>
            Gets primary <see cref="T:Xtensive.Core.Comparison.ComparisonRule"/> value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.Tail">
            <summary>
            Gets tail <see cref="T:Xtensive.Core.Comparison.ComparisonRules"/>.
            Tail rule is considered repeating infinitely 
            starting from <see cref="P:Xtensive.Core.Comparison.ComparisonRules.TailIndex"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.Count">
            <summary>
            Gets count of <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> rules.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.TailIndex">
            <summary>
            Gets <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Tail"/> rule index in <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/> rules.
            Always returns <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Count"/>-1.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.IsRecursive">
            <summary>
            Indicates whether rule is recursive - 
            i.e. its <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Count"/>==<see langword="1"/> and 
            <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Composite"/><see langword="[0]"/> returns itself.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.Item(System.Int32)">
            <summary>
            Gets composite rule for the specified index of composite value.
            </summary>
            <param name="index">Index of composite rule to get.</param>
            <returns>An instance of <see cref="T:Xtensive.Core.Comparison.ComparisonRules"/>, 
            if rule for specified <paramref name="index"/> is found; 
            otherwise, <see cref="P:Xtensive.Core.Comparison.ComparisonRules.Tail"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Comparison.ComparisonRules.Composite">
            <summary>
            Gets a copy of internal array of composite rules
            that are used to order composite values.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Pair`1">
            <summary>
            A pair of two values of the same type.
            </summary>
            <typeparam name="T">The type of both stored values.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Pair`1.First">
            <summary>
            The first value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Pair`1.Second">
            <summary>
            The second value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Pair`1.Equals(Xtensive.Core.Pair{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.CompareTo(Xtensive.Core.Pair{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.op_Equality(Xtensive.Core.Pair{`0},Xtensive.Core.Pair{`0})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.op_Inequality(Xtensive.Core.Pair{`0},Xtensive.Core.Pair{`0})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`1.#ctor(`0,`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="first">The first value in the pair.</param>
            <param name="second">The second value in the pair.</param>
        </member>
        <member name="T:Xtensive.Core.Reflection.ExecutionSequenceHandler`1">
            <summary>
            Execution sequence handler - a delegate that can be passed to 
            <see cref="M:Xtensive.Core.Reflection.DelegateHelper.ExecuteDelegates``1(Xtensive.Core.Reflection.ExecutionSequenceHandler{``0}[],``0@,Xtensive.Core.Direction)"/> method.
            </summary>
            <typeparam name="T">Argument type.</typeparam>
            <param name="argument">Argument value.</param>
            <param name="index">Index of executed delegate in sequence.</param>
            <returns><see langword="True"/>, if execution of sequence should be stopped;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Boolean}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Byte}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#SByte}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Int16}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#UInt16}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Int32}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#UInt32}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Int64}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#UInt64}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Single}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Double}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#DateTime}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#TimeSpan}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.DecimalRoughAdvancedConverter.Xtensive#Core#Conversion#IAdvancedConverter{System#Decimal@System#Char}#Convert(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.EnumerableInterfaceHasher`2.GetHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.EnumerableInterfaceHasher`2.GetHashes(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Comparison.ValueRangeInfo`1">
            <summary>
            Represents a pair of smallest and largest values defined for <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">the type of <typeparamref name="T"/>.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Comparison.ValueRangeInfo`1.Invert">
            <summary>
            Inverts the instance of <see cref="T:Xtensive.Core.Comparison.ValueRangeInfo`1"/>.
            Exactly, exchanges <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MinValue"/> and <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MaxValue"/>,
            and replaced <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.DeltaValue"/> to a negative one.
            </summary>
            <returns>Inverted <see cref="T:Xtensive.Core.Comparison.ValueRangeInfo`1"/> instance.</returns>
        </member>
        <member name="M:Xtensive.Core.Comparison.ValueRangeInfo`1.#ctor(System.Boolean,`0,System.Boolean,`0,System.Boolean,`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="hasMinValue">if set to <see langword="true"/> then this instance has the smallest possible value of <typeparamref name="T"/>.</param>
            <param name="minValue">The smallest possible value of <typeparamref name="T"/>.</param>
            <param name="hasMaxValue">if set to <see langword="true"/> then this instance has the largest possible value of <typeparamref name="T"/>.</param>
            <param name="maxValue">The largest possible value of <typeparamref name="T"/>.</param>
            <param name="hasDeltaValue">if set to <see langword="true"/> then this instance has the smallest possible delta value of <typeparamref name="T"/>.</param>
            <param name="deltaValue">The smallest possible delta value of <typeparamref name="T"/>.</param>
        </member>
        <member name="P:Xtensive.Core.Comparison.ValueRangeInfo`1.HasMinValue">
            <summary>
            Gets a value indicating whether this instance has <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MinValue"/>.
            </summary>
            <value>
              <see langword="true"/> if this instance has <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MinValue"/>; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:Xtensive.Core.Comparison.ValueRangeInfo`1.HasMaxValue">
            <summary>
            Gets a value indicating whether this instance has <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MaxValue"/>.
            </summary>
            <value>
              <see langword="true"/> if this instance has <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MaxValue"/>; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:Xtensive.Core.Comparison.ValueRangeInfo`1.HasDeltaValue">
            <summary>
            Gets a value indicating whether this instance has <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.DeltaValue"/>.
            </summary>
            <value>
              <see langword="true"/> if this instance has <see cref="P:Xtensive.Core.Comparison.ValueRangeInfo`1.DeltaValue"/>; otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MinValue">
            <summary>
            Represents the smallest possible value of a T.
            </summary>
            <value>The smallest possible value.</value>
        </member>
        <member name="P:Xtensive.Core.Comparison.ValueRangeInfo`1.MaxValue">
            <summary>
            Represents the largest possible value of a T.
            </summary>
            <value>The largest possible value.</value>
        </member>
        <member name="P:Xtensive.Core.Comparison.ValueRangeInfo`1.DeltaValue">
            <summary>
            Represents the smallest possible delta value of a <typeparamref name="T"/>.
            </summary>
            <value>The smallest possible delta value.</value>
        </member>
        <member name="T:Xtensive.Core.Comparison.WrappingComparer`3">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Comparison.IAdvancedComparer`1"/>s.
            </summary>
            <typeparam name="T">The type to compare.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Comparison.WrappingComparer`3.BaseComparer1">
            <summary>
            Comparer delegates for <typeparamref name="TBase1"/> type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Comparison.WrappingComparer`3.BaseComparer2">
            <summary>
            Comparer delegates for <typeparamref name="TBase2"/> type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Comparison.WrappingComparer`3.#ctor(Xtensive.Core.Comparison.IComparerProvider,Xtensive.Core.Comparison.ComparisonRules)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="provider">Comparer provider this comparer is bound to.</param>
            <param name="comparisonRules">Comparison rules.</param>
        </member>
        <member name="T:Xtensive.Core.Conversion.AdvancedConverterProvider">
            <summary>
            Default <see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/> provider. 
            Provides default converter for specified types.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Conversion.IAdvancedConverterProvider">
            <summary>
            Provides <see cref="T:Xtensive.Core.Conversion.AdvancedConverter`2"/>s.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.IAdvancedConverterProvider.GetConverter``2">
            <summary>
            Gets <see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/> for specified types <typeparamref name="TFrom"/> and <typeparamref name="TTo"/>.
            </summary>
            <typeparam name="TFrom">Type to convert from.</typeparam>
            <typeparam name="TTo">Type to convert to.</typeparam>
            <returns><see cref="T:Xtensive.Core.Conversion.IAdvancedConverter`2"/> instance  for specified types <typeparamref name="TFrom"/> and <typeparamref name="TTo"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Conversion.IAdvancedConverterProvider.BaseTime">
            <summary>
            Gets base time for <see cref="T:System.DateTime"/> conversions.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.AdvancedConverterProvider.ZeroTime">
            <summary>
            Zero time point (for conversion of <see cref="T:System.DateTime"/> to e.g. <see cref="T:System.Int32"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterProvider.GetConverter``2">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterProvider.PreferAssociate``3(``2,``2)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterProvider.CreateCustomAssociate``3">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterProvider.ConvertAssociate``4(``2)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.AdvancedConverterProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Conversion.AdvancedConverterProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Conversion.AdvancedConverterProvider.BaseTime">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HashableInterfaceHasher`1.GetHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HashableInterfaceHasher`1.GetHashes(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.TupleHasher.GetHash(Xtensive.Core.Tuples.Tuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.TupleHasher.GetHashes(Xtensive.Core.Tuples.Tuple,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Hashing.WrappingHasher`4">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Hashing.IHasher`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate <see cref="T:System.Int64"/> hashes for.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
            <typeparam name="TBase3">Third base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Hashing.WrappingHasher`4.BaseHasher1">
            <summary>
            Hasher for the first base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.WrappingHasher`4.BaseHasher2">
            <summary>
            Hasher for the second base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.WrappingHasher`4.BaseHasher3">
            <summary>
            Hasher for the third base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.WrappingHasher`4.#ctor(Xtensive.Core.Hashing.IHasherProvider)">
            <summary>
            Creates new instance of <see cref="T:Xtensive.Core.Hashing.WrappingHasher`3"/>.
            </summary>
            <param name="provider">Hasher provider.</param>
        </member>
        <member name="T:Xtensive.Core.Hashing.WrappingHasher`3">
            <summary>
            Base class for any wrapping <see cref="T:Xtensive.Core.Hashing.IHasher`1"/>s.
            </summary>
            <typeparam name="T">The type to calculate <see cref="T:System.Int64"/> hashes for.</typeparam>
            <typeparam name="TBase1">First base (wrapped) type.</typeparam>
            <typeparam name="TBase2">Second base (wrapped) type.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Hashing.WrappingHasher`3.BaseHasher1">
            <summary>
            Hasher for the first base (wrapped) type.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Hashing.WrappingHasher`3.BaseHasher2">
            <summary>
            Hasher for the second base (wrapped) type.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.WrappingHasher`3.#ctor(Xtensive.Core.Hashing.IHasherProvider)">
            <summary>
            Creates new instance of <see cref="T:Xtensive.Core.Hashing.WrappingHasher`3"/>.
            </summary>
            <param name="provider">Hasher provider.</param>
        </member>
        <member name="T:Xtensive.Core.IHashable">
            <summary>
            This interface should be implemented by classes, that can
            calculate <see cref="T:System.Int64"/> hashes.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHashable.Hash">
            <summary>
            Gets hash.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.EmitHelper">
            <summary>
            Code emission (via <see cref="N:System.Reflection.Emit"/>) helper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.EmitHelper.EmitIfElse(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.OpCode,System.Action,System.Action)">
            <summary>
            Helps to emit "if-else" or "if" block. 
            Implies all the necessary values <paramref name="brElse"/> operation needs
            are already on the stack.
            </summary>
            <param name="il">IL generator.</param>
            <param name="brElse">An opcode transferring </param>
            <param name="onTrue">Action to execute for "if" part.</param>
            <param name="onFalse">Action to execute for "else" part. Could be <see langword="null"/> for simple "if" statement.</param>
        </member>
        <member name="M:Xtensive.Core.Reflection.EmitHelper.EmitSwitch(System.Reflection.Emit.ILGenerator,System.Int32,System.Boolean,System.Action{System.Int32,System.Boolean})">
            <summary>
            Helps to emit "switch" block for all the integer values 
            in 0...<paramref name="valueCount"/> range. 
            Implies that switch argument is already on the stack.
            </summary>
            <param name="il">IL generator.</param>
            <param name="valueCount">Switch integer values count.</param>
            <param name="breakAnyCase">Break any case.</param>
            <param name="onLabel">Action to execute per any switch label.</param>
        </member>
        <member name="M:Xtensive.Core.Reflection.EmitHelper.EmitSwitch(System.Reflection.Emit.ILGenerator,System.Reflection.Emit.Label[],System.Boolean,System.Action{System.Int32,System.Boolean})">
            <summary>
            Helps to emit "switch" block for provided <paramref name="labels"/> using case values
            varying in <c>0</c>...<c>labels.Length-1</c> range. 
            Implies that switch argument is already on the stack.
            </summary>
            <param name="il">IL generator.</param>
            <param name="labels">An array of not marked yet labels to pass the control to.</param>
            <param name="breakAnyCase">Break any case.</param>
            <param name="onLabel">Action to execute per any switch label.</param>
        </member>
        <member name="T:Xtensive.Core.Reflection.MethodHelper">
            <summary>
            <see cref="T:System.Reflection.MethodInfo"/> related helper \ extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.GetMethod(System.Type,System.String,System.Reflection.BindingFlags,System.String[],System.Object[])">
            <summary>
            Gets generic method by names \ types of its arguments.
            </summary>
            <param name="type">Type to search the method in.</param>
            <param name="name">Method name.</param>
            <param name="bindingFlags">Binding attributes.</param>
            <param name="genericArgumentNames">Generic arguments of the method.</param>
            <param name="parameterTypes">Either strings or <see cref="T:System.Type"/>s of parameters (mixing is allowed).</param>
            <returns>Found method, if match was found;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.GetConstructor(System.Type,System.Reflection.BindingFlags,System.Object[])">
            <summary>
            Gets constructor by names \ types of its parameters.
            </summary>
            <param name="type">Type to search constructor in.</param>
            <param name="bindingFlags">Binding attributes.</param>
            <param name="parameterTypes">Either strings or <see cref="T:System.Type"/>s of parameters (mixing is allowed).</param>
            <returns>Found constructor, if match was found;
            otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.GetParameterTypes(System.Reflection.MethodBase)">
            <summary>
            Gets the types of method parameters.
            </summary>
            <param name="method">The method to get the types of parameters of.</param>
            <returns>The array of types of method parameters.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.IsPropertyAccessor(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is a property accessor.
            </summary>
            <param name="method">The method to check.</param>
            <returns>
            <see langword="true"/> if the specified method is property accessor; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.IsGetter(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is a property getter.
            </summary>
            <param name="method">The method to check.</param>
            <returns>
            <see langword="true"/> if the specified method is getter; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.IsSetter(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is a property setter.
            </summary>
            <param name="method">The method to check.</param>
            <returns>
            <see langword="true"/> if the specified method is setter; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.GetProperty(System.Reflection.MethodInfo)">
            <summary>
            Gets the property to which <paramref name="method"/> belongs.
            </summary>
            <param name="method">The method to get the property for.</param>
            <returns>Found property;
            <see langword="null" />, if no property is associated with the method.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.IsEventAccessor(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is an event accessor.
            </summary>
            <param name="method">The method to check.</param>
            <returns>
            <see langword="true"/> if the specified method is event accessor; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.IsAddEventHandler(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is "add event handler" method.
            </summary>
            <param name="method">The method to check.</param>
            <returns>
            <see langword="true"/> if the specified method is "add event handler" method; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.IsRemoveEventHandler(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the specified method is "remove event handler" method.
            </summary>
            <param name="method">The method to check.</param>
            <returns>
            <see langword="true"/> if the specified method is "remove event handler" method; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.MethodHelper.GetEvent(System.Reflection.MethodInfo)">
            <summary>
            Gets the event to which <paramref name="method"/> belongs.
            </summary>
            <param name="method">The method to get the event for.</param>
            <returns>Found event;
            <see langword="null" />, if no event is associated with the method.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.BufferedEnumerable`1.System#Collections#Generic#IEnumerable{TItem}#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.BufferedEnumerable`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.BufferedEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.BufferedEnumerable`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.BufferedEnumerable`1.Count">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.DirectionCollection`1">
            <summary>
             A sequence of <typeparamref name="T"/>-<see cref="T:Xtensive.Core.Direction"/> pairs.
             Normally used to describe "order by" clauses.
            </summary>
             <typeparam name="T">The type of collection item to associate with direction.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Collections.FlagCollection`2">
            <summary>
            A sequence of <typeparamref name="TKey"/>-<typeparamref name="TFlag"/> pairs.
            </summary>
            <remarks>
            Item count should be less than 32.
            <see cref="T:Xtensive.Core.Conversion.Biconverter`2"/> is used to convert flag keys from type <typeparamref name="TFlag"/> to <see cref="T:System.Boolean"/>.
            </remarks>
            <typeparam name="TKey">Type of the key.</typeparam>
            <typeparam name="TFlag">Type of the flag.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Add(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.TryGetValue(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#IList{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#IndexOf(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#IList{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#Insert(System.Int32,System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#IList{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TFlag}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Equals(Xtensive.Core.Collections.FlagCollection{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.#ctor(Xtensive.Core.Conversion.Biconverter{`1,System.Boolean})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="converter"><see cref="P:Xtensive.Core.Collections.FlagCollection`2.Converter"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.#ctor(Xtensive.Core.Conversion.Biconverter{`1,System.Boolean},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="converter"><see cref="P:Xtensive.Core.Collections.FlagCollection`2.Converter"/> property value.</param>
            <param name="enumerable">Initial content of collection.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Collections.FlagCollection`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Converter">
            <summary>
            Gets <see cref="T:Xtensive.Core.Conversion.Biconverter`2"/> instance
            used to convert flag value to <see cref="T:System.Boolean"/> and vice versa.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Flags">
            <summary>
            Gets an <see cref="T:System.Collections.ObjectModel.Collection`1"/> containing the flags.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Item(`0)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Keys">
            <summary>
            Gets a list of keys.
            </summary>
            <returns>A list of keys.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#IDictionary{TKey@TFlag}#Keys">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Values">
            <summary>
            Gets an array of values.
            </summary>
            <returns>An array of values.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.System#Collections#Generic#IDictionary{TKey@TFlag}#Values">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.FlagCollection`2.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DirectionCollection`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DirectionCollection`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,Xtensive.Core.Direction}})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="enumerable">Initial content of collection.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.DirectionCollection`1.#ctor(`0[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="items">Initial content of collection.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.DirectionCollection`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.ArrayUtils`1">
            <summary>
            <see cref="T:System.Array"/> related utilities.
            </summary>
            <typeparam name="TItem">Type of array item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.ArrayUtils`1.Create(System.Int32)">
            <summary>
            Creates a new 1-dimensional array of specified <paramref name="size"/>,
            if <paramref name="size"/> isn't <see langword="0"/>;
            otherwise, returns <see cref="P:Xtensive.Core.Collections.ArrayUtils`1.EmptyArray"/>.
            </summary>
            <param name="size">Size of the array to create.</param>
            <returns>Created array, if <paramref name="size"/> isn't <see langword="0"/>;
            otherwise, <see cref="P:Xtensive.Core.Collections.ArrayUtils`1.EmptyArray"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.ArrayUtils`1.EmptyArray">
            <summary>
            Gets empty array of items of <typeparamref name="TItem"/> type.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.IFilterable`2">
            <summary>
            Defines contract for a filterable collection of <typeparamref name="TItem"/>s.
            </summary>
            <typeparam name="TFilter">The type of the filter.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IFilterable`2.Find(`0)">
            <summary>
            Finds the items from initial collection according to specified filter <paramref name="criteria"/>.
            </summary>
            <param name="criteria">The object to filter initial collection with.</param>
            <returns><see cref="T:Xtensive.Core.Collections.ICountable`1"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IFilterable`2.Find(`0,Xtensive.Core.MatchType)">
            <summary>
            Finds the items from initial collection according to specified filter <paramref name="criteria"/>.
            </summary>
            <param name="criteria">The object to filter initial collection with.</param>
            <param name="matchType">Type of the match.</param>
            <returns><see cref="T:Xtensive.Core.Collections.ICountable`1"/> object.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.FixedList3`1">
            <summary>
            Defines a fixed stack-like list with three items.
            </summary>
            <typeparam name="T">Type of items.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.FixedList3`1.Push(`0)">
            <summary>
            Adds item to the <see cref="T:Xtensive.Core.Collections.FixedList3`1"/> list.
            </summary>
            <param name="item">Item to add.</param>
            <exception cref="T:System.ArgumentException">The list already have three items.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.FixedList3`1.Pop">
            <summary>
            Removes latest item from the <see cref="T:Xtensive.Core.Collections.FixedList3`1"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.FixedList3`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.FixedList3`1.#ctor(`0,`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="first">First item to add.</param>
            <param name="second">Second item ot add.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.FixedList3`1.#ctor(`0,`0,`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="first">First item to add.</param>
            <param name="second">Second item ot add.</param>
            <param name="third">Third item to add.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.FixedList3`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">Index of the item</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The index is greater or equal count of items.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.FixedList3`1.Items">
            <summary>
            Enumerates all items.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.FixedList3`1.Count">
            <summary>
            Gets count of items.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.Set`1">
            <summary>
            A set of items (with event-handling support).
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Collections.SetSlim`1">
            <summary>
            Represents a set of items.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.SetSlim`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.SetSlim`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="comparer">The equality comparer to use.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.SetSlim`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="items">Collection to copy the items from.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.SetSlim`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="items">Collection to copy the items from.</param>
            <param name="comparer">The equality comparer to use.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.SetSlim`1.Items">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Notifications.ICollectionChangeNotifier`1">
            <summary>
            A collection exposing the collection change events contract.
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Notifications.IChangeNotifier">
            <summary>
            An object exposing change related events contract.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.IChangeNotifier.Changing">
            <summary>
            Occurs when this instance is about to be changed.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.IChangeNotifier.Changed">
            <summary>
            Occurs when this instance is changed.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Clearing">
            <summary>
            Occurs when collection is intended to be cleared.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Cleared">
            <summary>
            Occurs when collection was cleared.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Validate">
            <summary>
            Occurs when collection validates new item.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Inserting">
            <summary>
            Occurs when item is inserting into collection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Inserted">
            <summary>
            Occurs when item was inserted into collection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Removing">
            <summary>
            Occurs when item is removing from collection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.Removed">
            <summary>
            Occurs when item was removed from collection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.ItemChanging">
            <summary>
            Occurs when item is about to be changed.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Notifications.ICollectionChangeNotifier`1.ItemChanged">
            <summary>
            Occurs when item is changed.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnChanging">
            <summary>
            Performs additional custom processes when changing the contents of the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnChanged">
            <summary>
            Performs additional custom processes after the contents of the 
            collection instance was changed.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnClearing">
            <summary>
            Performs additional custom processes when clearing the contents of the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnCleared">
            <summary>
            Performs additional custom processes after clearing the contents of the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnInserting(`0)">
            <summary>
            Performs additional custom processes before inserting a new element into the
            collection instance.
            </summary>
            <param name="value">The value to insert.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnInserted(`0)">
            <summary>
            Performs additional custom processes after inserting a new element into the
            collection instance.
            </summary>
            <param name="value">The inserted value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnRemoving(`0)">
            <summary>
            Performs additional custom processes before removing an element from the
            collection instance.
            </summary>
            <param name="value">The item to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnRemoved(`0)">
            <summary>
            Performs additional custom processes after removing an element from the
            collection instance.
            </summary>
            <param name="value">The item to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnValidate(`0)">
            <summary>
            Performs additional custom processes when validating a value.
            </summary>
            <param name="value">The object to validate.</param>
            <remarks>
            The default implementation of this method determines whether value is a <see langword="null"/> 
            reference (Nothing in Visual Basic), and, if so, throws <see cref="T:System.ArgumentNullException"/>. 
            It is intended to be overridden by a derived class to perform additional action 
            when the specified element is validated.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnItemChanging(System.Object,Xtensive.Core.Notifications.ChangeNotifierEventArgs)">
            <summary>
            Called when item is about to be changed.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:Xtensive.Core.Notifications.ChangeNotifierEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.OnItemChanged(System.Object,Xtensive.Core.Notifications.ChangeNotifierEventArgs)">
            <summary>
            Called when item was changed.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:Xtensive.Core.Notifications.ChangeNotifierEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="comparer">Equality comparer for the set type.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="items">Collection to copy the items from.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Set`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="items">Collection to copy the items from.</param>
            <param name="comparer">Equality comparer for the set type.</param>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Changing">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Changed">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Validate">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Clearing">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Cleared">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Inserting">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Inserted">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Removing">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.Removed">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.ItemChanging">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Set`1.ItemChanged">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.StringLog">
            <summary>
            Log writing all events to <see cref="T:System.Text.StringBuilder"/> <see cref="P:Xtensive.Core.Diagnostics.StringLog.Output"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.StringLog.LogEventText(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.StringLog.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">Log name.</param>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.StringLog.Output">
            <summary>
            Gets output of this log (as <see cref="T:System.Text.StringBuilder"/>).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.StringLog.Text">
            <summary>
            Gets output of this log (as <see cref="T:System.String"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.BaseHasherWrapper`2.GetHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.BaseHasherWrapper`2.GetHashes(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ValueTypeHasher`1.GetHash(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ValueTypeHasher`1.GetHashes(`0,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.KeyValuePairHasher`2.GetHash(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.KeyValuePairHasher`2.GetHashes(System.Collections.Generic.KeyValuePair{`0,`1},System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.PairHasher`2.GetHash(Xtensive.Core.Pair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.PairHasher`2.GetHashes(Xtensive.Core.Pair{`0,`1},System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.TripletHasher`3.GetHash(Xtensive.Core.Triplet{`0,`1,`2})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.TripletHasher`3.GetHashes(Xtensive.Core.Triplet{`0,`1,`2},System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ByteHasher.GetHash(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ByteHasher.GetHashes(System.Byte,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Hashing.HasherProvider">
            <summary>
            Default <see cref="T:Xtensive.Core.Hashing.IHasher`1"/> provider. 
            Provides default hasher for the specified type.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Hashing.IHasherProvider">
            <summary>
            Hasher provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.IHasherProvider.GetHasher``1">
            <summary>
            Gets <see cref="T:Xtensive.Core.Hashing.IHasher`1"/> for the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to get the hasher for.</typeparam>
            <returns><see cref="T:Xtensive.Core.Hashing.IHasher`1"/> for the specified type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.IHasherProvider.GetHasherByInstance(System.Object)">
            <summary>
            Gets <see cref="T:Xtensive.Core.Hashing.IHasherBase"/> for the specified <paramref name="value"/>.
            </summary>
            <param name="value">Value to get the hasher for.</param>
            <returns><see cref="T:Xtensive.Core.Hashing.IHasherBase"/> for the specified <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.IHasherProvider.GetHasherByType(System.Type)">
            <summary>
            Gets <see cref="T:Xtensive.Core.Hashing.IHasherBase"/> for the specified <paramref name="type"/>.
            </summary>
            <param name="type">Type to get the hasher for.</param>
            <returns><see cref="T:Xtensive.Core.Hashing.IHasherBase"/> for the specified <paramref name="type"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherProvider.GetHasher``1">
            <summary>
            Gets <see cref="T:Xtensive.Core.Hashing.IHasher`1"/> for the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to get the hasher for.</typeparam>
            <returns><see cref="T:Xtensive.Core.Hashing.IHasher`1"/> for the specified type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherProvider.GetHasherByInstance(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherProvider.GetHasherByType(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherProvider.CreateAssociate``2(System.Type@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherProvider.ConvertAssociate``3(``1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.HasherProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Hashing.HasherProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Hashing.HashingUtils">
            <summary>
            Helps to manipulate hashes.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Hashing.HashingUtils.GetHash(System.Byte[])">
            <summary>
            Calculates hash.
            </summary>
            <param name="value">Object to calculate hash to.</param>
            <returns>Hash.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.HashingUtils.GetHashes(System.Byte[],System.Int32)">
            <summary>
            Calculates <paramref name="count"/> of different hashes at once.
            </summary>
            <param name="data">Object to calculate hashes for.</param>
            <param name="count">Count of hashes to calculate, should be less then Byte.MaxValue.</param>
            <returns>Array of <paramref name="count"/> hashes.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.HashingUtils.GetHashes(System.Byte[],System.Int32,System.Int64)">
            <summary>
            Calculates <paramref name="count"/> of different hashes at once.
            </summary>
            <param name="data">Object to calculate hashes for.</param>
            <param name="count">Count of hashes to calculate, should be less then Byte.MaxValue.</param>
            <param name="firstHash">First hash value.</param>
            <returns>Array of <paramref name="count"/> hashes.</returns>
        </member>
        <member name="M:Xtensive.Core.Hashing.HashingUtils.WriteHashes(System.Int64[],System.Int32,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Calculates <paramref name="count"/> of different hashes at once
            and fills them into <paramref name="writeTo"/> array.
            </summary>
            <param name="writeTo">Array to write calculated hashes to.</param>
            <param name="offset">Offset to start writing from.</param>
            <param name="data">Object to calculate hashes for.</param>    
            <param name="count">Count of hashes to calculate, should be less then Byte.MaxValue.</param>
            <param name="writeFirstHash">Specifies whether to write first hash code or not.</param>
        </member>
        <member name="M:Xtensive.Core.Hashing.ArrayHasher`1.GetHash(`0[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ArrayHasher`1.GetHashes(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.BooleanHasher.GetHash(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.BooleanHasher.GetHashes(System.Boolean,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.DateTimeHasher.GetHash(System.DateTime)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.DateTimeHasher.GetHashes(System.DateTime,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.DecimalHasher.GetHash(System.Decimal)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.DecimalHasher.GetHashes(System.Decimal,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.DoubleHasher.GetHash(System.Double)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.DoubleHasher.GetHashes(System.Double,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.NullableHasher`1.GetHash(System.Nullable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.NullableHasher`1.GetHashes(System.Nullable{`0},System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.SByteHasher.GetHash(System.SByte)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.SByteHasher.GetHashes(System.SByte,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.SingleHasher.GetHash(System.Single)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.SingleHasher.GetHashes(System.Single,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.GuidHasher.GetHash(System.Guid)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.GuidHasher.GetHashes(System.Guid,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.Int16Hasher.GetHash(System.Int16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.Int16Hasher.GetHashes(System.Int16,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.Int32Hasher.GetHash(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.Int32Hasher.GetHashes(System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.Int64Hasher.GetHash(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.Int64Hasher.GetHashes(System.Int64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.StringHasher.GetHash(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.StringHasher.GetHashes(System.String,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.UInt16Hasher.GetHash(System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.UInt16Hasher.GetHashes(System.UInt16,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.UInt32Hasher.GetHashes(System.UInt32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.UInt64Hasher.GetHash(System.UInt64)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.UInt64Hasher.GetHashes(System.UInt64,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ObjectHasher.GetHash(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Hashing.ObjectHasher.GetHashes(System.Object,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.DictionaryBaseSlim`2">
            <summary>
            Base class for dictionary mapping keys to values.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.Add(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.SetValue(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.TryGetValue(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.Values">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.Item(`0)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.DictionaryBaseSlim`2.ValueCollection">
            <summary>
            Value collection used by <see cref="T:Xtensive.Core.Collections.DictionaryBaseSlim`2"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1">
            <summary>
            Base class for keys \ values collections used by 
            <see cref="T:Xtensive.Core.Collections.DictionaryBaseSlim`2"/>.
            </summary>
            <typeparam name="T">The type of stored item.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.dictionary">
            <summary>
            Inner dictionary.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.CopyTo(`2[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.Contains(`2)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.GetItem(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.Remove(`2)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.Add(`2)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="dictionary">Inner <see cref="F:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.dictionary"/> object.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.ValueCollection.GetItem(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.ValueCollection.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="dictionary">Inner <see cref="F:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.dictionary"/> object.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyCollection">
            <summary>
            Key collection used by <see cref="T:Xtensive.Core.Collections.DictionaryBaseSlim`2"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyCollection.GetItem(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyCollection.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyCollection.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="dictionary">Inner <see cref="F:Xtensive.Core.Collections.DictionaryBaseSlim`2.KeyOrValueCollectionBase`1.dictionary"/> object.</param>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.ISizeCalculatorAware">
            <summary>
            Describes an object that is aware of <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculatorAware.GetSize(Xtensive.Core.SizeCalculators.ISizeCalculatorProvider)">
            <summary>
            Gets the size of the object (in stack plus heap).
            </summary>
            <param name="provider">The size calculator provider to use for calculating fields size.</param>
            <returns>The size of the object (in stack plus heap, in bytes).</returns>
        </member>
        <member name="T:Xtensive.Core.StreamExtensions">
            <summary>
            Helper class providing a set of useful stream operations.
            </summary>
        </member>
        <member name="M:Xtensive.Core.StreamExtensions.Erase(System.IO.Stream)">
            <summary>
            Fills the stream with zero bytes 
            starting from the current position 
            and up to the end of it.
            </summary>
            <param name="stream">The stream to erase.</param>
            <returns>Count of actually erased bytes.</returns>
        </member>
        <member name="M:Xtensive.Core.StreamExtensions.Erase(System.IO.Stream,System.Int64)">
            <summary>
            Fills the stream with specified count of zero bytes
            starting from the current position.
            If count is greater than the tail of the stream (count &gt; Length-Position), 
            the stream will be erased up to its end.
            </summary>
            <param name="stream">The stream to erase.</param>
            <param name="count">Count of bytes to erase.</param>
            <returns>Count of actually erased bytes.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is out of range.</exception>
        </member>
        <member name="M:Xtensive.Core.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies the part of the <paramref name="source"/> stream 
            to the <paramref name="destination"/> stream
            starting from the current positions 
            and up to the end of the <paramref name="source"/> stream.
            </summary>
            <param name="source">The stream to copy from.</param>
            <param name="destination">The stream to copy to.</param>
            <returns>Count of actually copied bytes.</returns>
            <remarks>Destination stream can be prolonged to fit the data.</remarks>
        </member>
        <member name="M:Xtensive.Core.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Int64)">
            <summary>
            Copies specified count of bytes 
            from the <paramref name="source"/> stream 
            to the <paramref name="destination"/> stream
            starting from the current positions.
            </summary>
            <param name="source">The stream to copy from.</param>
            <param name="destination">The stream to copy to.</param>
            <param name="count">Count of bytes to copy.</param>
            <returns>Count of actually copied bytes.</returns>
            <remarks>Destination stream can be prolonged to fit the data.</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is out of range.</exception>
            <exception cref="T:System.NotSupportedException"><paramref name="destination"/> and <paramref name="source"/> is the same stream.</exception>
        </member>
        <member name="M:Xtensive.Core.StreamExtensions.Copy(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Copies a part of the stream within the stream
            to the current position of it.
            </summary>
            <param name="stream">The stream to copy a part of.</param>
            <param name="offset">Offset of the part to copy from.</param>
            <param name="count">Count of bytes to copy.</param>
            <returns>Count of actually copied bytes.</returns>
            <remarks>Stream can be prolonged to fit the data.</remarks>
        </member>
        <member name="T:Xtensive.Core.MatchType">
            <summary>
            Possible types of match to look for.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogIndent">
            <summary>
            Used internally by <see cref="T:Xtensive.Core.Diagnostics.LogIndentScope"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogIndent.Xtensive#Core#IoC#IContext#Activate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogIndent.Activate">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogIndent.IsActive">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogIndentScope">
            <summary>
            Log indent scope. 
            An instance of this class adds indent to all logged messages
            in the current thread. Dispose the instance to remove the indent.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogIndentScope.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogIndentScope.CurrentIndent">
            <summary>
            Gets current indent value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogIndentScope.CurrentIndentString">
            <summary>
            Gets current indent as string.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogIndentScope.Indent">
            <summary>
            Gets the indent associated with this scope.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogIndentScope.IndentString">
            <summary>
            Gets the indent associated with this scope as string.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogEventHandler">
            <summary>
            <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/> event handler (see <see cref="E:Xtensive.Core.Diagnostics.IRealLog.OnLogEvent"/>).
            </summary>
            <param name="source">Event source.</param>
            <param name="eventType">Event type.</param>
            <param name="message">Message to log.</param>
            <param name="exception">Exception to log.</param>
            <param name="capturedBy">The scope which captured this event, if any.</param>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogEventTypes">
            <summary>
            <see cref="T:Xtensive.Core.Diagnostics.IRealLog"/> event types.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.None">
            <summary>
            None of the events.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.Debug">
            <summary>
            Debug-only event.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.Info">
            <summary>
            Information.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.Warning">
            <summary>
            Warning.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.Error">
            <summary>
            Error.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.FatalError">
            <summary>
            Fatal error.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.LogEventTypes.All">
            <summary>
            All events.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Notifications.CollectionChangeNotifierEventArgs`1">
            <summary>
            Represents class that contains <see cref="T:Xtensive.Core.Notifications.ICollectionChangeNotifier`1"/> related event data.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Notifications.CollectionChangeNotifierEventArgs`1.#ctor(`0,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The item.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Xtensive.Core.Notifications.CollectionChangeNotifierEventArgs`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="P:Xtensive.Core.Notifications.CollectionChangeNotifierEventArgs`1.Index">
            <summary>
            Gets the item's index if any.
            </summary>
            <value>The index.</value>
        </member>
        <member name="P:Xtensive.Core.Notifications.CollectionChangeNotifierEventArgs`1.Item">
            <summary>
            Gets the item.
            </summary>
            <value>The item.</value>
        </member>
        <member name="T:Xtensive.Core.Notifications.ChangeNotifierEventArgs">
            <summary>
            Represents a set of information describing <see cref="T:Xtensive.Core.Notifications.IChangeNotifier"/> change.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Notifications.ChangeNotifierEventArgs.#ctor(System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="changeInfo">The info.</param>
        </member>
        <member name="M:Xtensive.Core.Notifications.ChangeNotifierEventArgs.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Notifications.ChangeNotifierEventArgs.ChangeInfo">
            <summary>
            Gets the object representing some additional change information.
            </summary>
            <value>The info.</value>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.DebugInfo">
            <summary>
            Provides various debugging related information.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.DebugInfo.IsUnitTestSessionRunning">
            <summary>
            <see langword="True"/>, if current method is executed under unit test runner.
            </summary>
            <remarks>
            Currently only NUnit tests are recognized.
            Note that value of this property is detected just once - during its first call.
            </remarks>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.DebugInfo.IsRunningOnBuildServer">
            <summary>
            <see langword="True"/>, if current method is executed on build server.
            </summary>
            <remarks>
            Currently only TeamCity is recognized.
            Note that value of this property is detected just once - during its first call.
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.LogCaptureScope">
            <summary>
            Log capture scope.
            Forward all the log messages sent to any <see cref="T:Xtensive.Core.Diagnostics.LogTemplate`1"/> (or to the specified set of them) 
            to specified <see cref="T:Xtensive.Core.Diagnostics.Log"/> as well.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.Clear">
            <summary>
            Clears captured event types state.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.IsCaptured(Xtensive.Core.Diagnostics.LogEventTypes)">
            <summary>
            Returns <see langword="true"/> if at least one event with specified event type are captured by current instance of <see cref="T:Xtensive.Core.Diagnostics.LogCaptureScope"/>.
            </summary>
            <param name="eventType">Event type to check.</param>
            <returns><see langword="true"/> if this scope captured events with specified 
            event type; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.IsCapturing(Xtensive.Core.Diagnostics.LogEventTypes)">
            <summary>
            Returns <see langword="true"/> if this or outer scope should capture specified 
            event type.
            </summary>
            <param name="eventType">Event type to check.</param>
            <returns><see langword="True"/> if this or outer scope should capture specified 
            event type.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.IsCapturing(Xtensive.Core.Diagnostics.ILog)">
            <summary>
            Returns <see langword="true"/> if this scope should capture events from 
            specified <see cref="T:Xtensive.Core.Diagnostics.ILog"/>.
            </summary>
            <param name="log">Log to check.</param>
            <returns><see langword="True"/> if this scope should capture events from 
            specified <see cref="T:Xtensive.Core.Diagnostics.ILog"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.Activate(Xtensive.Core.Diagnostics.ILog)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.#ctor(Xtensive.Core.Diagnostics.ILog,Xtensive.Core.Diagnostics.ILog[])">
            <summary>
            Creates a new instance of this class.
            </summary>
            <param name="log">New log to use.</param>
            <param name="captureFilter">A set of logs which events should be captured;
            <see langword="null"/> means events from all logs should be captured.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.#ctor(Xtensive.Core.Diagnostics.ILog,System.Boolean,Xtensive.Core.Diagnostics.ILog[])">
            <summary>
            Creates a new instance of this class.
            </summary>
            <param name="log">New log to use.</param>
            <param name="logEnterLeave">Logs entering and leaving this scope.</param>
            <param name="captureFilter">A set of logs which events should be captured;
            <see langword="null"/> means events from all logs should be captured.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.LogCaptureScope.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogCaptureScope.CaptureEventTypes">
            <summary>
            Gets enabled event types for this and outer <see cref="T:Xtensive.Core.Diagnostics.LogCaptureScope"/>s.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogCaptureScope.CaptureFilter">
            <summary>
            Gets capture filter for this scope.
            <see langword="Null"/> implies events from all <see cref="T:Xtensive.Core.Diagnostics.ILog"/>s are captured.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.LogCaptureScope.InitialIndent">
            <summary>
            Gets <see cref="P:Xtensive.Core.Diagnostics.LogIndentScope.Indent"/> value on the moment
            when this <see cref="T:Xtensive.Core.Diagnostics.LogCaptureScope"/> was created.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.MeasurementOptions">
            <summary>
            <see cref="T:Xtensive.Core.Diagnostics.Measurement"/> options.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.None">
            <summary>
            Don't collect garbage and don't write to log.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.Default">
            <summary>
            Default measurement options: <see cref="F:Xtensive.Core.Diagnostics.MeasurementOptions.Log"/>, <see cref="F:Xtensive.Core.Diagnostics.MeasurementOptions.CollectGarbageOnEnter"/>, <see cref="F:Xtensive.Core.Diagnostics.MeasurementOptions.CollectGarbageOnLeave"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.CollectGarbage">
            <summary>
            Indicates whether garbage must be collected both on enter and leave.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.CollectGarbageOnEnter">
            <summary>
            Indicates whether garbage must be collected on enter.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.CollectGarbageOnLeave">
            <summary>
            Indicates whether garbage must be collected on leave.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.Log">
            <summary>
            Indicates whether measurement results must be logged.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Diagnostics.MeasurementOptions.LogEnter">
            <summary>
            Indicates whether measurement start must be logged.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Exceptions">
            <summary>
            Most common <see cref="T:System.Exception"/> factory.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Exceptions.InternalError(System.String,Xtensive.Core.Diagnostics.ILog)">
            <summary>
            Returns an exception informing internal error has occurred.
            </summary>
            <param name="description">Error description.</param>
            <param name="log"><see cref="T:Xtensive.Core.Diagnostics.ILog"/> instance to log the problem;
            <see langword="null"/> means logging is not necessary.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.InvalidUrl(System.String,System.String)">
            <summary>
            Returns an exception informing that URL is invalid.
            </summary>
            <param name="url">Invalid URL.</param>
            <param name="parameterName">Name of method parameter where URL was passed (<see langword="null"/> if none).</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.AlreadyInitialized(System.String)">
            <summary>
            Returns an exception informing that object or property is already initialized.
            </summary>
            <param name="propertyName">Name of the property; <see langword="null"/>, if none.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.AlreadyDisposed(System.String)">
            <summary>
            Returns an exception informing that object is already disposed.
            </summary>
            <param name="objectName">Name of the object; <see langword="null"/>, if none.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.NotInitialized(System.String)">
            <summary>
            Returns an exception informing that object or property is not initialized,
            or not initialized properly.
            </summary>
            <param name="propertyName">Name of the property; <see langword="null"/>, if none.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.InvalidArgument``1(``0,System.String)">
            <summary>
            Returns an exception informing that specified argument
            value is not allowed or invalid.
            </summary>
            <param name="value">Actual parameter value.</param>
            <param name="parameterName">Name of the method parameter (<see langword="null"/> if none).</param>
            <returns>Newly created exception.</returns>
            <typeparam name="T">The type of the value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Exceptions.ObjectIsReadOnly(System.String)">
            <summary>
            Returns an exception informing that object is read-only.
            </summary>
            <param name="parameterName">Name of the method parameter (<see langword="null"/> if none).</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.CollectionIsEmpty(System.String)">
            <summary>
            Returns an exception informing that collection is empty.
            </summary>
            <param name="parameterName">Name of the method parameter (<see langword="null"/> if none).</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.CollectionIsReadOnly(System.String)">
            <summary>
            Returns an exception informing that collection is read-only.
            </summary>
            <param name="parameterName">Name of the method parameter (<see langword="null"/> if none).</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.CollectionHasBeenChanged(System.String)">
            <summary>
            Returns an exception informing that collection has been changed during the enumeration.
            </summary>
            <param name="parameterName">Name of the method parameter (<see langword="null"/> if none).</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.ContextRequired(System.Type,System.Type)">
            <summary>
            Returns an exception informing that context is required.
            </summary>
            <param name="contextType">Type of required context.</param>
            <param name="scopeType">Type of <see cref="!:Scope&lt;TContext&gt;"/> used to set the context.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.ContextRequired``2">
            <summary>
            Returns an exception informing that context is required.
            </summary>
            <typeparam name="TContext">The type of the context.</typeparam>
            <typeparam name="TScope">The type of the scope.</typeparam>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.ScopeRequired(System.Type)">
            <summary>
            Returns an exception informing that scope is required.
            </summary>
            <param name="scopeType">Type of <see cref="!:SimpleScope&lt;TContext&gt;"/> used to set the context.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.ScopeRequired``1">
            <summary>
            Returns an exception informing that scope is required.
            </summary>
            <typeparam name="TScope">The type of the scope.</typeparam>
            <returns>Newly created exception.</returns>
        </member>
        <member name="M:Xtensive.Core.Exceptions.LambdaParameterIsOutOfScope(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Returns an exception informing that specified <see cref="T:System.Linq.Expressions.ParameterExpression"/> is out of scope.
            </summary>
            <param name="parameter">The parameter.</param>
            <returns>Newly created exception.</returns>
        </member>
        <member name="T:Xtensive.Core.SystemTimeChangedException">
            <summary>
            Thrown by <see cref="P:Xtensive.Core.Diagnostics.HighResolutionTime.Now"/> method when it
            notices system time has been changed.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SystemTimeChangedException.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.SystemTimeChangedException.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="text">Text of message.</param>
        </member>
        <member name="M:Xtensive.Core.SystemTimeChangedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> object.</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> object.</param>
        </member>
        <member name="T:Xtensive.Core.ArgumentValidator">
            <summary>
            Helper class validation most common error conditions.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentNotNull(System.Object,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is not
            <see langoword="null"/>.
            </summary>
            <param name="value">Value to compare with <see langword="null"/>.</param>
            <param name="parameterName">Name of the method parameter.</param>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsNotDefault``1(``0,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is not
            <see langoword="null"/>.
            </summary>
            <param name="value">Value to compare with <see langword="null"/>.</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The type of default value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentNotNullOrEmpty(System.String,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is not
            <see langoword="null"/> or <see cref="F:System.String.Empty"/> string.
            </summary>
            <param name="value">Value to check.</param>
            <param name="parameterName">Name of the method parameter.</param>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIs``1(System.Object,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is not <see langword="null"/> 
            and of <typeparamref name="T"/> type.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The expected type of value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIs(System.Object,System.Type,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is not <see langword="null"/> 
            and of <paramref name="type"/> type.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="type">The expected type of value.</param>
            <param name="parameterName">Name of the method parameter.</param>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsNullOr``1(System.Object,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is either <see langword="null"/>,
            or of <typeparamref name="T"/> type.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The expected type of value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsInRange``1(``0,``0,``0,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is either <see langword="null"/>,
            or of <typeparamref name="T"/> type.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="lowerBoundary">Lower range boundary (inclusively).</param>
            <param name="upperBoundary">Upper range boundary (inclusively).</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The type of value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsGreaterThan``1(``0,``0,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is greater then the specified <paramref name="boundary"/> value.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="boundary">Value boundary.</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The type of value.</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsGreaterThanOrEqual``1(``0,``0,System.String)" -->
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsLessThan``1(``0,``0,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is less then
            the specified <paramref name="boundary"/> value.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="boundary">Value boundary.</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The type of value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ArgumentValidator.EnsureArgumentIsLessThanOrEqual``1(``0,``0,System.String)">
            <summary>
            Ensures argument (<paramref name="value"/>) is less then or equal
            the specified <paramref name="boundary"/> value.
            </summary>
            <param name="value">Value to compare check.</param>
            <param name="boundary">Value boundary.</param>
            <param name="parameterName">Name of the method parameter.</param>
            <typeparam name="T">The type of value.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Conversion.Biconverter`2">
            <summary>
            Delegate-based implementation.
            </summary>
            <typeparam name="TFrom">Type to convert from.</typeparam>
            <typeparam name="TTo">Type to convert to.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Conversion.Biconverter`2.ConvertForward">
            <summary>
            Gets the delegate converting specified value 
            from <typeparamref name="TFrom"/>
            to <typeparamref name="TTo"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Conversion.Biconverter`2.ConvertBackward">
            <summary>
            Gets the delegate converting specified value 
            from <typeparamref name="TTo"/>
            to <typeparamref name="TFrom"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Conversion.Biconverter`2.Equals(Xtensive.Core.Conversion.Biconverter{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.Biconverter`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.Biconverter`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.Biconverter`2.#ctor(System.Converter{`0,`1},System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="convertForward">Forward converter.</param>
            <param name="convertBackward">Backward converter.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.Biconverter`2.#ctor(Xtensive.Core.Conversion.IAdvancedConverter{`0,`1},Xtensive.Core.Conversion.IAdvancedConverter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="forwardConverter">Forward converter.</param>
            <param name="backwardConverter">Backward converter.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.Biconverter`2.#ctor(Xtensive.Core.Conversion.IBiconverter{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="biconverter">The biconverter.</param>
        </member>
        <member name="P:Xtensive.Core.Conversion.Biconverter`2.AsIs">
            <summary>
            Gets the "as is" bidirectional converter.
            Note: it involves boxing on any conversion (for <see cref="T:System.ValueType"/>s).
            </summary>
        </member>
        <member name="T:Xtensive.Core.LockType">
            <summary>
            Enumerates possible locks types.
            </summary>
        </member>
        <member name="F:Xtensive.Core.LockType.None">
            <summary>
            No lock.
            Value is <see langword="0" />.
            </summary>
        </member>
        <member name="F:Xtensive.Core.LockType.Read">
            <summary>
            Read lock.
            Value is <see langword="1" />.
            </summary>
        </member>
        <member name="F:Xtensive.Core.LockType.Shared">
            <summary>
            Shared lock. The same as <see cref="F:Xtensive.Core.LockType.Read"/> lock.
            Value is <see langword="0"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.LockType.Write">
            <summary>
            Write lock.
            Value is <see langword="2" />.
            </summary>
        </member>
        <member name="F:Xtensive.Core.LockType.Exclusive">
            <summary>
            Exclusive lock. The same as <see cref="F:Xtensive.Core.LockType.Write"/> lock.
            Value is <see langword="2"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.LockType.Suspend">
            <summary>
            Suspend lock.
            Value is <see langword="4" />.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.CollectionBase`1">
            <summary>
            Base class for any collection.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.CollectionBaseSlim`1">
            <summary>
            Lightweight base class for any collection.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds the elements of the specified collection to the end of the <see cref="T:Xtensive.Core.Collections.CollectionBaseSlim`1"/>.
            </summary>
            <param name="collection">The collection whose elements should be added to the end of the <see cref="T:Xtensive.Core.Collections.CollectionBaseSlim`1"/>. The collection itself cannot be null, but it can contain elements that are null, if type T is a reference type.</param>
            <exception cref="T:System.ArgumentNullException">collection is null.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBaseSlim`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.Items">
            <summary>
            Gets the items.
            </summary>
            <value>The items.</value>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.System#Collections#Generic#ICollection{TItem}#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBaseSlim`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an element to the collection.
            </summary>
            <param name="index">The zero-based index at which value should be inserted.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index of the
            collection instance.
            </summary>
            <param name="index">The zero-based index of the element to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.Clear">
            <summary>
            Removes all objects from the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.Add(`0)">
            <summary>
            Adds new element to the collection.
            </summary>
            <param name="value">Item to add.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.Remove(`0)">
            <summary>
            Removes element from the the collection.
            </summary>
            <param name="value">Item to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.TrySubscribe(`0)">
            <summary>
            Tries to subscribe the collection on 
            change notifications from the specified item.
            </summary>
            <param name="item">The item to try.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.TryUnsubscribe(`0)">
            <summary>
            Tries to unsubscribe the collection from
            change notifications from the specified item.
            </summary>
            <param name="item">The item to try.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnChanging">
            <summary>
            Performs additional custom processes when changing the contents of the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnChanged">
            <summary>
            Performs additional custom processes after the contents of the 
            collection instance was changed.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnClearing">
            <summary>
            Performs additional custom processes when clearing the contents of the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnCleared">
            <summary>
            Performs additional custom processes after clearing the contents of the 
            collection instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnInserting(`0,System.Int32)">
            <summary>
            Performs additional custom processes before inserting a new element into the
            collection instance.
            </summary>
            <param name="index">The zero-based <paramref name="index"/> of the value to insert.</param>
            <param name="value">The value to insert.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnInserted(`0,System.Int32)">
            <summary>
            Performs additional custom processes after inserting a new element into the
            collection instance.
            </summary>
            <param name="index">The zero-based <paramref name="index"/> of the value to insert.</param>
            <param name="value">The inserted value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnRemoving(`0,System.Int32)">
            <summary>
            Performs additional custom processes before removing an element from the
            collection instance.
            </summary>
            <param name="index">The zero-based <paramref name="index"/> at which to insert value.</param>
            <param name="value">The element to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnRemoved(`0,System.Int32)">
            <summary>
            Performs additional custom processes after removing an element from the
            collection instance.
            </summary>
            <param name="index">The zero-based <paramref name="index"/> at which to insert value.</param>
            <param name="value">The element to remove.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnValidate(`0)">
            <summary>
            Performs additional custom processes when validating a value.
            </summary>
            <param name="value">The object to validate.</param>
            <remarks>
            The default implementation of this method determines whether value is a <see langword="null"/> 
            reference (Nothing in Visual Basic), and, if so, throws <see cref="T:System.ArgumentNullException"/>. 
            It is intended to be overridden by a derived class to perform additional action 
            when the specified element is validated.
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnItemChanging(System.Object,Xtensive.Core.Notifications.ChangeNotifierEventArgs)">
            <summary>
            Called when item is about to be changed.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:Xtensive.Core.Notifications.ChangeNotifierEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.OnItemChanged(System.Object,Xtensive.Core.Notifications.ChangeNotifierEventArgs)">
            <summary>
            Called when item was changed.
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:Xtensive.Core.Notifications.ChangeNotifierEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="capacity">The capacity.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.CollectionBase`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="collection">The collection.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.CollectionBase`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Changing">
            <summary>
            Occurs when collection is intended to be changed.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Changed">
            <summary>
            Occurs when collection was changed.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Validate">
            <summary>
            Occurs when item is validated.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Clearing">
            <summary>
            Occurs when collection is inteneded to be cleared.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Cleared">
            <summary>
            Occurs when collection was cleared.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Inserting">
            <summary>
            Occurs when item is inserting into collection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Inserted">
            <summary>
            Occurs when item was inserted into colection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Removing">
            <summary>
            Occurs when item is removing from collection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.Removed">
            <summary>
            Occurs when item was removed from colection.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.ItemChanging">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.CollectionBase`1.ItemChanged">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.IPoolBase`1">
            <summary>
            Base interface for pools.
            </summary>
            <typeparam name="T">The type of pooled item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IPoolBase`1.Remove(`0)">
            <summary>
            Removes the specified <paramref name="item"/> from the pool.
            </summary>
            <param name="item">The item to remove.</param>
            <returns><see langword="True"/>, if the item was successfully removed;
            otherwise (e.g. if there were no such item), <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPoolBase`1.Release(`0)">
            <summary>
            Returns the pooled item back to the pool.
            </summary>
            <param name="item">The item to release.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IPoolBase`1.IsPooled(`0)">
            <summary>
            Gets a value indicating whether specified <paramref name="item"/> is pooled.
            </summary>
            <param name="item">Item to check the status for.</param>
            <returns><see langword="True"/>, if the specified item is pooled;
            otherwise (e.g. if there is no such item), <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPoolBase`1.IsAvailable(`0)">
            <summary>
            Gets a value indicating whether specified <paramref name="item"/> is pooled and available now.
            </summary>
            <param name="item">Item to check the status for.</param>
            <returns><see langword="True"/>, if the specified item is pooled and available;
            otherwise (e.g. if there is no such item, or it is consumed now), <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPoolBase`1.IsConsumed(`0)">
            <summary>
            Gets a value indicating whether specified <paramref name="item"/> is pooled and consumed now.
            </summary>
            <param name="item">Item to check the status for.</param>
            <returns><see langword="True"/>, if the specified item is pooled and consumed now;
            otherwise (e.g. if there is no such item, or it is available now), <see langword="false"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Collections.IPoolBase`1.Capacity">
            <summary>
            Gets the capacity of the pool.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IPoolBase`1.AvailableCount">
            <summary>
            Gets the count of available items in the pool.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IPoolBase`1.Count">
            <summary>
            Gets the total count of items in the pool.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.IPoolBase`1.ItemRemoved">
            <summary>
            Occurs after item is removed from the pool.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.IPool`2">
            <summary>
            Keyed pool contract.
            </summary>
            <typeparam name="K">The type of key to retrieve the items by.</typeparam>
            <typeparam name="T">The type of pooled item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`2.Add(`0,`1)">
            <summary>
            Adds the item into the pool.
            </summary>
            <param name="key">Key to associate the item with.</param>
            <param name="item">Item to add.</param>
            <returns><see langword="True"/>, if the item was successfully added;
            otherwise (e.g. if the pool is full), <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`2.Consume(`0)">
            <summary>
            Consumes the item with specified key from the pool.
            </summary>
            <param name="key">Key to get the pooled item for.</param>
            <returns>Pooled item.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`2.Consume(`0,System.Func{`1})">
            <summary>
            Consumes the item with specified key from the pool;
            creates a new one (using <paramref name="itemGenerator"/>),
            if no available item is found in pool.
            </summary>
            <param name="key">Key to get the pooled item for.</param>
            <param name="itemGenerator">Item generator to use, if no pooled item is found.</param>
            <returns>Pooled or newly created item.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`2.Consume(`0,`1)">
            <summary>
            Adds the specified item into the pool and immediately consumes it.
            </summary>
            <param name="key">Key to associate the item with.</param>
            <param name="item">Item to add and consume.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`2.ExecuteConsumer(`0,System.Func{`1},System.Action{`0,`1})">
            <summary>
            Executes <paramref name="consumer"/> action for either
            pooled or newly created item. 
            <see cref="M:Xtensive.Core.Collections.IPoolBase`1.Release(`0)"/>s the item on completion of
            execution.
            </summary>
            <param name="key">Key to get the pooled item for.</param>
            <param name="itemGenerator">Item generator to use, if no pooled item is found.</param>
            <param name="consumer">The action to execute.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`2.RemoveKey(`0)">
            <summary>
            Removes all the items associated with the specified
            <paramref name="key"/> from the pool.
            </summary>
            <param name="key">Key to remove the pooled items for.</param>
            <returns>The array of items that were removed from the pool.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.IPriorityQueue`2">
            <summary>
            Priority queue interface.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of items to be stored in queue.</typeparam>
            <typeparam name="TPriority"><see cref="T:System.Type"/> of priority value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.Enqueue(`0,`1)">
            <summary>
            Adds an <paramref name="item"/> to the priority queue.
            </summary>
            <param name="item">Item to be added to the queue.</param>
            <param name="priority">Priority value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.Dequeue">
            <summary>
            Removes top item from the queue.
            </summary>
            <returns>Top item from priority queue if applicable.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.DequeueRange(`1)">
            <summary>
            Removes range of items from queue. Item's priority must be greater than <paramref name="priority"/>.
            </summary>
            <param name="priority">Threshold value for items to remove from queue </param>
            <returns>An <see langword="array"/> of items. Empty <see langword="array"/> if no items found under <paramref name="priority"/> condition.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.Peek">
            <summary>
            Returns top item from the priority queue but not removes it from the queue.
            </summary>
            <returns>Top item from queue if applicable.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the queue,
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.Clear">
            <summary>
            Removes all objects from the queue.
            </summary>
            <remarks>
            <para>
            <see cref="P:Xtensive.Core.Collections.ICountable.Count"/> is set to zero, and references to other objects 
            from elements of the queue are also released.
            </para>
            <para>
            The capacity remains unchanged. To reset the capacity of the queue,
            call <see cref="M:Xtensive.Core.Collections.IPriorityQueue`2.TrimExcess"/>. Trimming an empty queue sets the capacity 
            of the queue to the default capacity.
            </para>
            <para>
            This method is an O(n) operation, where n is <see cref="P:Xtensive.Core.Collections.ICountable.Count"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.Contains(`0)">
            <summary>
            Determines whether an element is in the queue. 
            </summary>
            <param name="item">
            The element to locate in the queue. The value can be a 
            <see langword="null"/> for reference types.
            </param>
            <returns><see langword="true"/> if <paramref name="item"/> is found in the 
            queue; otherwise, <see langword="false"/>.</returns>
            <remarks>
            <para>
            This method determines equality using the default equality comparer 
            <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/> for <typeparamref name="T"/>,
            the type of values in the queue.
            </para>
            <para>
            This method performs a linear search; therefore, this method is an O(n) operation,
            where n is <see cref="P:Xtensive.Core.Collections.ICountable.Count"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.IPriorityQueue`2.Remove(`0)">
            <summary>
            Removes an element from the queue
            </summary>
            <param name="item">The element to remove from the queue</param>
        </member>
        <member name="P:Xtensive.Core.Collections.IPriorityQueue`2.Direction">
            <summary>
            Gets direction of items stored in the queue
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IPriorityQueue`2.Capacity">
            <summary>
            Gets or sets the size of an internal array.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IPriorityQueue`2.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified <paramref name="index"/> 
            is less than zero or is equal to \ greater than <see langword="Count"/>.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueueItemComparer`2.Compare(Xtensive.Core.Pair{`0,`1},Xtensive.Core.Pair{`0,`1})">
            <summary>
            Compares two objects and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            
            <returns>
            Value Condition Less than zerox is less than y.Zerox equals y.Greater than zerox is greater than y.
            </returns>
            
            <param name="y">The second object to compare.</param>
            <param name="x">The first object to compare.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.Pool`2">
            <summary>
            Keyed pool implementation.
            <see langword="Thread-safe." />
            </summary>
            <typeparam name="TKey">The type of key to retrieve the items by.</typeparam>
            <typeparam name="TItem">The type of pooled item.</typeparam>
        </member>
        <member name="T:Xtensive.Core.Collections.IExpiringItemCollection`1">
            <summary>
            Describes a collection containing expiring items.
            </summary>
            <typeparam name="T">The type of collection item.</typeparam>
        </member>
        <member name="T:Xtensive.Core.IHasGarbageCollector">
            <summary>
            Describes a class that automatically collects the garbage inside it.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHasGarbageCollector.GarbageCollectionPeriod">
            <summary>
            Gets the period of time between automatic garbage collections.
            If multiple periods are used (e.g. for generational GC), this should be the shortest one.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.IExpiringItemCollection`1.ItemExpirationPeriod">
            <summary>
            Gets the item expiration period.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.IExpiringItemCollection`1.ItemExpires">
            <summary>
            Occurs when item is going to expire.
            </summary>
        </member>
        <member name="E:Xtensive.Core.Collections.IExpiringItemCollection`1.ItemRemoved">
            <summary>
            Occurs when item has expired.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Add(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Consume(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Consume(`0,System.Func{`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Consume(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.ExecuteConsumer(`0,System.Func{`1},System.Action{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Release(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.IsPooled(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.IsAvailable(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.IsConsumed(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.CollectGarbage">
            <summary>
            Removes expired items from pool.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.OnItemExpires(Xtensive.Core.Collections.ItemExpiresEventArgs{`1})">
            <summary>
            Invokes <see cref="E:Xtensive.Core.Collections.Pool`2.ItemExpires"/> event.
            </summary>
            <param name="eventArgs">Event arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.OnItemRemoved(Xtensive.Core.Collections.ItemRemovedEventArgs{`1})">
            <summary>
            Invokes <see cref="E:Xtensive.Core.Collections.Pool`2.ItemRemoved"/> event.
            </summary>
            <param name="eventArgs">Event arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="initialCapacity">Initial <see cref="P:Xtensive.Core.Collections.Pool`2.Capacity"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="initialCapacity">Initial <see cref="P:Xtensive.Core.Collections.Pool`2.Capacity"/> property value.</param>
            <param name="itemExpirationPeriod"><see cref="P:Xtensive.Core.Collections.Pool`2.ItemExpirationPeriod"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.#ctor(System.Int32,System.TimeSpan,System.TimeSpan)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="initialCapacity">Initial <see cref="P:Xtensive.Core.Collections.Pool`2.Capacity"/> property value.</param>
            <param name="itemExpirationPeriod"><see cref="P:Xtensive.Core.Collections.Pool`2.ItemExpirationPeriod"/> property value.</param>
            <param name="garbageCollectionPeriod"><see cref="P:Xtensive.Core.Collections.Pool`2.GarbageCollectionPeriod"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Dispose">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Finalize">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`2.Dispose(System.Boolean)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`2.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`2.AvailableCount">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`2.ItemExpirationPeriod">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`2.GarbageCollectionPeriod">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Pool`2.ItemExpires">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Pool`2.ItemRemoved">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.PriorityQueue`2">
            <summary>
            Priority queue.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of objects to be stored in queue.</typeparam>
            <typeparam name="TPriority"><see cref="T:System.Type"/> of priority value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.TrimExcess">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Enqueue(`0,`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Dequeue">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.DequeueRange(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Peek">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.#ctor(Xtensive.Core.Direction)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="direction">Initial <see cref="P:Xtensive.Core.Collections.PriorityQueue`2.Direction"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.#ctor(Xtensive.Core.Direction,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="direction">Initial <see cref="P:Xtensive.Core.Collections.PriorityQueue`2.Direction"/> property value.</param>
            <param name="initialCapacity">Initial <see cref="P:Xtensive.Core.Collections.PriorityQueue`2.Capacity"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.#ctor(Xtensive.Core.Direction,System.Int32,System.Single)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="direction">Initial <see cref="P:Xtensive.Core.Collections.PriorityQueue`2.Direction"/> property value.</param>
            <param name="initialCapacity">Initial <see cref="P:Xtensive.Core.Collections.PriorityQueue`2.Capacity"/> property value.</param>
            <param name="growFactor">Capacity grow factor.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Collections.PriorityQueue`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.SerializableDocTemplate.Ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Collections.PriorityQueue`2.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.PriorityQueue`2.Direction">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.PriorityQueue`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.PriorityQueue`2.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.CollectionExtensions">
            <summary>
            <see cref="T:System.Collections.Generic.ICollection`1"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts <paramref name="source"/> collection to an array.
            </summary>
            <typeparam name="TItem">The type of collection items.</typeparam>
            <param name="source">Collection to convert.</param>
            <returns>An array containing all the items from the <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.ToArray``2(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts <paramref name="source"/> collection to an array with type case.
            </summary>
            <typeparam name="TItem">The type of collection items.</typeparam>
            <typeparam name="TNewItem">The type of array (result) items.</typeparam>
            <param name="source">Collection to convert.</param>
            <returns>An array containing all the items from the <paramref name="source"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.Copy``1(System.Collections.Generic.ICollection{``0},``0[],System.Int32)">
            <summary>
            Copies the items from <paramref name="source"/> collection
            to <paramref name="target"/> array starting from specified
            <paramref name="targetIndex"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">Source collection to copy from.</param>
            <param name="target">Target array to copy to.</param>
            <param name="targetIndex">Index in <paramref name="target"/> array to start from.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>targetIndex</c> is out of range.</exception>
            <exception cref="T:System.ArgumentException">Destination array is too small.</exception>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.Copy``1(System.Collections.Generic.ICollection{``0},System.Array,System.Int32)">
            <summary>
            Copies the items from <paramref name="source"/> collection
            to <paramref name="target"/> array starting from specified
            <paramref name="targetIndex"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="source">Source collection to copy from.</param>
            <param name="target">Target array to copy to.</param>
            <param name="targetIndex">Index in <paramref name="target"/> array to start from.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>targetIndex</c> is out of range.</exception>
            <exception cref="T:System.ArgumentException">Destination array is too small or multidimensional.</exception>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.ContainsNone``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="collection"/> contains 
            none of items in specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="collection">The collection.</param>
            <param name="items">The items to check for containment.</param>
            <returns>
              <see langword="True"/> if the specified <paramref name="collection"/> none 
              of items in specified set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.ContainsAll``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="collection"/> contains 
            all of items in specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="collection">The collection.</param>
            <param name="items">The items to check for containment.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="collection"/> all
            of items in specified set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.CollectionExtensions.ContainsAny``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the specified <paramref name="collection"/> contains 
            any of items in specified set of <paramref name="items"/>.
            </summary>
            <typeparam name="TItem">The type of item.</typeparam>
            <param name="collection">The collection.</param>
            <param name="items">The items to check for containment.</param>
            <returns>
            <see langword="True"/> if the specified <paramref name="collection"/> any 
             of items in specified set of <paramref name="items"/>; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Xtensive.Core.Direction">
            <summary>
            Possible directions of iteration through the enumerable.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Direction.Default">
            <summary>
            Default direction (none).
            </summary>
        </member>
        <member name="F:Xtensive.Core.Direction.None">
            <summary>
            No direction.
            Implies that either comparison for it can't be performed, or shouldn't be done.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Direction.Positive">
            <summary>
            Forward direction (acsending order).
            </summary>
        </member>
        <member name="F:Xtensive.Core.Direction.Negative">
            <summary>
            Backward direction (descending order).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.DelegateHelper">
            <summary>
            Delegate helper \ extension methods. 
            Simplifies various delegate creation.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.DelegateHelper.AspectedPrivateFieldGetterPrefix">
            <summary>
            Aspected private field getter prefix.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.DelegateHelper.AspectedPrivateFieldSetterPrefix">
            <summary>
            Aspected private field setter prefix.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Reflection.DelegateHelper.AspectedFactoryMethodName">
            <summary>
            Aspected factory method name.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateGetMemberDelegate``2(System.String)">
            <summary>
            Creates get member delegate.
            </summary>
            <typeparam name="TObject">Declaring type.</typeparam>
            <typeparam name="TValue">Member type.</typeparam>
            <param name="memberName">Member name.</param>
            <returns><see cref="T:System.Func`2"/> delegate 
            that gets member value.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateGetMemberConverterDelegate``2(System.String)">
            <summary>
            Creates property \ member getter delegate.
            </summary>
            <typeparam name="TObject">Declaring type.</typeparam>
            <typeparam name="TValue">Member type.</typeparam>
            <param name="memberName">Member name.</param>
            <returns><see cref="T:System.Func`2"/> delegate 
            that gets member value.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateSetMemberDelegate``2(System.String)">
            <summary>
            Creates property \ member setter delegate.
            </summary>
            <typeparam name="TObject">Declaring type.</typeparam>
            <typeparam name="TValue">Member type.</typeparam>
            <param name="memberName">Member name.</param>
            <returns><see cref="T:System.Action`2"/> delegate 
            that sets member value.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreatePrimitiveCastDelegate``2">
            <summary>
            Creates primitive type cast delegate - e.g. <see cref="T:System.Enum"/> to <see cref="T:System.SByte"/>.
            </summary>
            <typeparam name="TSource">The type to cast.</typeparam>
            <typeparam name="TTarget">Target type.</typeparam>
            <returns>A delegate allowing to cast <typeparamref name="TSource"/> to <typeparamref name="TTarget"/>.</returns>
            <exception cref="T:System.InvalidCastException"><c>InvalidCastException</c>.</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateDelegate``1(System.Object,System.Type,System.String,System.Type[])">
            <summary>
            Creates (generic) method invocation delegate with specified generic argument types.
            </summary>
            <param name="callTarget">The delegate call target. <see langword="Null"/>, if static method should be called.</param>
            <param name="type">Type, which method should be called by delegate.</param>
            <param name="methodName">The name of the method to call by delegate.</param>
            <param name="genericArgumentTypes">Generic method arguments.</param>
            <returns>New delegate allowing to call specified generic method on <paramref name="callTarget"/>.</returns>
            <typeparam name="TDelegate">Type of delegate to create.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateDelegates``1(System.Object,System.Type,System.String,System.Collections.Generic.IList{System.Type})">
            <summary>
            Creates an array of generic method invocation delegates matching the method instance 
            with specified generic argument variants.
            </summary>
            <param name="callTarget">The delegate call target. <see langword="Null"/>, if static method should be called.</param>
            <param name="type">Type, which method should be called by delegate.</param>
            <param name="methodName">The name of the method to call by delegate.</param>
            <param name="genericArgumentVariants">Generic method argument variants.</param>
            <returns>An array of delegate allowing to call specified generic method instances on <paramref name="callTarget"/>.</returns>
            <typeparam name="TDelegate">Type of delegate to create.</typeparam>
            <exception cref="T:System.ArgumentException"><c>ArgumentException</c>.</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.ExecuteDelegates``1(Xtensive.Core.Reflection.ExecutionSequenceHandler{``0}[],``0@,Xtensive.Core.Direction)">
            <summary>
            Executes sequence of <see cref="T:Xtensive.Core.Reflection.ExecutionSequenceHandler`1"/>s.
            Stops when the executed delegate returns <see langword="true"/>.
            </summary>
            <typeparam name="T">Type of argument to pass to each delegate.</typeparam>
            <param name="delegates">Delegates to execute.</param>
            <param name="argument">Argument to pass to each delegate.</param>
            <param name="direction">Direction of execution.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid <paramref name="direction"/> value.</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateConstructorDelegate``1(System.Type)">
            <summary>
            Creates constructor invocation delegate.
            </summary>
            <typeparam name="TDelegate">The type of the delegate to return.</typeparam>
            <param name="type">The type to create the constructor invocation delegate for.</param>
            <returns>Constructor invocation delegate.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is an abstract type.</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.CreateProtectedConstructorDelegate``1(System.Type)">
            <summary>
            Creates protected constructor invocation delegate.
            </summary>
            <typeparam name="TDelegate">The type of the delegate to return.</typeparam>
            <param name="type">The type to create the protected constructor invocation delegate for.</param>
            <returns>Protected constructor invocation delegate.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="type"/> is an abstract type.</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.MakeDelegateType(System.Type,System.Type[])">
            <summary>
            Creates a delegate type that represents a delegate that calls a method with specified signature.
            </summary>
            <param name="returnType">Type of return value.</param>
            <param name="parameterTypes">Types of parameters.</param>
            <returns>Created delegate type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.MakeDelegateType(System.Type,System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates a delegate type that represents a delegate that calls a method with specified signature.
            </summary>
            <param name="returnType">Type of return value.</param>
            <param name="parameterTypes">Types of parameters.</param>
            <returns>Created delegate type.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.DelegateHelper.GetDelegateSignature(System.Type)">
            <summary>
            Gets signature of a delegate of a <paramref name="delegateType"/>.
            </summary>
            <param name="delegateType">Type of the delegate.</param>
            <returns>A pair that contains return type as first element and parameter types as second arguments.</returns>
        </member>
        <member name="T:Xtensive.Core.IoC.ResourceConsumptionScope`1">
            <summary>
            Represent base scope type for resource consumption pattern implementation.
            </summary>
            <typeparam name="TResource">The type of the resource.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="resource">The resource.</param>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`1.Dispose(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose(System.Boolean)" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`1.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`1.Finalize">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.DisposableDocTemplate.Dtor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.IoC.ResourceConsumptionScope`1.Current">
            <summary>
            Gets or sets the current consumption scope.
            </summary>
            <value>The current consumption scope.</value>
        </member>
        <member name="P:Xtensive.Core.IoC.ResourceConsumptionScope`1.Outer">
            <summary>
             Gets outer consumption scope if exists.
            </summary>
             <value>The outer consumption scope or <see langword="null"/> if it does not exist.</value>
        </member>
        <member name="P:Xtensive.Core.IoC.ResourceConsumptionScope`1.Resource">
            <summary>
            Gets or sets the <see cref="T:Xtensive.Core.IResource"/> object this instance is bound to.
            </summary>
            <value>The <see cref="T:Xtensive.Core.IResource"/>.</value>
            <exception cref="T:System.ObjectDisposedException">Scope is already disposed.</exception>
        </member>
        <member name="T:Xtensive.Core.IoC.ResourceConsumptionScope`2">
            <summary>
            Represent base configurable scope type for resource consumption pattern implementation.
            </summary>
            <typeparam name="TResource">The type of the resource.</typeparam>
            <typeparam name="TConfig">The type of the resource configuration.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.IoC.ResourceConsumptionScope`2.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="resource">The resource.</param>
        </member>
        <member name="T:Xtensive.Core.InstanceMustHaveSyncRootException">
            <summary>
            </summary>
        </member>
        <member name="M:Xtensive.Core.InstanceMustHaveSyncRootException.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Xtensive.Core.InstanceMustHaveSyncRootException.#ctor(System.String)">
            <summary>
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Xtensive.Core.InstanceMustHaveSyncRootException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:Xtensive.Core.IResource">
            <summary>
             Describes an object implementing consumption pattern.
            </summary>
        </member>
        <member name="M:Xtensive.Core.IResource.AddConsumer(System.Object)">
            <summary>
            Registers the object that wishes to act like a consumer of this instance.
            </summary>
            <param name="consumer">Object that wishes to act like a consumer of this instance.</param>
        </member>
        <member name="M:Xtensive.Core.IResource.RemoveConsumer(System.Object)">
            <summary>
            Unregisters the object that no longer wishes to act like a consumer of this instance.
            </summary>
            <param name="consumer">Object that no longer wishes to acts like a consumer of this instance.</param>
        </member>
        <member name="P:Xtensive.Core.IResource.HasConsumers">
            <summary>
            Gets a value indicating whether this instance is active (has one or more consumers).
            </summary>
            <value>
              <see langword="true"/> if this instance is active (has one or more consumers); otherwise, <see langword="false"/>.
            </value>
        </member>
        <member name="T:Xtensive.Core.IoC.IContextBound`1">
            <summary>
            Interface for all objects that are bound to some <see cref="P:Xtensive.Core.IoC.IContextBound`1.Context"/>
            instance.
            </summary>
            <typeparam name="TContext">The type of the context.</typeparam>
        </member>
        <member name="P:Xtensive.Core.IoC.IContextBound`1.Context">
            <summary>
            Gets <see cref="P:Xtensive.Core.IoC.IContextBound`1.Context"/> to which current instance is bound.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IFactory`2">
            <summary>
            Describes a factory object that is capable of creating 
            <typeparamref name="TValue"/> instances 
            relying on <typeparamref name="TKey"/> instances.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the resulting value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.IFactory`2.Create(`0)">
            <summary>
            Creates the object of type <typeparamref name="TValue"/> by specified key.
            </summary>
            <param name="key">The key.</param>
            <returns>Newly created instance of type <typeparamref name="TValue"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.IProvider`2">
            <summary>
            Provider contract.
            </summary>
            <typeparam name="TKey">The type of key.</typeparam>
            <typeparam name="TValue">The type of provided value.</typeparam>
        </member>
        <member name="P:Xtensive.Core.IProvider`2.Item(`0)">
            <summary>
            Gets the instance of type <typeparamref name="TValue"/> 
            by its <paramref name="key"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Reflection.AssemblyHelper">
            <summary>
            <see cref="T:System.Reflection.Assembly"/> related helper \ extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Reflection.AssemblyHelper.FindDependentAssemblies(System.Reflection.Assembly)">
            <summary>
            Finds all dependent assemblies in current <see cref="T:System.AppDomain"/>.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> of all dependent assemblies.</returns>
        </member>
        <member name="M:Xtensive.Core.Reflection.AssemblyHelper.FindTypes(System.Reflection.Assembly,System.Type,System.Reflection.TypeFilter)">
            <summary>
            Finds the types that are subclasses of the specified type and are located within the specified assembly.
            The <paramref name="filter"/> is optional additional parameter.
            </summary>
            <param name="assembly">The assembly.</param>
            <param name="baseType">The base type.</param>
            <param name="filter">The filter.</param>
            <returns>A <see cref="T:System.Collections.Generic.IList`1"/> of all found types.</returns>
            <exception cref="T:System.InvalidOperationException">Something went wrong :(</exception>
        </member>
        <member name="M:Xtensive.Core.Reflection.AssemblyHelper.LoadExtensionAssembly(System.String)">
            <summary>
            Loads the extension assembly.
            This method replaces a short name of a calling assembly.
            with a <paramref name="extensionAssemblyName"/>,
            then loads assembly with such name.
            </summary>
            <param name="extensionAssemblyName">Name of the extension assembly.</param>
            <returns>Loaded assembly.</returns>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.ISizeCalculatorProvider">
            <summary>
            Size calculator provider.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculatorProvider.GetSizeCalculator``1">
            <summary>
            Gets <see cref="T:Xtensive.Core.SizeCalculators.SizeCalculator`1"/> for the specified type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type to get the size calculator for.</typeparam>
            <returns><see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/> for the specified type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculatorProvider.GetSizeCalculatorByInstance(System.Object)">
            <summary>
            Gets <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculatorBase"/> for the specified <paramref name="value"/>.
            </summary>
            <param name="value">Value to get the size calculator for.</param>
            <returns><see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculatorBase"/> for the specified <paramref name="value"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.ISizeCalculatorProvider.GetSizeCalculatorByType(System.Type)">
            <summary>
            Gets <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculatorBase"/> for the specified <paramref name="type"/>.
            </summary>
            <param name="type">Type to get the size calculator for.</param>
            <returns><see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculatorBase"/> for the specified <paramref name="type"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.SizeCalculators.SizeCalculatorProvider">
            <summary>
            Default <see cref="T:Xtensive.Core.SizeCalculators.ISizeCalculator`1"/> provider. 
            Provides default size calculator for the specified type.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.PointerFieldSize">
            <summary>
            Gets the pointer size.
            </summary>
        </member>
        <member name="F:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.HeapObjectHeaderSize">
            <summary>
            Gets the heap object header size.
            </summary>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.GetSizeCalculator``1">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.GetSizeCalculatorByInstance(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.GetSizeCalculatorByType(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.ConvertAssociate``3(``1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.SizeCalculators.SizeCalculatorProvider.Default">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.HasStaticDefaultDocTemplate.Default" copy="true"/>
        </member>
        <member name="T:Xtensive.Core.Collections.IPool`1">
            <summary>
            Pool contract.
            </summary>
            <typeparam name="T">The type of pooled item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`1.Add(`0)">
            <summary>
            Adds the item into the pool.
            </summary>
            <param name="item">Item to add.</param>
            <returns><see langword="True"/>, if the item was successfully added;
            otherwise (e.g. if the pool is full), <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`1.Consume">
            <summary>
            Consumes the item from the pool.
            </summary>
            <returns>Pooled item.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`1.Consume(System.Func{`0})">
            <summary>
            Consumes the item from the pool;
            creates a new one (using <paramref name="itemGenerator"/>),
            if no available item is found in pool.
            </summary>
            <param name="itemGenerator">Item generator to use, if no pooled item is found.</param>
            <returns>Pooled or newly created item.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`1.Consume(`0)">
            <summary>
            Adds the specified item into the pool and immediately consumes it.
            </summary>
            <param name="item">Item to add and consume.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.IPool`1.ExecuteConsumer(System.Func{`0},System.Action{`0})">
            <summary>
            Executes <paramref name="consumer"/> action for either
            pooled or newly created item. 
            <see cref="M:Xtensive.Core.Collections.IPoolBase`1.Release(`0)"/>s the item on completion of
            execution.
            </summary>
            <param name="itemGenerator">Item generator to use, if no pooled item is found.</param>
            <param name="consumer">The action to execute.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.Consume">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.Consume(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.Consume(System.Func{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.Release(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.ExecuteConsumer(System.Func{`0},System.Action{`0})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.IsPooled(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.IsAvailable(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.IsConsumed(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.OnItemRemoved(Xtensive.Core.Collections.ItemRemovedEventArgs{`0})">
            <summary>
            Invokes <see cref="E:Xtensive.Core.Collections.Pool`1.ItemRemoved"/> event.
            </summary>
            <param name="eventArgs">Event arguments.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.Pool`1.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="capacity">Initial <see cref="P:Xtensive.Core.Collections.Pool`1.Capacity"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`1.Capacity">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`1.AvailableCount">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.Pool`1.Count">
            <inheritdoc/>
        </member>
        <member name="E:Xtensive.Core.Collections.Pool`1.ItemRemoved">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.ReadOnlyList`1">
            <summary>
            Read-only list (<see cref="T:System.Collections.IList"/>) wrapper.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Collections.ReadOnlyList`1.Empty">
            <summary>
            Empty <see cref="T:Xtensive.Core.Collections.ReadOnlyList`1"/> instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Contains(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.IndexOf(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Add(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Add(System.Object)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Insert(System.Int32,System.Object)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Remove(System.Object)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Remove(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.Clear">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="list">The list to copy or wrap.</param>
            <param name="copy">Indicates whether <paramref name="list"/> must be copied or wrapped.</param> 
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="list">The list to wrap.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.Item(System.Int32)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by "set" accessor (setter).</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyList`1.IsFixedSize">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.ConvertingEnumerator`2.#ctor(System.Collections.Generic.IEnumerator{`0},System.Converter{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="innerEnumerator">The inner enumerator.</param>
            <param name="converter">The converter.</param>
        </member>
        <member name="M:Xtensive.Core.Conversion.ConvertingEnumerator`2.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.Conversion.ConvertingEnumerable`2">
            <summary>
            An <see cref="T:System.Collections.Generic.IEnumerable`1"/> implementor performing
            conversion from <typeparamref name="TFrom"/> to
            <typeparamref name="TTo"/> on the fly.
            </summary>
            <typeparam name="TFrom">The item type to convert from.</typeparam>
            <typeparam name="TTo">The item type to convert to.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Conversion.ConvertingEnumerable`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.ConvertingEnumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Conversion.ConvertingEnumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Converter{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="innerEnumerable">Enumerable to wrap.</param>
            <param name="converter">Item converter to use.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TypedEnumerable`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Collections.TopDeque`2">
            <summary>
            Default <see cref="T:Xtensive.Core.Collections.ITopDeque`2"/> implementation.
            </summary>
            <typeparam name="K">Type of the key.</typeparam>
            <typeparam name="V">Type of the value.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.TryGetValue(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.TryGetValue(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.TryChangeValue(`0,`1,System.Boolean,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.PeekTop">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Collection is empty.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.PeekBottom">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Collection is empty.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.MoveToTop(`0)">
            <inheritdoc/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">There is no specified key.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.MoveToBottom(`0)">
            <inheritdoc/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">There is no specified key.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.AddToTop(`0,`1)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">The key is already added.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.AddToBottom(`0,`1)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">The key is already added.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="capacity">The initial capacity.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="keyComparer">The key comparer.</param>
        </member>
        <member name="M:Xtensive.Core.Collections.TopDeque`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="keyComparer">The key comparer.</param>
            <param name="capacity">The initial capacity.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.Item(`0)">
            <inheritdoc/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">There is no specified key.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.Top">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Collection is empty.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.Bottom">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Collection is empty.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.TopKey">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Collection is empty.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.TopDeque`2.BottomKey">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Collection is empty.</exception>
        </member>
        <member name="T:Xtensive.Core.Collections.ReadOnlyCollection`1">
            <summary>
            Read-only collection (<see cref="T:System.Collections.Generic.ICollection`1"/>) wrapper.
            </summary>
            <typeparam name="T">The type of collection items.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.IsWrapperOf(System.Collections.Generic.ICollection{`0})">
            <summary>
            Indicates whether this collection is a read-only wrapper 
            of specified <paramref name="collection"/>.
            </summary>
            <param name="collection">Collection to check.</param>
            <returns><see langword="True"/> if this collection is wrapper of
            specified collection; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.Add(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.Remove(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.Clear">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0},System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="collection">The collection to copy or wrap.</param>
            <param name="copy">Indicates whether <paramref name="collection"/> must be copied or wrapped.</param> 
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="collection">The collection to wrap.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyCollection`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyCollection`1.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyCollection`1.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyCollection`1.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Always returns <see langword="true"/>.
            </summary>
            <returns><see langword="True"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.Collections.ReadOnlyDictionary`2">
            <summary>
            Read-only generic dictionary (<see cref="T:System.Collections.Generic.IDictionary`2"/>) wrapper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Contains(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.CopyTo(System.Array,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Add(`0,`1)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Add(System.Object,System.Object)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Remove(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Remove(System.Object)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.Clear">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="dictionary">The dictionary to copy or wrap.</param>
            <param name="copy">Indicates whether <paramref name="dictionary"/> must be copied or wrapped.</param> 
        </member>
        <member name="M:Xtensive.Core.Collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="dictionary">The dictionary to wrap.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.SyncRoot">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.Item(`0)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by "set" accessor (setter).</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.Item(System.Object)">
            <inheritdoc/>
            <exception cref="T:System.NotSupportedException">Always thrown by "set" accessor (setter).</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.Values">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.IsReadOnly">
            <summary> 
            Always returns <see langword="true"/>.
            </summary>
            <returns><see langword="True"/>. </returns>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.IsFixedSize">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Collections.ReadOnlyDictionary`2.IsSynchronized">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.HighResolutionTime">
            <summary>
            A timer providing much higher resolution rather then default one.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Diagnostics.HighResolutionTime.Now">
            <summary>
            Gets current date and time (like <see cref="P:System.DateTime.Now">DateTime.Now</see>),
            but with the higher precision.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Diagnostics.Measurement">
            <summary>
            Time and memory measurement helper.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="operationCount">The operation count.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The measurement name.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(System.String,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The measurement  name.</param>
            <param name="operationCount">The operation count.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(Xtensive.Core.Diagnostics.MeasurementOptions)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="options">The measurement options.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(Xtensive.Core.Diagnostics.MeasurementOptions,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="options">The measurement options.</param>
            <param name="operationCount">The operation count.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(System.String,Xtensive.Core.Diagnostics.MeasurementOptions)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The measurement name.</param>
            <param name="options">The measurement options.</param>
        </member>
        <member name="M:Xtensive.Core.Diagnostics.Measurement.#ctor(System.String,Xtensive.Core.Diagnostics.MeasurementOptions,System.Int32)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="name">The measurement name.</param>
            <param name="options">The measurement options.</param>
            <param name="operationCount">The operation count.</param>
        </member>
        <member name="T:Xtensive.Core.InstanceIsLockedException">
            <summary>
            Thrown by <see cref="T:Xtensive.Core.ILockable"/> implementors on attempts 
            to change instance properties in the locked state.
            </summary>
        </member>
        <member name="M:Xtensive.Core.InstanceIsLockedException.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.InstanceIsLockedException.#ctor(System.String)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="text">Text of message.</param>
        </member>
        <member name="M:Xtensive.Core.InstanceIsLockedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor.
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> object.</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> object.</param>
        </member>
        <member name="T:Xtensive.Core.Collections.ItemExpiresEventArgs`1">
            <summary>
            Event arguments for <see cref="E:Xtensive.Core.Collections.IExpiringItemCollection`1.ItemExpires"/> event.
            </summary>
            <typeparam name="TItem">The type of collection item.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Collections.ItemExpiresEventArgs`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="item">The expiring item.</param>
        </member>
        <member name="P:Xtensive.Core.Collections.ItemExpiresEventArgs`1.Cancel">
            <summary>
            <see langword="True"/>, if item must be kept in collection; 
            otherwise, <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.ItemExpiresEventArgs`1.Item">
            <summary>
             Gets the expiring item.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ISequenceGenerator`1">
            <summary>
            Generates a sequence of values of <typeparamref name="T"/> type.
            </summary>
            <typeparam name="T">Type of value in sequence to produce.</typeparam>
        </member>
        <member name="M:Xtensive.Core.ISequenceGenerator`1.Next">
            <summary>
            Produces next value in the suequence.
            </summary>
            <returns>Next generated value.</returns>
        </member>
        <member name="T:Xtensive.Core.Triplet`3">
            <summary>
            Container of three values.
            </summary>
            <typeparam name="TFirst"><see cref="T:System.Type"/> of the first value.</typeparam>
            <typeparam name="TSecond"><see cref="T:System.Type"/> of the second value.</typeparam>
            <typeparam name="TThird"><see cref="T:System.Type"/> of the third value.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Triplet`3.First">
            <summary>
            First value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Triplet`3.Second">
            <summary>
            Second value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Triplet`3.Third">
            <summary>
            Third value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.Equals(Xtensive.Core.Triplet{`0,`1,`2})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.CompareTo(Xtensive.Core.Triplet{`0,`1,`2})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.op_Equality(Xtensive.Core.Triplet{`0,`1,`2},Xtensive.Core.Triplet{`0,`1,`2})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.op_Inequality(Xtensive.Core.Triplet{`0,`1,`2},Xtensive.Core.Triplet{`0,`1,`2})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Triplet`3.#ctor(`0,`1,`2)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="first">A first value in triplet.</param>
            <param name="second">A second value in triplet.</param>
            <param name="third">A third value in triplet.</param>
        </member>
        <member name="T:Xtensive.Core.Tuples.DifferentialTuple">
            <summary>
            Differential tuple. Combines read-only <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Origin"/> tuple
            with <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Difference"/> tuple providing all the 
            changes made to <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Origin"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Tuple">
            <summary>
            A base class for auto generated tuples.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.ITuple">
            <summary>
            Describes a tuple.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.ITupleFactory">
            <summary>
            <see cref="T:Xtensive.Core.Tuples.Tuple"/> factory contract.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITupleFactory.CreateNew">
            <summary>
            Creates new instance of the tuple of the same type.
            </summary>
            <returns>A new instance of the tuple of the same type.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITuple.Clone">
            <summary>
            Clones the tuple.
            </summary>
            <returns>A new instance of the tuple of the same type
            and with the same field values.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITuple.GetFieldState(System.Int32)">
            <summary>
            Gets the field state associated with the field.
            </summary>
            <param name="fieldIndex">Index of the field to get the state for.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITuple.GetValue(System.Int32)">
            <summary>
            Gets the value field value by its index.
            </summary>
            <param name="fieldIndex">Index of the field to get value of.</param>
            <returns>Field value.</returns>
            <remarks>
            If field value is not available (see <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/>),
            an exception will be thrown.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Field value is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITuple.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <summary>
            Gets the value field value by its index, if it is available;
            otherwise returns default value for field type.
            </summary>
            <param name="fieldIndex">Index of the field to get value of.</param>
            <param name="fieldState">Field state associated with the field.</param>
            <returns>Field value, if it is available; otherwise, default value for field type.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITuple.GetValueOrDefault(System.Int32)">
            <summary>
            Gets the value field value by its index, if it is available (see <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/>) and is not null (see <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Null"/>);
            otherwise returns <see langword="null"/>.
            </summary>
            <param name="fieldIndex">Index of the field to get value of.</param>
            <returns>Field value, if it is available and not null; otherwise, <see langword="null"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITuple.SetValue(System.Int32,System.Object)">
            <summary>
            Sets the field value by its index.
            </summary>
            <param name="fieldIndex">Index of the field to set value of.</param>
            <param name="fieldValue">Field value.</param>
            <exception cref="T:System.InvalidCastException">Type of stored value is incompatible
            with the specified one.</exception>
        </member>
        <member name="P:Xtensive.Core.Tuples.ITuple.Descriptor">
            <summary>
            Gets tuple descriptor.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.ITuple.Count">
            <summary>
            Gets field count for this instance.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Tuple.HashCodeMultiplier">
            <summary>
            Per-field hash code multiplier used in <see cref="M:Xtensive.Core.Tuples.Tuple.GetHashCode"/> calculation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Xtensive#Core#Tuples#ITupleFactory#CreateNew">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Xtensive#Core#Tuples#ITuple#Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.CreateNew">
            <see cref="M:Xtensive.Core.Tuples.ITupleFactory.CreateNew" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Clone">
            <see cref="M:Xtensive.Core.Tuples.ITuple.Clone" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetFieldState(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetValue(System.Int32)">
            <inheritdoc/>
            <exception cref="T:System.InvalidOperationException">Field value is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetValueOrDefault(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.SetValue(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetValue``1(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <summary>
            Gets the value field value by its index, if it is available;
            otherwise returns <see langword="default(T)"/>.
            </summary>
            <param name="fieldIndex">Index of the field to get value of.</param>
            <param name="fieldState">Field state associated with the field.</param>
            <returns>Field value, if it is available; otherwise, <see langword="default(T)"/>.</returns>
            <typeparam name="T">The type of value to get.</typeparam>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetValue``1(System.Int32)">
            <summary>
            Gets the value field value by its index.
            </summary>
            <param name="fieldIndex">Index of the field to get value of.</param>
            <returns>Field value.</returns>
            <typeparam name="T">The type of value to get.</typeparam>
            <remarks>
            If field value is not available (see <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/>),
            an exception will be thrown.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Field value is not available.</exception>
            <exception cref="T:System.InvalidCastException">Value is available, but it can't be cast
            to specified type. E.g. if value is <see langword="null"/>, field is struct, 
            but <typeparamref name="T"/> is not a <see cref="T:System.Nullable`1"/> type.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetValueOrDefault``1(System.Int32)">
            <summary>
            Gets the value field value by its index.
            </summary>
            <param name="fieldIndex">Index of the field to get value of.</param>
            <returns>Field value.</returns>
            <typeparam name="T">The type of value to get.</typeparam>
            <remarks>
            If field value is not available (see <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/>),
            an exception will be thrown.
            </remarks>
            <exception cref="T:System.InvalidCastException">Value is available, but it can't be cast
            to specified type. E.g. if value is <see langword="null"/>, field is struct, 
            but <typeparamref name="T"/> is not a <see cref="T:System.Nullable`1"/> type.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.SetValue``1(System.Int32,``0)">
            <summary>
            Sets the field value by its index.
            </summary>
            <param name="fieldIndex">Index of the field to set value of.</param>
            <param name="fieldValue">Field value.</param>
            <typeparam name="T">The type of value to set.</typeparam>
            <exception cref="T:System.InvalidCastException">Type of stored value and <typeparamref name="T"/>
            are incompatible.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetMappedContainer(System.Int32,System.Boolean)">
            <summary>
            Gets the tuple containing actual value of the specified field.
            </summary>
            <param name="fieldIndex">Index of the field to get the value container for.</param>
            <returns>Tuple container and remapped field index.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.CompareTo(Xtensive.Core.Tuples.Tuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.CompareTo(Xtensive.Core.Tuples.ITuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Equals(Xtensive.Core.Tuples.Tuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Equals(Xtensive.Core.Tuples.ITuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create(System.Type[])">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field types.
            </summary>
            <param name="fieldTypes">Array of field types.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create(Xtensive.Core.Tuples.TupleDescriptor)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its descriptor.
            </summary>
            <param name="descriptor">The descriptor.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``1(``0)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T">Type of the only tuple field.</typeparam>
            <param name="value">Value of the only tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``1(Xtensive.Core.Tuples.TupleDescriptor,``0)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T">Type of the only tuple field.</typeparam>
            <param name="descriptor">Tuple descriptor.</param>
            <param name="value">Value of the only tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``2(``0,``1)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``2(Xtensive.Core.Tuples.TupleDescriptor,``0,``1)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <param name="descriptor">Tuple descriptor.</param>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``3(``0,``1,``2)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``3(Xtensive.Core.Tuples.TupleDescriptor,``0,``1,``2)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <param name="descriptor">Tuple descriptor.</param>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``4(``0,``1,``2,``3)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <param name="value4">Value of the 4th tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``4(Xtensive.Core.Tuples.TupleDescriptor,``0,``1,``2,``3)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <param name="descriptor">Tuple descriptor.</param>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <param name="value4">Value of the 4th tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <typeparam name="T5">Type of the 5th tuple field.</typeparam>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <param name="value4">Value of the 4th tuple field.</param>
            <param name="value5">Value of the 5th tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``5(Xtensive.Core.Tuples.TupleDescriptor,``0,``1,``2,``3,``4)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <typeparam name="T5">Type of the 5th tuple field.</typeparam>
            <param name="descriptor">Tuple descriptor.</param>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <param name="value4">Value of the 4th tuple field.</param>
            <param name="value5">Value of the 5th tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <typeparam name="T5">Type of the 5th tuple field.</typeparam>
            <typeparam name="T6">Type of the 6th tuple field.</typeparam>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <param name="value4">Value of the 4th tuple field.</param>
            <param name="value5">Value of the 5th tuple field.</param>
            <param name="value6">Value of the 6th tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Create``6(Xtensive.Core.Tuples.TupleDescriptor,``0,``1,``2,``3,``4,``5)">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.Tuple"/> by its field value(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <typeparam name="T5">Type of the 5th tuple field.</typeparam>
            <typeparam name="T6">Type of the 6th tuple field.</typeparam>
            <param name="descriptor">Tuple descriptor.</param>
            <param name="value1">Value of the first tuple field.</param>
            <param name="value2">Value of the 2nd tuple field.</param>
            <param name="value3">Value of the 3rd tuple field.</param>
            <param name="value4">Value of the 4th tuple field.</param>
            <param name="value5">Value of the 5th tuple field.</param>
            <param name="value6">Value of the 6th tuple field.</param>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.Parse(Xtensive.Core.Tuples.TupleDescriptor,System.String)">
            <see cref="M:Xtensive.Core.Tuples.TupleFormatExtensions.Parse(Xtensive.Core.Tuples.TupleDescriptor,System.String)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Tuple.#ctor">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Tuple.Descriptor">
            <inheritdoc />
        </member>
        <member name="P:Xtensive.Core.Tuples.Tuple.Count">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.IsChanged(System.Int32)">
            <summary>
            Indicates whether field with specified <paramref name="fieldIndex"/> is changed.
            </summary>
            <param name="fieldIndex">Index of the field to check.</param>
            <returns><see langword="True"/> if specified field is changed;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.Merge">
            <summary>
            Merges the <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Origin"/> with the <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Difference"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.GetMappedContainer(System.Int32,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.SetValue(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.CreateNew">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.Clone">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.Reset">
            <summary>
            Resets all the changes in <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Difference"/> by re-creating it.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.#ctor(Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="origin">Initial <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Origin"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.DifferentialTuple.#ctor(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="origin">Initial <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Origin"/> property value.</param>
            <param name="difference">Initial <see cref="P:Xtensive.Core.Tuples.DifferentialTuple.Difference"/> property value.</param>
            <exception cref="T:System.ArgumentException">Tuple descriptors mismatch.</exception>
        </member>
        <member name="P:Xtensive.Core.Tuples.DifferentialTuple.Descriptor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.DifferentialTuple.Count">
            <inheritdoc />
        </member>
        <member name="P:Xtensive.Core.Tuples.DifferentialTuple.Origin">
            <summary>
            Gets original tuple.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.DifferentialTuple.Difference">
            <summary>
            Gets or sets difference tuple.
            Can be <see langword="null" /> (acts as if no values are available in this tuple).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.FastReadOnlyTuple">
            <summary>
            Fast read-only <see cref="T:Xtensive.Core.Tuples.Tuple"/> implementation.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.FastReadOnlyTuple.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.FastReadOnlyTuple.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.FastReadOnlyTuple.SetValue(System.Int32,System.Object)">
            <inheritdoc/>
            <summary>
            <inherited/>
            Always throws <see cref="T:System.NotSupportedException"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Always thrown by this method.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.FastReadOnlyTuple.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.FastReadOnlyTuple.#ctor(Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="source">The tuple to create the fast read-only tuple from.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.FastReadOnlyTuple.Descriptor">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Tuples.GetValueDelegate`1">
            <summary>
            Incapsulates <see cref="M:Xtensive.Core.Tuples.Tuple.GetValue``1(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)"/> method.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.RegularTuple">
            <summary>
            Base class for any regular tuple.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.RegularTuple.#ctor(Xtensive.Core.Tuples.TupleDescriptor)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Internals.EmptyTuple.Instance">
            <summary>
            Provides the only instance of this class.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.TupleUpdater">
            <summary>
             Helper for tuple updating with the functional style syntax.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleUpdater.UpdateField(System.Int32,System.Object)">
            <summary>
            Updates the field of <see cref="P:Xtensive.Core.Tuples.TupleUpdater.Tuple"/> with specified index.
            </summary>
            <param name="fieldIndex">The field index.</param>
            <param name="value">The field value</param>
            <returns><see langword="this"/></returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleUpdater.#ctor(Xtensive.Core.Tuples.Tuple)">
            <summary>
              <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="tuple">The tuple to be wrapped.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleUpdater.Tuple">
            <summary>
            Gets the wrapped tuple.
            </summary>
            <value>The tuple.</value>
        </member>
        <member name="T:Xtensive.Core.Tuples.ReferencedTuple">
            <summary>
            Tuple that references another tuple by getter delegate.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.ReferencedTuple.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.ReferencedTuple.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.ReferencedTuple.SetValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.ReferencedTuple.#ctor(System.Func{Xtensive.Core.Tuples.Tuple})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="tupleGetter">The delegate to get inner tuple.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.ReferencedTuple.Descriptor">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Tuples.TupleFieldStateExtensions">
            <summary>
            Extension methods for <see cref="T:Xtensive.Core.Tuples.TupleFieldState"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFieldStateExtensions.IsAvailable(Xtensive.Core.Tuples.TupleFieldState)">
            <summary>
            Checks if specified field state has <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/> flag.
            </summary>
            <param name="fieldState"><see cref="T:Xtensive.Core.Tuples.TupleFieldState"/> to check.</param>
            <returns><see langword="true"/> if field state value has <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/> flag; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFieldStateExtensions.IsNull(Xtensive.Core.Tuples.TupleFieldState)">
            <summary>
            Checks if specified field state has <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Null"/> flag.
            </summary>
            <param name="fieldState"><see cref="T:Xtensive.Core.Tuples.TupleFieldState"/> to check.</param>
            <returns><see langword="true"/> if field state value has <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Null"/> flag; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:System.InvalidOperationException">Field value is not available.</exception>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFieldStateExtensions.IsAvailableAndNull(Xtensive.Core.Tuples.TupleFieldState)">
            <summary>
            Checks if specified field state has both <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Null"/> and <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/> flags.
            </summary>
            <param name="fieldState"><see cref="T:Xtensive.Core.Tuples.TupleFieldState"/> to check.</param>
            <returns><see langword="true"/> if field state value has both <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Null"/> and <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/> flags; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFieldStateExtensions.HasValue(Xtensive.Core.Tuples.TupleFieldState)">
            <summary>
            Checks if specified field state has <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/> flag and has no <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Null"/> flag.
            </summary>
            <param name="fieldState"><see cref="T:Xtensive.Core.Tuples.TupleFieldState"/> to check.</param>
            <returns><see langword="true"/> if field state value is equal to <see cref="F:Xtensive.Core.Tuples.TupleFieldState.Available"/>;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:Xtensive.Core.Tuples.TupleFormatExtensions">
            <summary>
            Extension methods for <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFormatExtensions.ToString(Xtensive.Core.Tuples.Tuple,System.Boolean)">
            <summary>
            Converts the <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> to 
            its string representation.
            </summary>
            <param name="source">The tuple to convert.</param>
            <param name="format">Indicates whether to use <see cref="M:Xtensive.Core.Tuples.TupleFormatExtensions.Format(Xtensive.Core.Tuples.Tuple)"/>,
            or <see cref="M:Xtensive.Core.Tuples.Tuple.ToString"/> method.</param>
            <returns>String representation of <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFormatExtensions.Format(Xtensive.Core.Tuples.Tuple)">
            <summary>
            Returns string representation of the specified <paramref name="tuple"/>.
            </summary>
            <param name="tuple">The <see cref="T:Xtensive.Core.Tuples.Tuple"/> to format.</param>
            <returns>
            String representation of the specified <paramref name="tuple"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleFormatExtensions.Parse(Xtensive.Core.Tuples.TupleDescriptor,System.String)">
            <summary>
            Returns a <see cref="T:Xtensive.Core.Tuples.Tuple"/> with specified <paramref name="descriptor"/>
            parsed from the <paramref name="source"/> string.
            </summary>
            <param name="descriptor">The descriptor of <see cref="T:Xtensive.Core.Tuples.Tuple"/> to parse.</param>
            <param name="source">The string to parse.</param>
            <returns>A <see cref="T:Xtensive.Core.Tuples.Tuple"/> parsed from the <paramref name="source"/> string.</returns>
            <exception cref="T:System.InvalidOperationException"><paramref name="source"/> string 
            can't be parsed to a <see cref="T:Xtensive.Core.Tuples.Tuple"/> with specified <paramref name="descriptor"/>.</exception>
        </member>
        <member name="T:Xtensive.Core.Tuples.MergeBehavior">
            <summary>
            Possible tuple merge behaviors.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.MergeBehavior.Default">
            <summary>
            The same as <see cref="F:Xtensive.Core.Tuples.MergeBehavior.PreferOrigin"/>
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.MergeBehavior.PreferOrigin">
            <summary>
            Origin values are preferrable.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.MergeBehavior.PreferDifference">
            <summary>
            Difference values are preferrable.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Internals.EmptyTupleDescriptor">
            <summary>
            Empty tuple descriptor.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.TupleDescriptor">
            <summary>
            Tuple descriptor.
            Provides information about <see cref="T:Xtensive.Core.Tuples.Tuple"/> structure.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IIdentified`1">
            <summary>
            Describes an object having <see cref="P:Xtensive.Core.IIdentified`1.Identifier"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IIdentified`1.Identifier">
            <summary>
            Gets object identifier.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.GetCommonPartLength(Xtensive.Core.Tuples.TupleDescriptor)">
            <summary>
            Gets the length of the common part.
            </summary>
            <param name="other">The other descriptor.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.IsValueType(System.Int32)">
            <summary>
            Determines whether the specified field is a value type field.
            </summary>
            <param name="fieldIndex">Index of the field to check.</param>
            <returns>
            <see langword="true"/> if specified field is a value type field; 
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.EnsureIsInitialized">
            <summary>
            Ensures the descriptor is compiled.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.IndexOf(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Insert(System.Int32,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Add(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Contains(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.CopyTo(System.Type[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Remove(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Equals(Xtensive.Core.Tuples.TupleDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.CompareTo(Xtensive.Core.Tuples.TupleDescriptor)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create(System.Type[])">
            <summary>
            Creates or returns already created descriptor
            for provided set of types.
            </summary>
            <param name="fieldTypes">List of tuple field types.</param>
            <returns>Either new or existing tuple descriptor
            describing the specified set of fields.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create(System.Collections.Generic.IList{System.Type})">
            <summary>
            Creates or returns already created descriptor
            for provided set of types.
            </summary>
            <param name="fieldTypes">List of tuple field types.</param>
            <returns>Either new or existing tuple descriptor
            describing the specified set of fields.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Creates or returns already created descriptor
            for provided set of types.
            </summary>
            <param name="fieldTypes">Enumerable of tuple field types.</param>
            <returns>Either new or existing tuple descriptor
            describing the specified set of fields.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.TrimFields(System.Int32)">
            <summary>
            Trims the field's set of the current tuple to the specified length.
            </summary>
            <param name="newTupleFieldCount">The length of the field's set
            of the new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/>.</param>
            <returns>Either new or existing tuple descriptor
            describing the specified set of fields.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.SkipFields(System.Int32)">
            <summary>
            Skips first fields of the current tuple.
            </summary>
            <param name="skipFieldCount">The length of the fields to skip.</param>
            <returns>Either new or existing tuple descriptor
            describing the specified set of fields.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create``1">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> by its field type(s).
            </summary>
            <typeparam name="T">Type of the only tuple field.</typeparam>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> object.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create``2">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> by its field type(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> object</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create``3">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> by its field type(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> object</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create``4">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> by its field type(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> object</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create``5">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> by its field type(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <typeparam name="T5">Type of the 5th tuple field.</typeparam>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> object</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.Create``6">
            <summary>
            Creates new <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> by its field type(s).
            </summary>
            <typeparam name="T1">Type of the first tuple field.</typeparam>
            <typeparam name="T2">Type of the 2nd tuple field.</typeparam>
            <typeparam name="T3">Type of the 3rd tuple field.</typeparam>
            <typeparam name="T4">Type of the 4th tuple field.</typeparam>
            <typeparam name="T5">Type of the 5th tuple field.</typeparam>
            <typeparam name="T6">Type of the 6th tuple field.</typeparam>
            <returns>Newly created <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> object</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleDescriptor.#ctor(System.Collections.Generic.IList{System.Type})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="fieldTypes">The types of <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> fields.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.Empty">
            <summary>
            Gets the empty tuple descriptor.
            </summary>
            <value>The empty tuple descriptor.</value>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.TotalCount">
            <summary>
            Gets total count of compiled descriptors.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.Identifier">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.Xtensive#Core#IIdentified#Identifier">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.IsInitialized">
            <summary>
            Indicates whether class for handling underlying 
            <see cref="T:Xtensive.Core.Tuples.Tuple"/> is already compiled.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.TupleType">
            <summary>
            Gets the type of underlying <see cref="T:Xtensive.Core.Tuples.Tuple"/>
            implementation. <see langword="Null"/>, if
            <see cref="P:Xtensive.Core.Tuples.TupleDescriptor.IsInitialized"/>==<see langword="false"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.TupleDescriptor.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Internals.EmptyTupleDescriptor.Instance">
            <summary>
            Provides the only instance of this class.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.SerializableTuple">
            <summary>
            A helper struct allowing to serialize <see cref="T:Xtensive.Core.Tuples.Tuple"/> objects.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.Equals(Xtensive.Core.Tuples.SerializableTuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.op_Equality(Xtensive.Core.Tuples.SerializableTuple,Xtensive.Core.Tuples.SerializableTuple)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.op_Inequality(Xtensive.Core.Tuples.SerializableTuple,Xtensive.Core.Tuples.SerializableTuple)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.SerializableTuple.#ctor(Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="value">The <see cref="P:Xtensive.Core.Tuples.SerializableTuple.Value"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.SerializableTuple.Value">
            <summary>
            Gets the wrapped <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.CutInTransform">
            <summary>
            Cuts in specified value to the <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.MapTransform">
            <summary>
            Base class for any tuple field mapping transform.
            Maps fields of destination tuple to fields of a set of source tuples.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.TupleTransformBase">
            <summary>
            Base class for any tuple transform.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.ITupleTransform">
            <summary>
            Tuple transformation definition.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.ITupleTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,System.Object[])">
            <summary>
            Applies the transformation.
            </summary>
            <param name="transformType">The type of transformation to perform.</param>
            <param name="arguments">Transformation arguments.</param>
            <returns>Transformation result - 
            either <see cref="T:Xtensive.Core.Tuples.Transform.TransformedTuple"/> or <see cref="T:Xtensive.Core.Tuples.Tuple"/> descendant,
            dependently on specified <paramref name="transformType"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Tuples.ITupleTransform.Descriptor">
            <summary>
            Gets <see cref="T:Xtensive.Core.Tuples.TupleDescriptor"/> describing the tuples
            this transform may produce.
            <see langword="Null"/> means "any" (i.e. transform definition 
            is not descriptor-dependent).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.ITupleTransform.DefaultResult">
            <summary>
            Gets the default result tuple.
            Can be used to get default values for the result tuple fields.
            Must be a read-only tuple.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.ITupleTransform.IsReadOnly">
            <summary>
            Indicates whether transform always produces read-only tuples or not.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.TupleTransformBase.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.TupleTransformBase.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TupleTransformBase.Descriptor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TupleTransformBase.DefaultResult">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TupleTransformBase.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="F:Xtensive.Core.Tuples.Transform.MapTransform.NoMapping">
            <summary>
            Means that no mapping is available for the specified field index.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple[])">
            <summary>
            Applies the transformation.
            </summary>
            <param name="transformType">The type of transformation to perform.</param>
            <param name="sources">Transformation sources.</param>
            <returns>Transformation result - 
            either <see cref="T:Xtensive.Core.Tuples.Transform.TransformedTuple"/> or <see cref="T:Xtensive.Core.Tuples.Tuple"/> descendant,
            dependently on specified <paramref name="transformType"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)">
            <summary>
            Applies the transformation.
            </summary>
            <param name="transformType">The type of transformation to perform.</param>
            <param name="source">Transformation source.</param>
            <returns>Transformation result - 
            either <see cref="T:Xtensive.Core.Tuples.Transform.TransformedTuple"/> or <see cref="T:Xtensive.Core.Tuples.Tuple"/> descendant,
            dependently on specified <paramref name="transformType"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            Applies the transformation.
            </summary>
            <param name="transformType">The type of transformation to perform.</param>
            <param name="source1">First transformation source.</param>
            <param name="source2">Second transformation source.</param>
            <returns>Transformation result - 
            either <see cref="T:Xtensive.Core.Tuples.Transform.TransformedTuple"/> or <see cref="T:Xtensive.Core.Tuples.Tuple"/> descendant,
            dependently on specified <paramref name="transformType"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            Applies the transformation.
            </summary>
            <param name="transformType">The type of transformation to perform.</param>
            <param name="source1">First transformation source.</param>
            <param name="source2">Second transformation source.</param>
            <param name="source3">Third transformation source.</param>
            <returns>Transformation result - 
            either <see cref="T:Xtensive.Core.Tuples.Transform.TransformedTuple"/> or <see cref="T:Xtensive.Core.Tuples.Tuple"/> descendant,
            dependently on specified <paramref name="transformType"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.#ctor(System.Boolean,Xtensive.Core.Tuples.TupleDescriptor,Xtensive.Core.Pair{System.Int32,System.Int32}[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="descriptor">Initial <see cref="P:Xtensive.Core.Tuples.Transform.TupleTransformBase.Descriptor"/> property value.</param>
            <param name="map"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.Map"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.#ctor(System.Boolean,Xtensive.Core.Tuples.TupleDescriptor,System.Int32[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="descriptor">Initial <see cref="P:Xtensive.Core.Tuples.Transform.TupleTransformBase.Descriptor"/> property value.</param>
            <param name="map"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.SingleSourceMap"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.#ctor(System.Boolean,Xtensive.Core.Tuples.TupleDescriptor)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="descriptor">Initial <see cref="P:Xtensive.Core.Tuples.Transform.TupleTransformBase.Descriptor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.MapTransform.#ctor(System.Boolean)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.MapTransform.SourceCount">
            <summary>
            Gets the count of source <see cref="N:Xtensive.Core.Tuples"/> this transform maps to the target one.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.MapTransform.SingleSourceMap">
            <summary>
            Gets or sets destination-to-source field map for the first source only.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.MapTransform.Map">
            <summary>
            Gets or sets destination-to-source field map.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutInTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <see cref="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutInTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutInTransform.#ctor(System.Boolean,System.Int32,Xtensive.Core.Tuples.TupleDescriptor[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="index">Start index.</param>
            <param name="sources">Source tuple descriptors.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.CutInTransform.Index">
            <summary>
            Gets the start index at witch this transform cuts in specified value.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.CutInTransform.Sources">
            <summary>
            Gets tuple descriptors this transform cuts in.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.CutInTransform`1">
            <summary>
            Cuts in specified value to the <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutInTransform`1.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,`0)">
            <see cref="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutInTransform`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutInTransform`1.#ctor(System.Boolean,System.Int32,Xtensive.Core.Tuples.TupleDescriptor)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="index">Start index.</param>
            <param name="source1">Source tuple descriptor.</param>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.CutOutTransform">
            <summary>
            Cuts out specified <see cref="P:Xtensive.Core.Tuples.Transform.CutOutTransform.Segment"/> from the <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutOutTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)">
            <see cref="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutOutTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CutOutTransform.#ctor(System.Boolean,Xtensive.Core.Tuples.TupleDescriptor,Xtensive.Core.Segment{System.Int32})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="sourceDescriptor">Source tuple descriptor.</param>
            <param name="segment">The segment to cut out.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.CutOutTransform.Segment">
            <summary>
            Gets the segment this transform cuts out.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple1">
            <summary>
            A <see cref="T:Xtensive.Core.Tuples.Transform.MapTransform"/> result tuple mapping 1 source tuple to a single one (this).
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.TransformedTuple`1">
            <summary>
            Base class for all transformed tuples.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.TransformedTuple">
            <summary>
            Base class for any transformed tuples.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.TransformedTuple.ToString">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TransformedTuple.Transform">
            <summary>
            Gets the transform used to produce this instance.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TransformedTuple.Arguments">
            <summary>
            Gets a list of arguments used in <see cref="M:Xtensive.Core.Tuples.ITupleTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,System.Object[])"/> method
            to produce this tuple.
            <see langword="Null"/> means arguments are unknown an this stage.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TransformedTuple.Descriptor">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.TransformedTuple`1.#ctor(`0)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="transform">Tuple transform.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TransformedTuple`1.Transform">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.TransformedTuple`1.TypedTransform">
            <summary>
            Gets or sets the transform used to produce this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple1.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple1.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple1.SetValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple1.#ctor(Xtensive.Core.Tuples.Transform.MapTransform,Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="transform">The transform.</param>
            <param name="source">Source tuple.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple1.Arguments">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.ReadOnlyTransform">
            <summary>
            Describes read-only tuple transformation.
            </summary>
            <remarks>
            <para id="About"><see cref="T:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate" copy="true"/></para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.ReadOnlyTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,System.Object[])">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.ReadOnlyTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)">
            <summary>
            Typed version of <see cref="M:Xtensive.Core.Tuples.Transform.ReadOnlyTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,System.Object[])"/>.
            </summary>
            <param name="transformType">The type of transformation to perform.</param>
            <param name="source">Transformation argument.</param>
            <returns>Transformation result - 
            either <see cref="T:Xtensive.Core.Tuples.Transform.TransformedTuple"/> or <see cref="T:Xtensive.Core.Tuples.Tuple"/> descendant,
            dependently on specified <paramref name="transformType"/>.</returns>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.ReadOnlyTransform.Instance">
            <see cref="P:Xtensive.Core.Internals.DocTemplates.SingletonDocTemplate.Instance" copy="true"/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.ReadOnlyTransform.IsReadOnly">
            <summary>
            <inheritdoc/>
            Implementation in this class always returns <see langword="true"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.Internals.ReadOnlyTransformTuple">
            <summary>
            A tuple wrapper for <see cref="T:Xtensive.Core.Tuples.Transform.ReadOnlyTransform"/>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase">
            <summary>
            Base class for one-to-one tuple transformations.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.SetValue(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.Equals(Xtensive.Core.Tuples.Tuple)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.#ctor(Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="tuple">Tuple to provide the wrapper for.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.Descriptor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.Count">
            <inheritdoc />
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.WrappingTransformTupleBase.Arguments">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.ReadOnlyTransformTuple.SetValue(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.ReadOnlyTransformTuple.#ctor(Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="tuple">Tuple to provide read-only wrapper for.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.Internals.ReadOnlyTransformTuple.Transform">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.Internals.ReadOnlyTransformTuple.Arguments">
            <inheritdoc/>
            <remarks>
            This method always returns <see cref="P:Xtensive.Core.Collections.ArrayUtils`1.EmptyArray"/> of <see cref="T:System.Object"/>s
            to block any access to the original tuple.
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.SegmentTransform">
            <summary>
            Extracts specified <see cref="P:Xtensive.Core.Tuples.Transform.SegmentTransform.Segment"/> from the <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.SegmentTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)">
            <see cref="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.SegmentTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.SegmentTransform.#ctor(System.Boolean,Xtensive.Core.Tuples.TupleDescriptor,Xtensive.Core.Segment{System.Int32})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="sourceDescriptor">Source tuple descriptor.</param>
            <param name="segment">The segment to extract.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.SegmentTransform.Segment">
            <summary>
            Gets the segment this transform extracts.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.Log">
            <summary>
            Log for this namespace.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Transform.Log.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple">
            <summary>
            A <see cref="T:Xtensive.Core.Tuples.Transform.MapTransform"/> result tuple mapping arbitrary count of source tuples to a single one (this).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple.SetValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple.#ctor(Xtensive.Core.Tuples.Transform.MapTransform,Xtensive.Core.Tuples.Tuple[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="transform">The transform.</param>
            <param name="sources">Source tuples.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple.Arguments">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.CombineTransform">
            <summary>
            This class is used for source <see cref="T:Xtensive.Core.Tuples.Tuple"/>s combining.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CombineTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <see cref="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CombineTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <see cref="M:Xtensive.Core.Tuples.Transform.MapTransform.Apply(Xtensive.Core.Tuples.Transform.TupleTransformType,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)" copy="true"/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CombineTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.CombineTransform.#ctor(System.Boolean,Xtensive.Core.Tuples.TupleDescriptor[])">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="isReadOnly"><see cref="P:Xtensive.Core.Tuples.Transform.MapTransform.IsReadOnly"/> property value.</param>
            <param name="sources">Source tuple descriptors.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.CombineTransform.Sources">
            <summary>
            Gets tuple descriptors this transform merges.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3">
            <summary>
            A <see cref="T:Xtensive.Core.Tuples.Transform.MapTransform"/> result tuple mapping up to 3 source tuples to a single one (this).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3.GetFieldState(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3.GetValue(System.Int32,Xtensive.Core.Tuples.TupleFieldState@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3.SetValue(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3.#ctor(Xtensive.Core.Tuples.Transform.MapTransform,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="transform">The transform.</param>
            <param name="source1">First source tuple.</param>
            <param name="source2">2nd source tuple.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3.#ctor(Xtensive.Core.Tuples.Transform.MapTransform,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="transform">The transform.</param>
            <param name="source1">First source tuple.</param>
            <param name="source2">2nd source tuple.</param>
            <param name="source3">3rd source tuple.</param>
        </member>
        <member name="P:Xtensive.Core.Tuples.Transform.Internals.MapTransformTuple3.Arguments">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Tuples.Transform.TupleTransformType">
            <summary>
            Enumerates possible tuple transformation types.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Transform.TupleTransformType.Default">
            <summary>
            Default transform type (<see cref="F:Xtensive.Core.Tuples.Transform.TupleTransformType.Auto"/>).
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Transform.TupleTransformType.Auto">
            <summary>
            Transform type is detected automatically based on sources.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Transform.TupleTransformType.TransformedTuple">
            <summary>
            <see cref="F:Xtensive.Core.Tuples.Transform.TupleTransformType.TransformedTuple"/> must be returned.
            A wrapper performing specified transform on-the-fly is returned.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.Transform.TupleTransformType.Tuple">
            <summary>
            <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> must be returned.
            Transform is performed right now and a newly created tuple is returned.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Tuples.TupleExtensions">
            <summary>
            Various extension methods for <see cref="T:Xtensive.Core.Tuples.Tuple"/> and <see cref="T:Xtensive.Core.Tuples.Tuple"/> types.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the specified source index 
            and pastes them to <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the specified target index. 
            </summary>
            <param name="source">Source tuple to copy.</param>
            <param name="target">Tuple that receives the data.</param>
            <param name="startIndex">The index in the <paramref name="source"/> tuple at which copying begins.</param>
            <param name="targetStartIndex">The index in the <paramref name="target"/> tuple at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32,System.Int32)">
            <summary>
            Copies a range of elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the specified source index 
            and pastes them to <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the first element. 
            </summary>
            <param name="source">Source tuple to copy.</param>
            <param name="target">Tuple that receives the data.</param>
            <param name="startIndex">The index in the <paramref name="source"/> tuple at which copying begins.</param>
            <param name="length">The number of elements to copy.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32)">
            <summary>
            Copies a range of elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the <paramref name="startIndex"/>
            and pastes them into <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the first element. 
            </summary>
            <param name="source">Source tuple to copy.</param>
            <param name="target">Tuple that receives the data.</param>
            <param name="startIndex">The index in the <paramref name="source"/> tuple at which copying begins.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            Copies all the elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the first element
            and pastes them into <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            starting at the first element.
            </summary>
            <param name="source">Source tuple to copy.</param>
            <param name="target">Tuple that receives the data.</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32[])">
            <summary>
            Copies a set of elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> 
            to <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> using 
            specified target-to-source field index <paramref name="map"/>.
            </summary>
            <param name="source">Source tuple to copy.</param>
            <param name="target">Tuple that receives the data.</param>
            <param name="map">Target-to-source field index map.
            Negative value in this map means "skip this element".</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Tuples.Tuple[],Xtensive.Core.Tuples.Tuple,Xtensive.Core.Pair{System.Int32,System.Int32}[])">
            <summary>
            Copies a set of elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/>s
            to <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> using 
            specified target-to-source field index <paramref name="map"/>.
            </summary>
            <param name="source">Source tuples to copy.</param>
            <param name="target">Tuple that receives the data.</param>
            <param name="map">Target-to-source field index map.
            Negative value in this map means "skip this element".</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.CopyTo(Xtensive.Core.Collections.FixedList3{Xtensive.Core.Tuples.Tuple},Xtensive.Core.Tuples.Tuple,Xtensive.Core.Pair{System.Int32,System.Int32}[])">
            <summary>
            Copies a set of elements from <paramref name="source"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/>s
            to <paramref name="target"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> using 
            specified target-to-source field index <paramref name="map"/>.
            </summary>
            <param name="source">Source tuples to copy.</param>
            <param name="target">Tuple that receives the data.</param>
            <param name="map">Target-to-source field index map.
            Negative value in this map means "skip this element".</param>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.Combine(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)">
            <summary>
            Combines the <paramref name="left"/> with <paramref name="right"/>.
            </summary>
            <param name="left">The first <see cref="T:Xtensive.Core.Tuples.Tuple"/> to combine.</param>
            <param name="right">The second <see cref="T:Xtensive.Core.Tuples.Tuple"/> to combine.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.GetSegment(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Segment{System.Int32})">
            <summary>
            Cuts out <paramref name="segment"/> from <paramref name="left"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
            <param name="left">The <see cref="T:Xtensive.Core.Tuples.Tuple"/> to get segment from.</param>
            <param name="segment">The <see cref="T:Xtensive.Core.Segment`1"/> to cut off.</param>
            <returns></returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.MergeWith(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32,System.Int32,Xtensive.Core.Tuples.MergeBehavior)">
            <summary>
            Merges a range of fields from <paramref name="difference"/>
            <see cref="T:Xtensive.Core.Tuples.Tuple"/> starting at the specified index with the fields from
            <paramref name="origin"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> with the specified
            <paramref name="behavior"/>.
            </summary>
            <param name="origin">Tuple containing original values and receiving the data.</param>
            <param name="difference">Tuple with differences to merge with.</param>
            <param name="startIndex">The index in the <paramref name="difference"/> tuple at which merging begins.</param>
            <param name="length">The number of elements to process.</param>
            <param name="behavior">The merge behavior that will be used to resolve conflicts when both values 
            from <paramref name="difference"/> and <paramref name="origin"/> are available.</param>
            <exception cref="T:System.ArgumentException">Tuple descriptors mismatch.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Tuples.TupleExtensions.MergeWith(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32,System.Int32)" -->
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.MergeWith(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32,Xtensive.Core.Tuples.MergeBehavior)">
            <summary>
            Merges a range of fields from <paramref name="difference"/>
            <see cref="T:Xtensive.Core.Tuples.Tuple"/> starting at the specified index with the fields from
            <paramref name="origin"/> <see cref="T:Xtensive.Core.Tuples.Tuple"/> with the specified
            <paramref name="behavior"/>.
            </summary>
            <param name="origin">Tuple containing original values and receiving the data.</param>
            <param name="difference">Tuple with differences to merge with.</param>
            <param name="startIndex">The index in the <paramref name="difference"/> tuple at which merging begins.</param>
            <param name="behavior">The merge behavior that will be used to resolve conflicts when both values 
            from <paramref name="difference"/> and <paramref name="origin"/> are available.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Tuples.TupleExtensions.MergeWith(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Tuples.TupleExtensions.MergeWith(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.MergeBehavior)" -->
        <!-- Badly formed XML comment ignored for member "M:Xtensive.Core.Tuples.TupleExtensions.MergeWith(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Tuple)" -->
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.ToRegular(Xtensive.Core.Tuples.Tuple)">
            <summary>
            Creates <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> instance "filled" with the same field values
            as the specified <paramref name="source"/> tuple.
            </summary>
            <param name="source">The tuple to clone as <see cref="T:Xtensive.Core.Tuples.RegularTuple"/>.</param>
            <returns>A new instance of <see cref="T:Xtensive.Core.Tuples.RegularTuple"/> with the same field values
            as the specified <paramref name="source"/> tuple.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.ToReadOnly(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.Transform.TupleTransformType)">
            <summary>
            Converts <paramref name="source"/> tuple to read-only one.
            </summary>
            <param name="source">The tuple to convert to read-only.</param>
            <param name="transformType">The type of transformation to perform.</param>
            <returns>Read-only version of <paramref name="source"/> tuple.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.ToFastReadOnly(Xtensive.Core.Tuples.Tuple)">
            <summary>
            Converts <paramref name="source"/> tuple to fast read-only one.
            </summary>
            <param name="source">The tuple to convert to fast read-only.</param>
            <returns>Fast read-only version of <paramref name="source"/> tuple.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.GetFieldStateMap(Xtensive.Core.Tuples.Tuple,Xtensive.Core.Tuples.TupleFieldState)">
            <summary>
            Gets the field state map of the specified <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
            <param name="target">The <see cref="T:Xtensive.Core.Tuples.Tuple"/> to inspect.</param>
            <param name="requestedState">The state to compare with.</param>
            <returns>Newly created <see cref="T:System.Collections.BitArray"/> instance which holds inspection result.</returns>
        </member>
        <member name="M:Xtensive.Core.Tuples.TupleExtensions.Initialize(Xtensive.Core.Tuples.Tuple,System.Collections.BitArray)">
            <summary>
            Initializes the specified <see cref="T:Xtensive.Core.Tuples.Tuple"/> with default values.
            </summary>
            <param name="target">Tuple to initialize.</param>
            <param name="nullableMap"><see cref="T:System.Collections.BitArray"/> instance that flags that field should have null value.</param>
            <exception cref="T:System.ArgumentException">Tuple descriptor field count is not equal to <paramref name="nullableMap"/> count.</exception>
        </member>
        <member name="T:Xtensive.Core.Tuples.TupleFieldState">
            <summary>
            Defines field state that can be set or get for each field in <see cref="T:Xtensive.Core.Tuples.Tuple"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.TupleFieldState.Default">
            <summary>
            Default value
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.TupleFieldState.Available">
            <summary>
            Field value is available in tuple.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Tuples.TupleFieldState.Null">
            <summary>
            Field has null value.
            Used with both nullable and non-nullable fields.
            </summary>
        </member>
        <member name="T:Xtensive.Core.ContextBoundExtensions">
            <summary>
            <see cref="T:Xtensive.Core.IoC.IContextBound`1"/> related extension methods.
            </summary>
        </member>
        <member name="M:Xtensive.Core.ContextBoundExtensions.ActivateContext``1(Xtensive.Core.IoC.IContextBound{``0})">
            <summary>
            Activates the context of <typeparamref name="TContext"/> type
            of specified <paramref name="contextBound"/>.
            </summary>
            <typeparam name="TContext">The type of context to activate.</typeparam>
            <param name="contextBound">The object to activate the context of.</param>
            <returns><see cref="T:System.IDisposable"/> object (normally - <see cref="T:Xtensive.Core.IoC.Scope`1"/> descendant)
            that can be used to deactivate the context by disposing it.</returns>
        </member>
        <member name="T:Xtensive.Core.UrlInfo">
            <summary>
            Holds an URL and provides easy access to its different parts.
            </summary>
            <remarks>
            <para>
            The common URL format that would be converted 
            to the <see cref="T:Xtensive.Core.UrlInfo"/> can be represented 
            in the BNF form as following:
            <code lang="BNF" outline="true">
            url ::= protocol://[user[:password]@]host[:port]/resource[?parameters]
            protocol ::= alphanumx[protocol]
            user ::= alphanumx[user]
            password ::= alphanumx[password]
            host ::= hostname | hostnum
            port ::= digits
            resource ::= name
            parameters ::= parameter[&amp;parameter]
            
            hostname ::= name[.hostname]
            hostnum ::= digits.digits.digits.digits
            
            parameter ::= name=[name]
            
            name ::= alpanumx[name]
            
            digits ::= digit[digits]
            alphanumx ::= alphanum | escape | $ | - | _ | . | + | ! | * | " | ' | ( | ) | , | ; | # | space
            alphanum ::= alpha | digit
            escape ::= % hex hex
            hex ::= digit | a | b | c | d | e | f | A | B | C | D | E | F
            digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
            alpha ::= /* represents any unicode alpa character */
            </code>
            </para>
            <note>
            This not fully precise notation because it slightly simplified to be shorter.
            But it almost completely reflects <see cref="T:Xtensive.Core.UrlInfo"/> URL parser
            capabilities.
            </note>
            <para>
            Here you can see several valid URL samples:
            <pre>
            tcp://localhost/
            tcp://server:40000/myResource
            tcp://admin:admin@localhost:40000/myResource?askTimeout=60
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.Parse(System.String)">
            <summary>
            Splits URL into parts (protocol, host, port, resource, user, password) and set all
            derived values to the corresponding properties of the instance.
            </summary>
            <param name="url">URL to split</param>
            <remarks>
            The expected URL format is as the following:
            proto://[[user[:password]@]host[:port]]/resource.
            Note that the empty URL will cause an exception.
            </remarks>
            <exception cref="T:System.ArgumentException">Specified <paramref name="url"/> is invalid (cannot be parsed).</exception>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.Equals(Xtensive.Core.UrlInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.CompareTo(Xtensive.Core.UrlInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.op_Equality(Xtensive.Core.UrlInfo,Xtensive.Core.UrlInfo)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.op_Inequality(Xtensive.Core.UrlInfo,Xtensive.Core.UrlInfo)">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
             Deserilizing constructor.
            </summary>
             <param name="context">The source (see <see cref="T:System.Runtime.Serialization.StreamingContext"></see>) for this deserialization. </param>
             <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> to populate the data from. </param>
        </member>
        <member name="M:Xtensive.Core.UrlInfo.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> with the data needed to serialize the target object.
            </summary>
            <param name="context">The destination (see <see cref="T:System.Runtime.Serialization.StreamingContext"></see>) for this serialization. </param>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"></see> to populate with data. </param>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission. </exception>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Url">
            <summary>
            Gets an URL this instance describes.
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Protocol">
            <summary>
            Gets the protocol part of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>"tcp"</b> is the protocol part of the "<b>tcp</b>://admin:password@localhost/resource" URL).
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Host">
            <summary>
            Gets the host part of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>"localhost"</b> is the host part of the "tcp://admin:password@<b>localhost</b>/resource" URL).
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Port">
            <summary>
            Gets the port part of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>40000</b> is the port part of the "tcp://admin:password@localhost:<b>40000</b>/resource" URL).
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Resource">
            <summary>
            Gets the resource name part of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>"resource"</b> is the resource name part of the "tcp://admin:password@localhost/<b>resource</b>" URL).
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.User">
            <summary>
            Gets the user name part of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>"admin"</b> is the user name part of the "tcp://<b>admin</b>:password@localhost/resource" URL).
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Password">
            <summary>
            Gets the password part of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>"password"</b> is the password part of the "tcp://admin:<b>password</b>@localhost/resource" URL).
            </summary>
        </member>
        <member name="P:Xtensive.Core.UrlInfo.Params">
            <summary>
            Gets additional parameters of the current <see cref="P:Xtensive.Core.UrlInfo.Url"/>
            (e.g. <b>"param1=value1&amp;param2=value2"</b> is the additional parameters part
            of the "tcp://admin:password@localhost/resource?<b>param1=value1&amp;param2=value2</b>" URL).
            </summary>
            <remarks>
            <para>The mentioned part of the <see cref="P:Xtensive.Core.UrlInfo.Url"/> is parsed
            and represented in a <see cref="T:System.Collections.Generic.Dictionary`2"/> form.</para>
            </remarks>
        </member>
        <member name="T:Xtensive.Core.Pair`2">
            <summary>
            A pair of two values.
            </summary>
            <typeparam name="TFirst">The <see cref="T:System.Type"/> of first value.</typeparam>
            <typeparam name="TSecond">The <see cref="T:System.Type"/> of second value.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Pair`2.First">
            <summary>
            A first value.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Pair`2.Second">
            <summary>
            A second value.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Pair`2.Equals(Xtensive.Core.Pair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.CompareTo(Xtensive.Core.Pair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.op_Equality(Xtensive.Core.Pair{`0,`1},Xtensive.Core.Pair{`0,`1})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorEq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.op_Inequality(Xtensive.Core.Pair{`0,`1},Xtensive.Core.Pair{`0,`1})">
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.OperatorNeq(Xtensive.Core.Internals.DocTemplates.ClassDocTemplate,Xtensive.Core.Internals.DocTemplates.ClassDocTemplate)"/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Pair`2.#ctor(`0,`1)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="first">A first value in pair.</param>
            <param name="second">A second value in pair.</param>
        </member>
        <member name="T:Xtensive.Core.Resources.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.AnyCulture">
            <summary>
              Looks up a localized string similar to *.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.BoxFormat">
            <summary>
              Looks up a localized string similar to Box({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.CachedFormat">
            <summary>
              Looks up a localized string similar to Cached({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ComparisonRuleFormat">
            <summary>
              Looks up a localized string similar to ComparisonRule({0}, {1}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ComparisonRulesFormat">
            <summary>
              Looks up a localized string similar to ComparisonRules({0}, [{1}]).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ComprehensiveLogFormat">
            <summary>
              Looks up a localized string similar to {0,6:F2}s/T{1,-5} {2,5} {3,-24} {4}{5}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.EmptyString">
            <summary>
              Looks up a localized string similar to &apos;&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.EntireFormat">
            <summary>
              Looks up a localized string similar to Entire({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExAccessedMemberIsNotProperty">
            <summary>
              Looks up a localized string similar to The accessed member is not a property..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExActualConjunctionOperandCountGreaterThanExpected">
            <summary>
              Looks up a localized string similar to Actual conjunction operand count greater than MaxConjunctionOperandCount..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExAlreadyDisposed">
            <summary>
              Looks up a localized string similar to Object is already disposed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExAlreadyInitialized">
            <summary>
              Looks up a localized string similar to Instance is already initialized..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentCannotBeEmptyString">
            <summary>
              Looks up a localized string similar to Argument can&apos;t be an empty string..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentMustBeGreaterThanX">
            <summary>
              Looks up a localized string similar to Argument must be greater than &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentMustBeGreaterThatOrEqualX">
            <summary>
              Looks up a localized string similar to Argument must be greater that or equal &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentMustBeLessThanOrEqualX">
            <summary>
              Looks up a localized string similar to Argument must be less than or equal &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentMustBeLessThanX">
            <summary>
              Looks up a localized string similar to Argument must be less than &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentMustnotBeOfTypeX">
            <summary>
              Looks up a localized string similar to The argument must not be of type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentShouldBeInRange">
            <summary>
              Looks up a localized string similar to Argument should be in range [{0}...{1}]..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentValueMustBeGreaterThanOrEqualToZero">
            <summary>
              Looks up a localized string similar to Argument value must be greater than or equal to zero..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentValueMustBeGreaterThanZero">
            <summary>
              Looks up a localized string similar to Argument value must be greater than zero..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArgumentXIsLessThanArgumentY">
            <summary>
              Looks up a localized string similar to The argument &apos;{0}&apos; is less than the argument &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArrayDoesNotHaveZeroBasedIndexing">
            <summary>
              Looks up a localized string similar to Array does not have zero-based indexing..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExArrayIsMultidimensional">
            <summary>
              Looks up a localized string similar to Array is multidimentional..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExASetOfExceptionsIsCaught">
            <summary>
              Looks up a localized string similar to A set of exceptions is caught..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExBothMeasurementsHaveNoValue">
            <summary>
              Looks up a localized string similar to Both measurements have no value..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCannotActivateServiceXErrorY">
            <summary>
              Looks up a localized string similar to Can&apos;t activate service &apos;{0}&apos;. Error: {1}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCannotActivateServiceXWithKeyYErrorZ">
            <summary>
              Looks up a localized string similar to Can&apos;t activate service &apos;{0}&apos; with name &quot;{1}&quot;. Error: {2}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCannotParseCallToComparisonMethod">
            <summary>
              Looks up a localized string similar to Can&apos;t parse the call to the comparison method..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCantCreateAssociateForGenericTypeDefinitions">
            <summary>
              Looks up a localized string similar to Can&apos;t create associates for generic type definitions (type &apos;{0}&apos;)..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCantFindAssociate">
            <summary>
              Looks up a localized string similar to Can&apos;t find associated {0} of type &apos;{1}&apos; for type &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCantFindAssociate2">
            <summary>
              Looks up a localized string similar to Can&apos;t find associated {0} of type &apos;{1}&apos; for type &apos;{2}&apos; or &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCantPassNoInfinityToThisConstructor">
            <summary>
              Looks up a localized string similar to InfinityType.None can&apos;t be passed to this constructor..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionAlreadyContainsItemWithSpecifiedKey">
            <summary>
              Looks up a localized string similar to Collection already contains item with the specified key..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionAlreadyContainsSpecifiedItem">
            <summary>
              Looks up a localized string similar to Collecton already contains specified item..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionHasBeenChanged">
            <summary>
              Looks up a localized string similar to Collection has been changed during the enumeration..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionHasBeenModified">
            <summary>
              Looks up a localized string similar to Collection has been modified..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionIsEmpty">
            <summary>
              Looks up a localized string similar to Collection is empty..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionIsReadOnly">
            <summary>
              Looks up a localized string similar to Collection is read-only..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionOrCoutableExcpected">
            <summary>
              Looks up a localized string similar to Item should be either an ICollection or ICountable..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCollectionPropertyXIsBoundToPropertyYThatIsNotCollection">
            <summary>
              Looks up a localized string similar to The collection property {0} is bound to the property {1} that isn&apos;t collection..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerForXIsAlreadyRegistered">
            <summary>
              Looks up a localized string similar to Compiler for {0} is already registered..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXHasBadTargetMember">
            <summary>
              Looks up a localized string similar to Compiler {0} has &quot;bad&quot; target member..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXHasBadTargetType">
            <summary>
              Looks up a localized string similar to Compiler {0} has &quot;bad&quot; target type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXHasTooManyParameters">
            <summary>
              Looks up a localized string similar to Compiler {0} has too many parameters..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXShouldHaveMemberInfoParameter">
            <summary>
              Looks up a localized string similar to Compiler {0} should have first parameter of type MemberInfo.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXShouldHaveParameterYOfTypeZ">
            <summary>
              Looks up a localized string similar to Compiler {0} should have parameter {1} of type {2}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXShouldHaveThisParameter">
            <summary>
              Looks up a localized string similar to Compiler {0} should have &quot;this&quot; parameter..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCompilerXShouldReturnY">
            <summary>
              Looks up a localized string similar to Compiler {0} should return {1}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExContainerTypeDoesNotProvideASuitableConstructor">
            <summary>
              Looks up a localized string similar to Container type does not provide a suitable constructor..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExContainerTypeMustImplementX">
            <summary>
              Looks up a localized string similar to Container type must implement {0}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExContextRequired">
            <summary>
              Looks up a localized string similar to {0} is required. Use {1} to set it..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCopyToMustOperateWithDifferentStreams">
            <summary>
              Looks up a localized string similar to Unable to copy a part of the stream to itself. Use StreamExtensions.Copy method instead..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCouldNotLoadTypesFromAssembly">
            <summary>
              Looks up a localized string similar to Could not load types from the assembly &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExCultureOfAppliedRuleShouldBeEitherNullOrTheSameAsOnTarget">
            <summary>
              Looks up a localized string similar to Culture of the applied rule should either be undefined (null), or be the same as on target rule..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDependencyOperationIsAlreadyRegistered">
            <summary>
              Looks up a localized string similar to Dependency operation with full name &quot;{0}&quot; is already registered..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDescriptorIsInInvalidState">
            <summary>
              Looks up a localized string similar to Descriptor is in invalid state..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDeserializationErrorUnrecognizedSlotsAreFound">
            <summary>
              Looks up a localized string similar to Deserialization error: some SerializationData slots were not recognized, thus the format of the serialized data differs from the supported one..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDeserializationStreamLengthIncorrect">
            <summary>
              Looks up a localized string similar to Stream length not enough to deserialize object of specified type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDestionationArrayIsTooSmall">
            <summary>
              Looks up a localized string similar to Destionation array is too small..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDetectionOfChangesInUserStructureCollectionIsNotSupported">
            <summary>
              Looks up a localized string similar to The detection of changes in user structure collection isn&apos;t supported..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExDifferentTupleDescriptors">
            <summary>
              Looks up a localized string similar to Different TupleDescriptors are not valid here: {0} and {1}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExEndPointOrderMustBeEqual">
            <summary>
              Looks up a localized string similar to EndPoints order of both ranges must be equal..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExEnumerationIsAlreadyFinished">
            <summary>
              Looks up a localized string similar to Enumeration is already finished..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExEscapeCharacterMustDifferFromDelimiterCharacter">
            <summary>
              Looks up a localized string similar to Escape character must differ from delimiter character..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExExceptionWasThrownDuringTaskExecution">
            <summary>
              Looks up a localized string similar to The exception was thrown during the task&apos;s execution..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExExpectedValueOfParameterIsAlreadySet">
            <summary>
              Looks up a localized string similar to The expected value of the parameter is already set..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExExpressionHavingDifferentNormalFormMustNotBeRoot">
            <summary>
              Looks up a localized string similar to The expression having the different normal form must not be a root expression..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExExpressionHavingEqualNormalFormMustBeRoot">
            <summary>
              Looks up a localized string similar to The expression having the equal normal form must be a root expression..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExExpressionMustReturnValueOfTypeX">
            <summary>
              Looks up a localized string similar to The expression must return a value of type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExFieldIsInfinite">
            <summary>
              Looks up a localized string similar to Field with index &apos;{0}&apos; is infinitу..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExGenericParameterShouldBeOfTypeT">
            <summary>
              Looks up a localized string similar to Generic parameter &apos;{0}&apos; should be of type &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExGivenKeyNotPresent">
            <summary>
              Looks up a localized string similar to The given key was not present in the dictionary..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInadmissibleTypeConversion">
            <summary>
              Looks up a localized string similar to Conversion from type {0} to type {1} is inadmissible..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExIncompatibleArrayType">
            <summary>
              Looks up a localized string similar to Incompatible array type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInconsistentComparisons">
            <summary>
              Looks up a localized string similar to The two collections cannot be combined because they use different comparison operations..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExIndexOutOfRange">
            <summary>
              Looks up a localized string similar to Index is out of range..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExIndexShouldBeInNMRange">
            <summary>
              Looks up a localized string similar to Index should be in [{0}...{1}] range..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInstanceIsLocked">
            <summary>
              Looks up a localized string similar to Instance is locked..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInstanceMustHaveSyncRoot">
            <summary>
              Looks up a localized string similar to A instance must have non-null IHasSyncRoot.SyncRoot property value..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInternalError">
            <summary>
              Looks up a localized string similar to Internal error: {0}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidActiveScope">
            <summary>
              Looks up a localized string similar to Active scope is invalid - it differs from the expected one. Probably you have forgot to dispose some nested scope..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidArgumentType">
            <summary>
              Looks up a localized string similar to Invalid argument type: expected type is {0}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidCapacity">
            <summary>
              Looks up a localized string similar to The specified capacity value is less than collection count..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidCast">
            <summary>
              Looks up a localized string similar to Cast from &apos;{0}&apos; to &apos;{1}&apos; is invalid..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidFieldMapSizeExpectedX">
            <summary>
              Looks up a localized string similar to Invalid field map size. Expected {0}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidFormatterProcessType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; formatter process type is invalid for the current operation..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidObjectSerializerSimilarValueSerializerExists">
            <summary>
              Looks up a localized string similar to Object serializer is invalid, since similar value serializer exists..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidRecordType">
            <summary>
              Looks up a localized string similar to Record with invalid (possibly - unspecified) type is found..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidSerializerBehaviorMustNotBeReferable">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; can&apos;t be an IsReferable serializer, since it serializes IReference type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidSerializerType">
            <summary>
              Looks up a localized string similar to Generic parameter T is resolved to associated &apos;{0}&apos;, although &apos;{1}&apos; is expected..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidTupleDescriptorExpectedDescriptorIs">
            <summary>
              Looks up a localized string similar to Invalid TupleDescriptor. Expected descriptor is {0}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExInvalidUrl">
            <summary>
              Looks up a localized string similar to &quot;{0}&quot; is invalid URL..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemCantBeCachedIncompatibleType">
            <summary>
              Looks up a localized string similar to The specified item cannot be cached because its type is incompatible with underlying storage format..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemCantBeComparedIncompatibleType">
            <summary>
              Looks up a localized string similar to The specified item cannot be cached because its type is incompatible with ITuple..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemIsInUse">
            <summary>
              Looks up a localized string similar to Specified item is already in use..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemIsNotInUse">
            <summary>
              Looks up a localized string similar to Specified item is not in use..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemIsNotPooled">
            <summary>
              Looks up a localized string similar to Specified item isn&apos;t pooled..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemNotFound">
            <summary>
              Looks up a localized string similar to Specified item isn&apos;t found..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemWithNameWasNotFound">
            <summary>
              Looks up a localized string similar to Item with name &apos;{0}&apos; was not found..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExItemWithTheSameKeyHasBeenAdded">
            <summary>
              Looks up a localized string similar to An item with the same key has already been added..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExKeyAlreadyExists">
            <summary>
              Looks up a localized string similar to Key already exists..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExKeyXIsNotFound">
            <summary>
              Looks up a localized string similar to Key {0} is not found..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExLambdaParameterXIsOutOfScope">
            <summary>
              Looks up a localized string similar to Lambda parameter &apos;{0}&apos; is out of scope..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExLimitOfGraphDepthIsExceeded">
            <summary>
              Looks up a localized string similar to The limit of the graph depth is exceeded..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExLinkedOperationMissingFormat">
            <summary>
              Looks up a localized string similar to Linked operation for property {0} missing..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMappingForPropertyXHasAlreadyBeenRegistered">
            <summary>
              Looks up a localized string similar to The mapping for the property {0} has already been registered..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMaxItemCountIsN">
            <summary>
              Looks up a localized string similar to Maximal item count is {0}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMeasurementIsAlreadyCompleted">
            <summary>
              Looks up a localized string similar to Measurement is already completed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMeasurementMustHaveValue">
            <summary>
              Looks up a localized string similar to Measurement &apos;{0}&apos; must have value..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMemberIsNotPublicPropertyOrField">
            <summary>
              Looks up a localized string similar to Member: &apos;{0}&apos; is not a Public Property or Field of Type: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMergeOperationRequireIntersectionOfOperands">
            <summary>
              Looks up a localized string similar to Merge operation require intersection of operands..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMinMaxValuesAreNotSupportedForTupleFieldAdvancedComparer">
            <summary>
              Looks up a localized string similar to MinMaxValues aren&apos;t supported for TupleFieldAdvancedComparer..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMultipleAssociatesMatch">
            <summary>
              Looks up a localized string similar to Multiple associates match type &apos;{0}&apos; by its interfaces (at least &apos;{1}&apos; and &apos;{2}&apos;)..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMultipleAttributesOfTypeXAreNotAllowedHere">
            <summary>
              Looks up a localized string similar to {0}: multiple attributes of type &apos;{1}&apos; are not allowed here..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExMultipleServicesMatchToTheSpecifiedArguments">
            <summary>
              Looks up a localized string similar to Multiple services match to the specified arguments..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExNestedCollectionIsNotSupported">
            <summary>
              Looks up a localized string similar to Nested collection is not supported..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExNoAvailableItems">
            <summary>
              Looks up a localized string similar to There are no more available items..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExNoObjectWithSpecifiedKey">
            <summary>
              Looks up a localized string similar to There is no object with specified key..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExNotInitialized">
            <summary>
              Looks up a localized string similar to Instance is not initialized (or not initialized properly)..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExNullablePropertyXIsBoundToPropertyYThatIsNotNullable">
            <summary>
              Looks up a localized string similar to The nullable property {0} is bound to the property {1} that isn&apos;t nullable..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExObjectIsReadOnly">
            <summary>
              Looks up a localized string similar to Object is read-only..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExOnlyBreakableNodesSadSmile">
            <summary>
              Looks up a localized string similar to Only breakable nodes :(.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExOnlyNormalizedExpressionCanBeAddedAsChildToRoot">
            <summary>
              Looks up a localized string similar to Only the normalized expression having the different normal form can be added as the immediate descendant to the root expression..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExOnlyOneAncestorOfEachInstanceOfThisGenericTypeIsAllowed">
            <summary>
              Looks up a localized string similar to Only one ancestor of each instance of this generic type is allowed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExOperationLinkTypeUndefined">
            <summary>
              Looks up a localized string similar to Operation LinkType should be defined before it can be registered in OperationDictionary..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExOperationMustBeLocked">
            <summary>
              Looks up a localized string similar to Operation must be locked before it can be registered in OperationDictionary..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExOperationPropertyNameUndefined">
            <summary>
              Looks up a localized string similar to Operation PropertyName must be specified before it can be registered in OperationDictionary..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPoolMustBeSyncronized">
            <summary>
              Looks up a localized string similar to Pool should be in syncronized mode to utilize AutoCleanup feature..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPoolWrongKey">
            <summary>
              Looks up a localized string similar to Item already exists in the pool with another key..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPortOutOfRange">
            <summary>
              Looks up a localized string similar to Port value must be in [0,65535] range..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPrimitivePropertyXIsBoundToPropertyYThatIsNotPrimitive">
            <summary>
              Looks up a localized string similar to The primitive property {0} is bound to the property {1} that isn&apos;t primitive..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPropertiesXAndYHaveDifferentPrimitiveTypes">
            <summary>
              Looks up a localized string similar to The properties {0} and {1} have different primitive types..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPropertiesXAndYHaveIncompatibleTypes">
            <summary>
              Looks up a localized string similar to The properties &quot;{0}&quot; and &quot;{1}&quot; have incompatible types..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPropertyDoesNotHaveGetter">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; of type &apos;{1}&apos; does not have public get accessor..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPropertyDoesNotHaveSetter">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; of type &apos;{1}&apos; does not have public set accessor..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPropertyIsAlreadyInitialized">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; is already initialized..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExPropertyIsNotInitialized">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; is not initialized (or not initialized properly)..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExRangeIsEmpty">
            <summary>
              Looks up a localized string similar to Range is empty..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExRecursiveAssociateLookupDetected">
            <summary>
              Looks up a localized string similar to Recursive associate lookup is detected..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExRecursiveConstructorParemeterDependencyIsDetected">
            <summary>
              Looks up a localized string similar to Recursive constructor paremeter dependency is detected..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExReferenceIsAlreadyDefined">
            <summary>
              Looks up a localized string similar to Reference &apos;{0}&apos; is already defined..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExReferenceIsNotResolvedYet">
            <summary>
              Looks up a localized string similar to Reference &apos;{0}&apos; is not resolved yet..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExReferenceIsNull">
            <summary>
              Looks up a localized string similar to Reference points to null..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExReferencePropertyXIsBoundToPropertyYThatIsNotReference">
            <summary>
              Looks up a localized string similar to The reference property {0} is bound to the property {1} that isn&apos;t reference..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExResourcePropertyXIsNotOfStringType">
            <summary>
              Looks up a localized string similar to Resource property {0} is not of string type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExScopeCantBeDisposed">
            <summary>
              Looks up a localized string similar to Scope can&apos;t be disposed. Most likely it is bound to a different thread..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExScopeRequired">
            <summary>
              Looks up a localized string similar to {0} is required..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSegmentIsOutOfRange">
            <summary>
              Looks up a localized string similar to Segment is out of range..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExServiceNotFound">
            <summary>
              Looks up a localized string similar to Service &apos;{0}&apos; is not found..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExServiceOfTypeXIsNotAvailable">
            <summary>
              Looks up a localized string similar to Service of type &apos;{0}&apos; is not available..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExServiceWithNameXOfTypeYIsNotAvailable">
            <summary>
              Looks up a localized string similar to Service with name &quot;{0}&quot; of type &apos;{1}&apos; is not available..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSomeOperandsAreNotExpressionsOfTypeBoolean">
            <summary>
              Looks up a localized string similar to Some operands are not Expressions  of type &apos;System.Boolean&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSpecifiedCapacityIsLessThenCollectionCount">
            <summary>
              Looks up a localized string similar to The specified capacity value is less than collection count..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSpecifiedExpressionCanNotBeParsed">
            <summary>
              Looks up a localized string similar to The specified expression can&apos;t be parsed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSpecifiedExpressionIsNotMemberExpression">
            <summary>
              Looks up a localized string similar to The specified expression is not a MemberExpression..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSpecifiedTypeShouldBeGeneratedTupleDescriptorOrItsDescendant">
            <summary>
              Looks up a localized string similar to Specified type should be either GeneratedTupleDescriptor or its descendant..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExStringDoesNotCorrespondToDescriptor">
            <summary>
              Looks up a localized string similar to String does not correspond to the specified descriptor..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExSystemTimeChanged">
            <summary>
              Looks up a localized string similar to System date \ time has been changed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTargetMemberIsNotFoundForCompilerX">
            <summary>
              Looks up a localized string similar to Target member is not found for compiler {0}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTheNumberOfSourcesIsTooSmallExpected">
            <summary>
              Looks up a localized string similar to The number of sources is too small. Expected number is {0}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExThisOperationIsNotAllowedForParameterContextOperatingWithExpectedValuesOfParameters">
            <summary>
              Looks up a localized string similar to This operation is not allowed for the parameter context operating with expected values of parameters..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeIsNotSupportedByBinaryPrimitiveSerializer">
            <summary>
              Looks up a localized string similar to Type is not supported by BinaryPrimitiveSerializer..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXCanNotBeTransformed">
            <summary>
              Looks up a localized string similar to The type {0} can&apos;t be transformed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXDoesNotHavePropertyY">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; does not have property &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXHasAlreadyBeenRegistered">
            <summary>
              Looks up a localized string similar to The type {0} has already been registered..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXHasNotBeenRegistered">
            <summary>
              Looks up a localized string similar to The type {0} hasn&apos;t been registered..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXIsNotSubclassOfTypeY">
            <summary>
              Looks up a localized string similar to The type {0} isn&apos;t a subclass of the type {1}..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXMustBeNonAbstractType">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; must be non-abstract type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXMustBeReferenceType">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; must be reference type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXMustImplementY">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; must implement &apos;{1}&apos;, or must be its descendant..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExTypeXShouldNotBeGeneric">
            <summary>
              Looks up a localized string similar to Type {0} should not be generic..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUnableToBindParametersToLambdaXParametersCountIsIncorrect">
            <summary>
              Looks up a localized string similar to Unable to bind parameters to lambda {0}. Parameters count is incorrect..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUnableToCastNullValueToXUseXInstead">
            <summary>
              Looks up a localized string similar to Unable to cast null value to {0}; use {0}? instead..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUnableToCreateProviderInstance">
            <summary>
              Looks up a localized string similar to Unable to create provider instance. Check if provider&apos;s class has static &quot;Instance&quot; property..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUnableToUseExpressionXAsXParameterOfLambdaXBecauseOfTypeMistmatch">
            <summary>
              Looks up a localized string similar to Unable to use expression {0} as {1} parameter of lambda {2} because of type mistmatch..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUnknownExpressionType">
            <summary>
              Looks up a localized string similar to Unknown expression type: &apos;{0} ({1})&apos;.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUseLogCaptureScopeConstructorInstead">
            <summary>
              Looks up a localized string similar to Use LogCaptureScope constructor instead..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExUseLogIndentScopeConstructorInstead">
            <summary>
              Looks up a localized string similar to Use LogIndentScope constructor instead..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExValueForParameterXIsNotSet">
            <summary>
              Looks up a localized string similar to Value for parameter &apos;{0}&apos; is not set..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExValueIsNotAvailable">
            <summary>
              Looks up a localized string similar to Value is not available..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExValueWithNameXAlreadyExists">
            <summary>
              Looks up a localized string similar to Value with name &apos;{0}&apos; already exists..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExValueWithNameXIsNotFound">
            <summary>
              Looks up a localized string similar to Value with name &apos;{0}&apos; is not found..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExValueXIsNotAllowedHere">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not allowed or invalid here..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExWrongSourceCollectionElementType">
            <summary>
              Looks up a localized string similar to Source collection contains at least one item of type &quot;{0}&quot;, that cannot be cast to the item type of the destination collection..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ExXIsNeitherClassNorValueType">
            <summary>
              Looks up a localized string similar to The {0} is neither class nor value type..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.HasVersionFormat">
            <summary>
              Looks up a localized string similar to {0} (v{1}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.InfinitesimalFormat">
            <summary>
              Looks up a localized string similar to {0}{1}d.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.Infinity">
            <summary>
              Looks up a localized string similar to inf.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogAttemptToUseDisposedInstance">
            <summary>
              Looks up a localized string similar to Attempt to use disposed instance of type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogCantFindAssociateFor">
            <summary>
              Looks up a localized string similar to Can&apos;t find {0} (&apos;{1}&apos;) for type &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogException">
            <summary>
              Looks up a localized string similar to Exception!.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogGenericAssociateCreationHasFailedFor">
            <summary>
              Looks up a localized string similar to &apos;{0}&lt;{1}, {2}&gt;&apos; creation has failed for &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogGenericAssociateIsUsedFor">
            <summary>
              Looks up a localized string similar to &apos;{0}&lt;{1}, {2}&gt;&apos; was used for &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogRegionBegin">
            <summary>
              Looks up a localized string similar to {0}: started..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogRegionEnd">
            <summary>
              Looks up a localized string similar to {0}: completed..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogSafeDisposeFailing">
            <summary>
              Looks up a localized string similar to Safe dispose of &apos;{0}&apos; failing..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogScopeDisposeError">
            <summary>
              Looks up a localized string similar to Scope dispose error..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.LogUnableToGetDefaultHasherForTypeXxx">
            <summary>
              Looks up a localized string similar to Unable to get default hasher for type {0}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.NotAvailable">
            <summary>
              Looks up a localized string similar to n\a.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.Null">
            <summary>
              Looks up a localized string similar to null.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.OriginalExceptions">
            <summary>
              Looks up a localized string similar to Original exception(s).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.PairFormat">
            <summary>
              Looks up a localized string similar to ({0}, {1}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ReadOnly">
            <summary>
              Looks up a localized string similar to read-only.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ReadOnlyShort">
            <summary>
              Looks up a localized string similar to r/o.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ReadWrite">
            <summary>
              Looks up a localized string similar to read-write.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ReadWriteShort">
            <summary>
              Looks up a localized string similar to r/w.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.Recursive">
            <summary>
              Looks up a localized string similar to recursive.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ReferenceFormat">
            <summary>
              Looks up a localized string similar to #({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ReversedFormat">
            <summary>
              Looks up a localized string similar to Reversed({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.SegmentFormat">
            <summary>
              Looks up a localized string similar to [{0} ... {1}].
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.SerializationDataFormat">
            <summary>
              Looks up a localized string similar to Type=&apos;{0}&apos;, #=&apos;{1}&apos; ({2}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.SimpleLogFormat">
            <summary>
              Looks up a localized string similar to {3}: {5}.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.ThreadSafeCachedFormat">
            <summary>
              Looks up a localized string similar to ThreadSafeCached({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.TransformedTupleFormat">
            <summary>
              Looks up a localized string similar to {0}: {1} of ({2}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.TripletFormat">
            <summary>
              Looks up a localized string similar to ({0}, {1}, {2}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.TupleDescriptorFormat">
            <summary>
              Looks up a localized string similar to TupleDescriptor({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.TupleFormat">
            <summary>
              Looks up a localized string similar to ({0}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.TupleTransformFormat">
            <summary>
              Looks up a localized string similar to {0}({1}).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.UnableToDisposeItemWhenContainerIsNotDisposed">
            <summary>
              Looks up a localized string similar to Unable to dispose an item when disposable container has an invalid state..
            </summary>
        </member>
        <member name="P:Xtensive.Core.Resources.Strings.XInY">
            <summary>
              Looks up a localized string similar to {0} in {1}.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Collections.ISet">
            <summary>
            Set of items.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.Add(System.Object)">
            <summary>
            Adds the specified element to the <see cref="T:Xtensive.Core.Collections.ISet"/>.
            </summary>
            <param name="item">Item to add to the set.</param>
            <returns><see langword="true"/>if the element is added to the <see cref="T:Xtensive.Core.Collections.ISet"/> object; false if the element is already present.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.Remove(System.Object)">
            <summary>
            Removes the specified item from this instance.
            </summary>
            <param name="item">The item.</param>
            <returns><see langword="true"/> if the element is successfully found and removed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.RemoveWhere(System.Predicate{System.Object})">
            <summary>
            Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:Xtensive.Core.Collections.ISet"/> collection.
            </summary>
            <param name="match">The <see cref="T:System.Predicate`1"/> delegate that defines the conditions of the elements to remove.</param>
            <returns>The number of elements that were removed from the <see cref="T:Xtensive.Core.Collections.ISet"/> collection.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.Contains(System.Object)">
            <summary>
            Determines whether this instance contains the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns>
              <see langword="true"/> if this instance contains the specified item; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.IsDisjointWith(System.Collections.IEnumerable)">
            <summary>
            Determines if this instance is disjoint with the specified set.
            </summary>
            <param name="other">Set to check disjointness with.</param>
            <returns><see langword="true"/> if the two sets are disjoint; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
            <remarks>Two sets are disjoint if no item from one set is equal to any item from the other set.</remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.SetEquals(System.Collections.IEnumerable)">
            <summary>
            Determines if this instance is equal to another set. This set is equal to otherSet if they contain the same items.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <returns><see langword="true"/> if this set is equal to otherSet; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.IsProperSubsetOf(System.Collections.IEnumerable)">
            <summary>
            Determines if this instance is a proper subset of the specified set.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <returns><see langword="true"/> if this instance is a proper subset of <paramref name="other"/> set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
            <remarks>One set is a subset of second set if every element in first set is also contained in second set. 
            Additionally, first set must have strictly fewer items than second set.</remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.IsProperSupersetOf(System.Collections.IEnumerable)">
            <summary>
            Determines if this instance is a proper superset of the specified set.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <returns><see langword="true"/> if this instance is the proper superset of the specified set; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
            <remarks>One set is the proper superset of second set if every element in second set is also contained in the first set. 
            Additionally, first set must have strictly more items than second set.</remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.IsSubsetOf(System.Collections.IEnumerable)">
            <summary>
            Determines if this instance is a subset of the specified set.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <returns><see langword="true"/> if this instance is a proper subset of <paramref name="other"/> set.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
            <remarks>One set is a subset of second set if every element in first set is also contained in second set.</remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.IsSupersetOf(System.Collections.IEnumerable)">
            <summary>
            Determines if this instance is a superset of the specified set.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <returns><see langword="true"/> if this instance is the proper superset of the specified set; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
            <remarks>One set is the proper superset of second set if every element in second set is also contained in the first set.</remarks>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.Overlaps(System.Collections.IEnumerable)">
            <summary>
            Determines whether this instance overlaps the specified collection.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <returns><see langword="true"/> if this instance and <paramref name="other"/> share at least one common element; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.UnionWith(System.Collections.IEnumerable)">
            <summary>
            Modifies this instance to contain all elements that are present in both itself and in the specified collection.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.IntersectWith(System.Collections.IEnumerable)">
            <summary>
            Modifies this instance to contain only elements that are present in itself and in the specified collection.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.ExceptWith(System.Collections.IEnumerable)">
            <summary>
            Removes all elements in the specified collection from this instance.
            </summary>
            <param name="other">The collection of items to remove from this instance.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
        </member>
        <member name="M:Xtensive.Core.Collections.ISet.SymmetricExceptWith(System.Collections.IEnumerable)">
            <summary>
            Modifies this instance to contain only elements that are present in either itself, or in the specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to this instance.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is null.</exception>
        </member>
        <member name="P:Xtensive.Core.Collections.ISet.Item(System.Object)">
            <summary>
            Gets the <see cref="T:System.Object"/> with the specified item.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Collections.ISet.Count">
            <summary>
            Gets the number of elements contained in set.
            </summary>
            <value>The number of elements contained in set.</value>
        </member>
        <member name="P:Xtensive.Core.Collections.ISet.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.IEqualityComparer"/> object that is used to determine equality for the values in this instance.
            </summary>
            <value>The <see cref="T:System.Collections.IEqualityComparer"/> object that is used to determine equality for the values in this instance.</value>
        </member>
        <member name="T:Xtensive.Core.IHasVersion">
            <summary>
            Allows to track changes in object by its <see cref="P:Xtensive.Core.IHasVersion.Version"/>.
            </summary>
        </member>
        <member name="P:Xtensive.Core.IHasVersion.Version">
            <summary>
            Gets object version.
            Object isn't changed, while its
            <c>oldVersion.Equals(newVersion)</c>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.IHasVersion`1">
            <summary>
            Allows to track changes in object by its <see cref="P:Xtensive.Core.IHasVersion`1.Version"/>.
            </summary>
            <typeparam name="T">The type <see cref="P:Xtensive.Core.IHasVersion`1.Version"/> property.</typeparam>
        </member>
        <member name="P:Xtensive.Core.IHasVersion`1.Version">
            <summary>
            Gets object version.
            Object isn't changed, while its
            <c>oldVersion.Equals(newVersion)</c>.
            </summary>
        </member>
        <member name="T:Xtensive.Core.Caching.MfLruCache`2">
            <summary>
            A set of items limited by the maximal count of them.
            Stores as many most recently and frequently accessed items in memory as long as it is possible.
            </summary>
            <typeparam name="TKey">The key of the item.</typeparam>
            <typeparam name="TItem">The type of the item to cache.</typeparam>
        </member>
        <member name="F:Xtensive.Core.Caching.MfLruCache`2.DefaultEfficiencyFactor">
            <summary>
            Default <see cref="P:Xtensive.Core.Caching.MfLruCache`2.EfficiencyFactor"/> value.
            Value is <see langword="4"/>.
            </summary>
        </member>
        <member name="F:Xtensive.Core.Caching.MfLruCache`2.NoGcCount">
            <summary>
            Minimal <see cref="P:Xtensive.Core.Caching.MfLruCache`2.Count"/> value, until which <see cref="M:Xtensive.Core.Caching.MfLruCache`2.CollectGarbage"/> doesn't start at all.
            Value is <see langword="1024"/>.
            </summary>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.TryGetItem(`0,System.Boolean,`1@)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.Contains(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.Add(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.Add(`1,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.Remove(`1)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.RemoveKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.Invalidate">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.CollectGarbage">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.#ctor(System.Int32,System.Int32,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="lruCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.LruCapacity"/> property value.</param>
            <param name="mfuCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.MfuCapacity"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.MfLruCache`2.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.#ctor(System.Int32,System.Int32,System.Int32,System.Converter{`1,`0})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="lruCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.LruCapacity"/> property value.</param>
            <param name="mfuCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.MfuCapacity"/> property value.</param>
            <param name="efficiencyFactor">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.EfficiencyFactor"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.MfLruCache`2.KeyExtractor"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.#ctor(System.Int32,System.Int32,System.Converter{`1,`0},Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="lruCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.LruCapacity"/> property value.</param>
            <param name="mfuCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.MfuCapacity"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.MfLruCache`2.KeyExtractor"/> property value.</param>
            <param name="chainedCache"><see cref="P:Xtensive.Core.Caching.MfLruCache`2.ChainedCache"/> property value.</param>
        </member>
        <member name="M:Xtensive.Core.Caching.MfLruCache`2.#ctor(System.Int32,System.Int32,System.Int32,System.Converter{`1,`0},Xtensive.Core.Caching.ICache{`0,`1})">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="lruCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.LruCapacity"/> property value.</param>
            <param name="mfuCapacity">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.MfuCapacity"/> property value.</param>
            <param name="efficiencyFactor">The <see cref="P:Xtensive.Core.Caching.MfLruCache`2.EfficiencyFactor"/> property value.</param>
            <param name="keyExtractor"><see cref="P:Xtensive.Core.Caching.MfLruCache`2.KeyExtractor"/> property value.</param>
            <param name="chainedCache"><see cref="P:Xtensive.Core.Caching.MfLruCache`2.ChainedCache"/> property value.</param>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.KeyExtractor">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.ChainedCache">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.LruCapacity">
            <summary>
            Gets the Least Recently Used capacity.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.MfuCapacity">
            <summary>
            Gets the Most Frequently Used capacity.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.Capacity">
            <summary>
            Gets the total capacity (<see cref="P:Xtensive.Core.Caching.MfLruCache`2.LruCapacity"/> + <see cref="P:Xtensive.Core.Caching.MfLruCache`2.MfuCapacity"/>).
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.EfficiencyFactor">
            <summary>
            Gets the time shift factor offset.
            </summary>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.Xtensive#Core#Collections#ICountable#Count">
            <inheritdoc/>
        </member>
        <member name="P:Xtensive.Core.Caching.MfLruCache`2.Item(`0,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:Xtensive.Core.Threading.Locker">
            <summary>
            Lock utility - a helper class providing more convenient ways for dealing
            with various locks (<see cref="T:System.Threading.Monitor"/>, <see cref="T:System.Threading.ReaderWriterLockSlim"/>).
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ExecuteReader(System.Object,System.Action)">
            <summary>
            Executes a <paramref name="reader"/> delegate
            with lock on <paramref name="toLock"/> object.
            </summary>
            <param name="toLock">An object to lock.</param>
            <param name="reader">A reader delegate.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ExecuteReader``1(System.Object,System.Func{``0})">
            <summary>
            Executes a <paramref name="reader"/> delegate
            with lock on <paramref name="toLock"/> object.
            </summary>
            <typeparam name="T">A delegate return type.</typeparam>
            <param name="toLock">An object to lock.</param>
            <param name="reader">A reader delegate.</param>
            <returns>An object that <paramref name="reader"/> returns.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ExecuteWriter(System.Object,System.Action)">
            <summary>
            Executes a <paramref name="writer"/> delegate
            with lock on <paramref name="toLock"/> object.
            </summary>
            <param name="toLock">An object to lock.</param>
            <param name="writer">A writer delegate.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ExecuteWriter``1(System.Object,System.Func{``0})">
            <summary>
            Executes a <paramref name="writer"/> delegate
            with lock on <paramref name="toLock"/> object.
            </summary>
            <typeparam name="T">A delegate return type.</typeparam>
            <param name="toLock">An object to lock.</param>
            <param name="writer">A writer delegate.</param>
            <returns>An object that <paramref name="writer"/> returns.
            </returns>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.BeginRead(System.Object)">
            <summary>
            Attempts to acquire the lock in read mode.
            </summary>
            <param name="toLock">The object to acquire the lock on.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.EndRead(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Releases the read lock.
            </summary>
            <param name="rwLock">The object to release the lock from.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.BeginRead(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Attempts to acquire the lock in read mode.
            </summary>
            <param name="rwLock">The object to acquire the lock on.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.EndRead(System.Object)">
            <summary>
            Releases the read lock.
            </summary>
            <param name="toLock">The object to release the lock from.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.BeginWrite(System.Object)">
            <summary>
            Attempts to acquire the lock in write mode.
            </summary>
            <param name="toLock">The object to acquire the lock on.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.EndWrite(System.Object,System.Nullable{System.Threading.LockCookie})">
            <summary>
            Releases the write lock.
            </summary>
            <param name="toLock">The object to release the lock from.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.BeginWrite(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Attempts to acquire the lock in write mode.
            </summary>
            <param name="rwLock">The object to acquire the lock on.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.EndWrite(System.Threading.ReaderWriterLockSlim,System.Nullable{System.Threading.LockCookie})">
            <summary>
            Releases the write lock.
            </summary>
            <param name="rwLock">The object to release the lock from.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ReadController.#ctor(System.Threading.ReaderWriterLockSlim)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="rwLock">The <see cref="T:System.Threading.ReaderWriterLockSlim"/> to lock.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ReadController.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ReadLockController.#ctor(System.Object)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="toLock">To object to lock.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.ReadLockController.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.WriteController.#ctor(System.Threading.ReaderWriterLockSlim)">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="rwLock">The <see cref="T:System.Threading.ReaderWriterLockSlim"/> to lock.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.WriteController.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.WriteLockController.#ctor(System.Object)">
            <summary>
              <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Ctor" copy="true"/>
            </summary>
            <param name="toLock">The object to lock.</param>
        </member>
        <member name="M:Xtensive.Core.Threading.Locker.WriteLockController.Dispose">
            <summary>
            <see cref="M:Xtensive.Core.Internals.DocTemplates.ClassDocTemplate.Dispose" copy="true"/>
            </summary>
        </member>
        <member name="T:Xtensive.Core.UrlInfoConverter">
            <summary>
            Provides a type converter to convert <see cref="T:Xtensive.Core.UrlInfo"/> objects to and from other representations.
            </summary>
        </member>
        <member name="M:Xtensive.Core.UrlInfoConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfoConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Xtensive.Core.UrlInfoConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc/>
        </member>
    </members>
</doc>
